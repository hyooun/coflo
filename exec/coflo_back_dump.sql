--
-- PostgreSQL database dump
--

-- Dumped from database version 16.4 (Debian 16.4-1.pgdg120+2)
-- Dumped by pg_dump version 16.4

-- Started on 2024-11-18 16:11:04

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 2 (class 3079 OID 23244)
-- Name: vector; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS vector WITH SCHEMA public;


--
-- TOC entry 3879 (class 0 OID 0)
-- Dependencies: 2
-- Name: EXTENSION vector; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION vector IS 'vector data type and ivfflat and hnsw access methods';


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- TOC entry 216 (class 1259 OID 35455)
-- Name: badge; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.badge (
    id bigint NOT NULL,
    description character varying(255) NOT NULL,
    image_url character varying(255) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.badge OWNER TO reviewping;

--
-- TOC entry 217 (class 1259 OID 35460)
-- Name: badge_code; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.badge_code (
    id bigint NOT NULL,
    description character varying(255) NOT NULL,
    image_url character varying(255) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.badge_code OWNER TO reviewping;

--
-- TOC entry 218 (class 1259 OID 35465)
-- Name: badge_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.badge ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.badge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 219 (class 1259 OID 35466)
-- Name: batch_job_execution; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_job_execution (
    job_execution_id bigint NOT NULL,
    version bigint,
    job_instance_id bigint NOT NULL,
    create_time timestamp without time zone NOT NULL,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    status character varying(10),
    exit_code character varying(2500),
    exit_message character varying(2500),
    last_updated timestamp without time zone
);


ALTER TABLE public.batch_job_execution OWNER TO reviewping;

--
-- TOC entry 220 (class 1259 OID 35471)
-- Name: batch_job_execution_context; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_job_execution_context (
    job_execution_id bigint NOT NULL,
    short_context character varying(2500) NOT NULL,
    serialized_context text
);


ALTER TABLE public.batch_job_execution_context OWNER TO reviewping;

--
-- TOC entry 221 (class 1259 OID 35476)
-- Name: batch_job_execution_params; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_job_execution_params (
    job_execution_id bigint NOT NULL,
    parameter_name character varying(100) NOT NULL,
    parameter_type character varying(100) NOT NULL,
    parameter_value character varying(2500),
    identifying character(1) NOT NULL
);


ALTER TABLE public.batch_job_execution_params OWNER TO reviewping;

--
-- TOC entry 222 (class 1259 OID 35481)
-- Name: batch_job_execution_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

CREATE SEQUENCE public.batch_job_execution_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.batch_job_execution_seq OWNER TO reviewping;

--
-- TOC entry 223 (class 1259 OID 35482)
-- Name: batch_job_instance; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_job_instance (
    job_instance_id bigint NOT NULL,
    version bigint,
    job_name character varying(100) NOT NULL,
    job_key character varying(32) NOT NULL
);


ALTER TABLE public.batch_job_instance OWNER TO reviewping;

--
-- TOC entry 224 (class 1259 OID 35485)
-- Name: batch_job_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

CREATE SEQUENCE public.batch_job_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.batch_job_seq OWNER TO reviewping;

--
-- TOC entry 225 (class 1259 OID 35486)
-- Name: batch_step_execution; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_step_execution (
    step_execution_id bigint NOT NULL,
    version bigint NOT NULL,
    step_name character varying(100) NOT NULL,
    job_execution_id bigint NOT NULL,
    create_time timestamp without time zone NOT NULL,
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    status character varying(10),
    commit_count bigint,
    read_count bigint,
    filter_count bigint,
    write_count bigint,
    read_skip_count bigint,
    write_skip_count bigint,
    process_skip_count bigint,
    rollback_count bigint,
    exit_code character varying(2500),
    exit_message character varying(2500),
    last_updated timestamp without time zone
);


ALTER TABLE public.batch_step_execution OWNER TO reviewping;

--
-- TOC entry 226 (class 1259 OID 35491)
-- Name: batch_step_execution_context; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.batch_step_execution_context (
    step_execution_id bigint NOT NULL,
    short_context character varying(2500) NOT NULL,
    serialized_context text
);


ALTER TABLE public.batch_step_execution_context OWNER TO reviewping;

--
-- TOC entry 227 (class 1259 OID 35496)
-- Name: batch_step_execution_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

CREATE SEQUENCE public.batch_step_execution_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.batch_step_execution_seq OWNER TO reviewping;

--
-- TOC entry 228 (class 1259 OID 35497)
-- Name: best_mr_history; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.best_mr_history (
    created_date date NOT NULL,
    id bigint NOT NULL,
    user_id bigint NOT NULL
);


ALTER TABLE public.best_mr_history OWNER TO reviewping;

--
-- TOC entry 229 (class 1259 OID 35500)
-- Name: best_mr_history_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.best_mr_history ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.best_mr_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 230 (class 1259 OID 35501)
-- Name: branch; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.branch (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    project_id bigint,
    name character varying(255)
);


ALTER TABLE public.branch OWNER TO reviewping;

--
-- TOC entry 231 (class 1259 OID 35504)
-- Name: branch_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.branch ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.branch_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 232 (class 1259 OID 35505)
-- Name: channel_code; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.channel_code (
    id bigint NOT NULL,
    name character varying(255),
    image_url character varying(255),
    CONSTRAINT channel_code_name_check CHECK (((name)::text = ANY (ARRAY[('MATTERMOST'::character varying)::text, ('DISCORD'::character varying)::text])))
);


ALTER TABLE public.channel_code OWNER TO reviewping;

--
-- TOC entry 233 (class 1259 OID 35509)
-- Name: code_quality; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.code_quality (
    id bigint NOT NULL,
    name character varying(255)
);


ALTER TABLE public.code_quality OWNER TO reviewping;

--
-- TOC entry 234 (class 1259 OID 35512)
-- Name: code_quality_code; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.code_quality_code (
    id bigint NOT NULL,
    name character varying(255)
);


ALTER TABLE public.code_quality_code OWNER TO reviewping;

--
-- TOC entry 235 (class 1259 OID 35515)
-- Name: code_quality_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.code_quality ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.code_quality_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 236 (class 1259 OID 35516)
-- Name: custom_prompt; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.custom_prompt (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    project_id bigint,
    content character varying(1000)
);


ALTER TABLE public.custom_prompt OWNER TO reviewping;

--
-- TOC entry 237 (class 1259 OID 35519)
-- Name: custom_prompt_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.custom_prompt ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.custom_prompt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 238 (class 1259 OID 35520)
-- Name: gitlab_account; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.gitlab_account (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    user_id bigint,
    visited_project_id bigint,
    domain character varying(255) NOT NULL,
    user_token character varying(255) NOT NULL
);


ALTER TABLE public.gitlab_account OWNER TO reviewping;

--
-- TOC entry 239 (class 1259 OID 35525)
-- Name: gitlab_account_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.gitlab_account ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.gitlab_account_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 240 (class 1259 OID 35526)
-- Name: language; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.language (
    id bigint NOT NULL,
    type character varying(255),
    CONSTRAINT language_type_check CHECK (((type)::text = ANY (ARRAY[('TYPESCRIPT'::character varying)::text, ('JAVASCRIPT'::character varying)::text, ('PYTHON'::character varying)::text, ('JAVA'::character varying)::text, ('C'::character varying)::text, ('CPP'::character varying)::text, ('CSHARP'::character varying)::text, ('GO'::character varying)::text, ('RUBY'::character varying)::text, ('RUST'::character varying)::text, ('SWIFT'::character varying)::text, ('PHP'::character varying)::text, ('SHELL'::character varying)::text, ('SQL'::character varying)::text, ('HTML'::character varying)::text, ('CSS'::character varying)::text, ('PLAINTEXT'::character varying)::text])))
);


ALTER TABLE public.language OWNER TO reviewping;

--
-- TOC entry 241 (class 1259 OID 35530)
-- Name: language_code; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.language_code (
    id bigint NOT NULL,
    color character varying(255),
    name character varying(255)
);


ALTER TABLE public.language_code OWNER TO reviewping;

--
-- TOC entry 242 (class 1259 OID 35535)
-- Name: language_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.language ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.language_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 243 (class 1259 OID 35536)
-- Name: login_history; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.login_history (
    login_date date NOT NULL,
    id bigint NOT NULL,
    user_id bigint NOT NULL
);


ALTER TABLE public.login_history OWNER TO reviewping;

--
-- TOC entry 244 (class 1259 OID 35539)
-- Name: login_history_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.login_history ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.login_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 245 (class 1259 OID 35540)
-- Name: mr_info; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.mr_info (
    consistency_score integer,
    maintainability_score integer,
    readability_score integer,
    reliability_score integer,
    reusability_score integer,
    security_score integer,
    created_date timestamp(6) without time zone NOT NULL,
    gitlab_created_date timestamp(6) without time zone,
    gitlab_mr_iid bigint NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    project_id bigint
);


ALTER TABLE public.mr_info OWNER TO reviewping;

--
-- TOC entry 246 (class 1259 OID 35543)
-- Name: mr_info_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.mr_info ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.mr_info_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 268 (class 1259 OID 36284)
-- Name: notification; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.notification (
    is_read boolean NOT NULL,
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    user_project_id bigint,
    content character varying(255) NOT NULL,
    target_url character varying(255)
);


ALTER TABLE public.notification OWNER TO reviewping;

--
-- TOC entry 267 (class 1259 OID 36283)
-- Name: notification_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.notification ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.notification_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 247 (class 1259 OID 35544)
-- Name: project; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.project (
    created_date timestamp(6) without time zone NOT NULL,
    gitlab_project_id bigint NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    bot_token character varying(255) NOT NULL,
    full_path character varying(255),
    git_url character varying(255),
    name character varying(255)
);


ALTER TABLE public.project OWNER TO reviewping;

--
-- TOC entry 248 (class 1259 OID 35549)
-- Name: project_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.project ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.project_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 249 (class 1259 OID 35550)
-- Name: prompt_history; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.prompt_history (
    id bigint NOT NULL,
    update_date_time timestamp(6) without time zone NOT NULL,
    user_id bigint NOT NULL
);


ALTER TABLE public.prompt_history OWNER TO reviewping;

--
-- TOC entry 250 (class 1259 OID 35553)
-- Name: prompt_history_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.prompt_history ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.prompt_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 251 (class 1259 OID 35554)
-- Name: retrieval; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.retrieval (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    language_id bigint,
    modified_date timestamp(6) without time zone NOT NULL,
    review_id bigint,
    content text NOT NULL,
    file_name character varying(255) NOT NULL
);


ALTER TABLE public.retrieval OWNER TO reviewping;

--
-- TOC entry 252 (class 1259 OID 35559)
-- Name: retrieval_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.retrieval ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.retrieval_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 253 (class 1259 OID 35560)
-- Name: review; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.review (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    mr_info_id bigint,
    content text NOT NULL
);


ALTER TABLE public.review OWNER TO reviewping;

--
-- TOC entry 254 (class 1259 OID 35565)
-- Name: review_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.review ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.review_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 255 (class 1259 OID 35566)
-- Name: software_quality; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.software_quality (
    id bigint NOT NULL,
    name character varying(255)
);


ALTER TABLE public.software_quality OWNER TO reviewping;

--
-- TOC entry 256 (class 1259 OID 35569)
-- Name: software_quality_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.software_quality ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.software_quality_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 257 (class 1259 OID 35570)
-- Name: user; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public."user" (
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    main_badge_code_id bigint,
    modified_date timestamp(6) without time zone NOT NULL,
    oauth2id character varying(255) NOT NULL,
    profile_image_url character varying(255),
    provider character varying(255) NOT NULL,
    role character varying(255) NOT NULL,
    username character varying(255),
    CONSTRAINT user_provider_check CHECK (((provider)::text = ANY (ARRAY[('GOOGLE'::character varying)::text, ('KAKAO'::character varying)::text]))),
    CONSTRAINT user_role_check CHECK (((role)::text = 'USER'::text))
);


ALTER TABLE public."user" OWNER TO reviewping;

--
-- TOC entry 258 (class 1259 OID 35577)
-- Name: user_badge; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.user_badge (
    badge_code_id bigint,
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    user_id bigint
);


ALTER TABLE public.user_badge OWNER TO reviewping;

--
-- TOC entry 259 (class 1259 OID 35580)
-- Name: user_badge_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.user_badge ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_badge_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 260 (class 1259 OID 35581)
-- Name: user_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public."user" ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 261 (class 1259 OID 35582)
-- Name: user_project; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.user_project (
    created_date timestamp(6) without time zone NOT NULL,
    gitlab_account_id bigint,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    project_id bigint
);


ALTER TABLE public.user_project OWNER TO reviewping;

--
-- TOC entry 262 (class 1259 OID 35585)
-- Name: user_project_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.user_project ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_project_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 263 (class 1259 OID 35586)
-- Name: user_project_score; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.user_project_score (
    week integer NOT NULL,
    code_quality_code_id bigint,
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    total_score bigint,
    user_project_id bigint
);


ALTER TABLE public.user_project_score OWNER TO reviewping;

--
-- TOC entry 264 (class 1259 OID 35589)
-- Name: user_project_score_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.user_project_score ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_project_score_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 265 (class 1259 OID 35590)
-- Name: webhook_channel; Type: TABLE; Schema: public; Owner: reviewping
--

CREATE TABLE public.webhook_channel (
    channel_code_id bigint,
    created_date timestamp(6) without time zone NOT NULL,
    id bigint NOT NULL,
    modified_date timestamp(6) without time zone NOT NULL,
    project_id bigint,
    webhook_url character varying(255) NOT NULL
);


ALTER TABLE public.webhook_channel OWNER TO reviewping;

--
-- TOC entry 266 (class 1259 OID 35593)
-- Name: webhook_channel_id_seq; Type: SEQUENCE; Schema: public; Owner: reviewping
--

ALTER TABLE public.webhook_channel ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.webhook_channel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 3821 (class 0 OID 35455)
-- Dependencies: 216
-- Data for Name: badge; Type: TABLE DATA; Schema: public; Owner: reviewping
--



--
-- TOC entry 3822 (class 0 OID 35460)
-- Dependencies: 217
-- Data for Name: badge_code; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.badge_code VALUES (1, '처음 서비스 가입 시 기본 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%EC%B2%AB%EB%AA%A8%ED%97%98%EA%B0%80.png', '첫 모험가');
INSERT INTO public.badge_code VALUES (2, '첫 AI리뷰 재생성', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%EB%A6%AC%EB%B7%B0%ED%83%90%EC%83%89%EC%9E%90.png', '리뷰 탐색자');
INSERT INTO public.badge_code VALUES (3, '연동한 프로젝트 개수 20개 이상 시 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/ProjectMaster.png', '프로젝트 마스터');
INSERT INTO public.badge_code VALUES (4, 'AI 리뷰평가 리워드 합이 55점 이상 시 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/CodeMaster.png', '코드 마스터');
INSERT INTO public.badge_code VALUES (5, '접속 시 3% 확률로 랜덤 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%ED%96%89%EC%9A%B4%EC%9D%98%EB%B0%9C%EA%B2%AC.png', '행운의 발견');
INSERT INTO public.badge_code VALUES (6, '서비스 로그인 100회 이상 (1일 1회)', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%EB%8B%A8%EA%B3%A8%EC%86%90%EB%8B%98.png', '단골 손님');
INSERT INTO public.badge_code VALUES (7, '베스트 MR에 50회 이상 선정 시 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%EC%A0%95%EB%B3%B5%EC%9E%90.png', '정복자');
INSERT INTO public.badge_code VALUES (8, '커스텀 프롬포트 등록/수정 100회 이상', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%EC%B0%BD%EC%A1%B0%EC%9E%90.png', '프롬프트 창조자');
INSERT INTO public.badge_code VALUES (9, '9개의 뱃지를 모두 획득하면 획득', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/%EC%A0%84%EC%84%A4%EC%9D%98%EB%AA%A8%ED%97%98%EA%B0%80.png', '전설의 모험가');


--
-- TOC entry 3824 (class 0 OID 35466)
-- Dependencies: 219
-- Data for Name: batch_job_execution; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_job_execution VALUES (1, 2, 1, '2024-11-18 00:05:00.02931', '2024-11-18 00:05:00.060052', '2024-11-18 00:05:00.195731', 'COMPLETED', 'COMPLETED', '', '2024-11-18 00:05:00.196125');
INSERT INTO public.batch_job_execution VALUES (2, 2, 2, '2024-11-18 00:05:00.20897', '2024-11-18 00:05:00.214156', '2024-11-18 00:05:00.392836', 'FAILED', 'FAILED', 'org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:804)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:758)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:152)
	at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:255)
	at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82)
	at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:369)
	at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:206)
	at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:140)
	at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:240)
	at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:229)
	at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:153)
	at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:418)
	at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:132)
	at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:317)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:157)
	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:148)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.reviewping.coflo.global.batch.BatchJobScheduler.runBestMergeRequestJob(BatchJobScheduler.java:36)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.scheduling.support.ScheduledMethodRunnable.runInternal(ScheduledMethodRunnable.java:130)
	at org.springframework.scheduling.support.ScheduledMethodRunnable.lambda$run$2(ScheduledMethodRunnable.java:124)
	at io.micrometer.observation.Observation.observe(Observa', '2024-11-18 00:05:00.392935');


--
-- TOC entry 3825 (class 0 OID 35471)
-- Dependencies: 220
-- Data for Name: batch_job_execution_context; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_job_execution_context VALUES (1, 'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAANYmF0Y2gudmVyc2lvbnQABTUuMS4yeA==', NULL);
INSERT INTO public.batch_job_execution_context VALUES (2, 'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABdAANYmF0Y2gudmVyc2lvbnQABTUuMS4yeA==', NULL);


--
-- TOC entry 3826 (class 0 OID 35476)
-- Dependencies: 221
-- Data for Name: batch_job_execution_params; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_job_execution_params VALUES (1, 'time', 'java.lang.Long', '1731855900003', 'Y');
INSERT INTO public.batch_job_execution_params VALUES (2, 'time', 'java.lang.Long', '1731855900202', 'Y');


--
-- TOC entry 3828 (class 0 OID 35482)
-- Dependencies: 223
-- Data for Name: batch_job_instance; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_job_instance VALUES (1, 0, 'aiRewardEventJob', 'bb65e553a6dedea97a6d8d95d6fb94c9');
INSERT INTO public.batch_job_instance VALUES (2, 0, 'bestMergeRequestJob', '372c0f58eb27002c48868697c19a669d');


--
-- TOC entry 3830 (class 0 OID 35486)
-- Dependencies: 225
-- Data for Name: batch_step_execution; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_step_execution VALUES (1, 3, 'aiRewardEventStep', 1, '2024-11-18 00:05:00.072805', '2024-11-18 00:05:00.078584', '2024-11-18 00:05:00.188608', 'COMPLETED', 1, 0, 0, 0, 0, 0, 0, 0, 'COMPLETED', '', '2024-11-18 00:05:00.189388');
INSERT INTO public.batch_step_execution VALUES (2, 2, 'addBestMrHistoryStep', 2, '2024-11-18 00:05:00.220426', '2024-11-18 00:05:00.224341', '2024-11-18 00:05:00.38692', 'FAILED', 0, 0, 0, 0, 0, 0, 0, 1, 'FAILED', 'org.springframework.transaction.UnexpectedRollbackException: Transaction silently rolled back because it has been marked as rollback-only
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:804)
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:758)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:152)
	at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:255)
	at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:82)
	at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:369)
	at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:206)
	at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:140)
	at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:240)
	at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:229)
	at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:153)
	at org.springframework.batch.core.job.AbstractJob.handleStep(AbstractJob.java:418)
	at org.springframework.batch.core.job.SimpleJob.doExecute(SimpleJob.java:132)
	at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:317)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:157)
	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:50)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:148)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.reviewping.coflo.global.batch.BatchJobScheduler.runBestMergeRequestJob(BatchJobScheduler.java:36)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.scheduling.support.ScheduledMethodRunnable.runInternal(ScheduledMethodRunnable.java:130)
	at org.springframework.scheduling.support.ScheduledMethodRunnable.lambda$run$2(ScheduledMethodRunnable.java:124)
	at io.micrometer.observation.Observation.observe(Observa', '2024-11-18 00:05:00.387505');


--
-- TOC entry 3831 (class 0 OID 35491)
-- Dependencies: 226
-- Data for Name: batch_step_execution_context; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.batch_step_execution_context VALUES (1, 'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAADdAARYmF0Y2gudGFza2xldFR5cGV0AEZjb20ucmV2aWV3cGluZy5jb2Zsby5nbG9iYWwuYmF0Y2guQWlSZXdhcmRUb3RhbFRhc2tsZXQkJFNwcmluZ0NHTElCJCQwdAANYmF0Y2gudmVyc2lvbnQABTUuMS4ydAAOYmF0Y2guc3RlcFR5cGV0ADdvcmcuc3ByaW5nZnJhbWV3b3JrLmJhdGNoLmNvcmUuc3RlcC50YXNrbGV0LlRhc2tsZXRTdGVweA==', NULL);
INSERT INTO public.batch_step_execution_context VALUES (2, 'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAADdAARYmF0Y2gudGFza2xldFR5cGV0AFBjb20ucmV2aWV3cGluZy5jb2Zsby5nbG9iYWwuYmF0Y2guQmVzdE1lcmdlUmVxdWVzdEhpc3RvcnlUYXNrbGV0JCRTcHJpbmdDR0xJQiQkMHQADWJhdGNoLnZlcnNpb250AAU1LjEuMnQADmJhdGNoLnN0ZXBUeXBldAA3b3JnLnNwcmluZ2ZyYW1ld29yay5iYXRjaC5jb3JlLnN0ZXAudGFza2xldC5UYXNrbGV0U3RlcHg=', NULL);


--
-- TOC entry 3833 (class 0 OID 35497)
-- Dependencies: 228
-- Data for Name: best_mr_history; Type: TABLE DATA; Schema: public; Owner: reviewping
--



--
-- TOC entry 3835 (class 0 OID 35501)
-- Dependencies: 230
-- Data for Name: branch; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.branch VALUES ('2024-11-11 15:24:18.077573', 1, '2024-11-11 15:24:18.077573', 1, 'fe/dev');
INSERT INTO public.branch VALUES ('2024-11-11 15:24:18.082693', 2, '2024-11-11 15:24:18.082693', 1, 'be/dev');
INSERT INTO public.branch VALUES ('2024-11-11 15:24:18.084125', 3, '2024-11-11 15:24:18.084125', 1, 'main');
INSERT INTO public.branch VALUES ('2024-11-12 10:41:01', 4, '2024-11-12 10:41:06', 1, 'ai/dev');
INSERT INTO public.branch VALUES ('2024-11-16 12:14:34.287273', 5, '2024-11-16 12:14:34.287273', 2, 'master');


--
-- TOC entry 3837 (class 0 OID 35505)
-- Dependencies: 232
-- Data for Name: channel_code; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.channel_code VALUES (1, 'MATTERMOST', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/mattermost_logo.png');
INSERT INTO public.channel_code VALUES (2, 'DISCORD', 'https://khmbucket.s3.ap-northeast-2.amazonaws.com/discord_logo.png');


--
-- TOC entry 3838 (class 0 OID 35509)
-- Dependencies: 233
-- Data for Name: code_quality; Type: TABLE DATA; Schema: public; Owner: reviewping
--



--
-- TOC entry 3839 (class 0 OID 35512)
-- Dependencies: 234
-- Data for Name: code_quality_code; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.code_quality_code VALUES (1, '가독성');
INSERT INTO public.code_quality_code VALUES (2, '일관성');
INSERT INTO public.code_quality_code VALUES (3, '재사용성');
INSERT INTO public.code_quality_code VALUES (4, '신뢰성');
INSERT INTO public.code_quality_code VALUES (5, '보안성');
INSERT INTO public.code_quality_code VALUES (6, '유지보수성');


--
-- TOC entry 3841 (class 0 OID 35516)
-- Dependencies: 236
-- Data for Name: custom_prompt; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.custom_prompt VALUES ('2024-11-16 12:14:34.274266', 2, '2024-11-16 12:14:34.274266', 2, '');
INSERT INTO public.custom_prompt VALUES ('2024-11-11 15:24:18.069058', 1, '2024-11-17 16:03:04.719619', 1, '주어진 참고자료를 보고 변경사항을 검토해줘. 놓친 예외케이스가 없는 지 중점적으로 검토해줘!!');


--
-- TOC entry 3843 (class 0 OID 35520)
-- Dependencies: 238
-- Data for Name: gitlab_account; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.gitlab_account VALUES ('2024-11-11 15:23:31.139481', 1, '2024-11-11 15:23:31.139481', 1, NULL, 'lab.ssafy.com', 'CKjXhW0x5sGdBN8hp9FMkIj5qgUCOo5nQY3DjYXZJZY=');
INSERT INTO public.gitlab_account VALUES ('2024-10-18 09:00:00', 4, '2024-10-18 09:00:00', 3, NULL, 'lab.ssafy.com', 'Ya1ywMsx1UbAjj3Iv/BVEpbtH56KNSXNCXNry9ao5Ns=');
INSERT INTO public.gitlab_account VALUES ('2024-11-11 15:28:00.915732', 3, '2024-11-11 15:28:00.915732', 4, NULL, 'lab.ssafy.com', 'dtKzHalnJCj4yhE5ELDBmGM/f4OLOLxKnQcgCX/KFLM=');
INSERT INTO public.gitlab_account VALUES ('2024-11-11 15:27:12.824231', 2, '2024-11-11 15:27:12.824231', 2, NULL, 'lab.ssafy.com', 'cZ18CJJ839HMTHagwpy8pHTtJBW7BnjviW2HEkdvYos=');
INSERT INTO public.gitlab_account VALUES ('2024-11-11 17:02:56.088567', 9, '2024-11-11 17:02:56.088567', 6, NULL, 'lab.ssafy.com', 'nflU+fBCiVP3y4H0m8p8H+u7aeJnTHA6QCuBA0AyI7A=');
INSERT INTO public.gitlab_account VALUES ('2024-11-15 12:39:15.347827', 11, '2024-11-15 12:39:15.347827', 9, NULL, 'lab.ssafy.com', 'sm6OSoyk30hLWkre4ljgisMKWqDRKEs691dHh4+jc3A=');
INSERT INTO public.gitlab_account VALUES ('2024-11-17 13:09:37.896395', 16, '2024-11-17 13:09:37.896395', 14, NULL, 'lab.ssafy.com', 'C6h269aDQqfnkDfYsQ6sJdC8rGhMxhyH8AgSMM/6m/w=');
INSERT INTO public.gitlab_account VALUES ('2024-11-18 15:40:35.564213', 18, '2024-11-18 15:40:35.564213', 15, NULL, 'lab.ssafy.com', 'iNf5qjf1Q+X9xyG0ZaBx/IhPcQROKhDdlcgmw2JNF1M=');


--
-- TOC entry 3845 (class 0 OID 35526)
-- Dependencies: 240
-- Data for Name: language; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.language VALUES (1, 'TYPESCRIPT');
INSERT INTO public.language VALUES (2, 'JAVASCRIPT');
INSERT INTO public.language VALUES (3, 'PYTHON');
INSERT INTO public.language VALUES (4, 'JAVA');
INSERT INTO public.language VALUES (5, 'C');
INSERT INTO public.language VALUES (6, 'CPP');
INSERT INTO public.language VALUES (7, 'CSHARP');
INSERT INTO public.language VALUES (8, 'GO');
INSERT INTO public.language VALUES (9, 'RUBY');
INSERT INTO public.language VALUES (10, 'RUST');
INSERT INTO public.language VALUES (11, 'SWIFT');
INSERT INTO public.language VALUES (12, 'PHP');
INSERT INTO public.language VALUES (13, 'SHELL');
INSERT INTO public.language VALUES (14, 'SQL');
INSERT INTO public.language VALUES (15, 'HTML');
INSERT INTO public.language VALUES (16, 'CSS');
INSERT INTO public.language VALUES (17, 'PLAINTEXT');


--
-- TOC entry 3846 (class 0 OID 35530)
-- Dependencies: 241
-- Data for Name: language_code; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.language_code VALUES (1, '#abcdef', 'Mercury');
INSERT INTO public.language_code VALUES (2, '#31859c', 'TypeScript');
INSERT INTO public.language_code VALUES (3, '#5a6986', 'PureBasic');
INSERT INTO public.language_code VALUES (4, '#4886FC', 'Objective-C++');
INSERT INTO public.language_code VALUES (5, '#0579aa', 'Self');
INSERT INTO public.language_code VALUES (6, '#db5855', 'edn');
INSERT INTO public.language_code VALUES (7, '#eedd66', 'NewLisp');
INSERT INTO public.language_code VALUES (8, '#358a5b', 'Rebol');
INSERT INTO public.language_code VALUES (9, '#00cafe', 'Frege');
INSERT INTO public.language_code VALUES (10, '#98BAD6', 'Dart');
INSERT INTO public.language_code VALUES (11, '#1957b0', 'AspectJ');
INSERT INTO public.language_code VALUES (12, '#89e051', 'Shell');
INSERT INTO public.language_code VALUES (13, '#3994bc', 'Web Ontology Language');
INSERT INTO public.language_code VALUES (14, '#3a4040', 'xBase');
INSERT INTO public.language_code VALUES (15, '#946d57', 'Eiffel');
INSERT INTO public.language_code VALUES (16, '#7070ff', 'Nix');
INSERT INTO public.language_code VALUES (17, '#46390b', 'SuperCollider');
INSERT INTO public.language_code VALUES (18, '#0095d9', 'MTML');
INSERT INTO public.language_code VALUES (19, '#ae17ff', 'Racket');
INSERT INTO public.language_code VALUES (20, '#6e4a7e', 'Elixir');
INSERT INTO public.language_code VALUES (21, '#1E90FF', 'SAS');
INSERT INTO public.language_code VALUES (22, '#467C91', 'Agda');
INSERT INTO public.language_code VALUES (23, '#fcd46d', 'D');
INSERT INTO public.language_code VALUES (24, '#f7ede0', 'Opal');
INSERT INTO public.language_code VALUES (25, '#dc566d', 'Standard ML');
INSERT INTO public.language_code VALUES (26, '#438eff', 'Objective-C');
INSERT INTO public.language_code VALUES (27, '#ed2cd6', 'ColdFusion CFC');
INSERT INTO public.language_code VALUES (28, '#fcaf3e', 'Oz');
INSERT INTO public.language_code VALUES (29, '#c7a938', 'Mirah');
INSERT INTO public.language_code VALUES (30, '#ff0c5a', 'Objective-J');
INSERT INTO public.language_code VALUES (31, '#82937f', 'Gosu');
INSERT INTO public.language_code VALUES (32, '#701516', 'Ruby');
INSERT INTO public.language_code VALUES (33, '#b0ce4e', 'Component Pascal');
INSERT INTO public.language_code VALUES (34, '#ca2afe', 'Arc');
INSERT INTO public.language_code VALUES (35, '#343761', 'SystemVerilog');
INSERT INTO public.language_code VALUES (36, '#8a0707', 'APL');
INSERT INTO public.language_code VALUES (37, '#375eab', 'Go');
INSERT INTO public.language_code VALUES (38, '#945db7', 'Visual Basic');
INSERT INTO public.language_code VALUES (39, '#4F5D95', 'PHP');
INSERT INTO public.language_code VALUES (40, '#aaaaff', 'Cirru');
INSERT INTO public.language_code VALUES (41, '#FFCB1F', 'SQF');
INSERT INTO public.language_code VALUES (42, '#e4cc98', 'Glyph');
INSERT INTO public.language_code VALUES (43, '#b07219', 'Java');
INSERT INTO public.language_code VALUES (44, '#7dd3b0', 'Scala');
INSERT INTO public.language_code VALUES (45, '#ed2cd6', 'ColdFusion');
INSERT INTO public.language_code VALUES (46, '#0298c3', 'Perl');
INSERT INTO public.language_code VALUES (47, '#60B5CC', 'Elm');
INSERT INTO public.language_code VALUES (48, '#fa1fa1', 'Lua');
INSERT INTO public.language_code VALUES (49, '#848bf3', 'Verilog');
INSERT INTO public.language_code VALUES (50, '#636746', 'Factor');
INSERT INTO public.language_code VALUES (51, '#f7941e', 'Haxe');
INSERT INTO public.language_code VALUES (52, '#91de79', 'Pure Data');
INSERT INTO public.language_code VALUES (53, '#341708', 'Forth');
INSERT INTO public.language_code VALUES (54, '#ee0000', 'Red');
INSERT INTO public.language_code VALUES (55, '#7891b1', 'Hy');
INSERT INTO public.language_code VALUES (56, '#0098db', 'Volt');
INSERT INTO public.language_code VALUES (57, '#3d9970', 'LSL');
INSERT INTO public.language_code VALUES (58, '#244776', 'CoffeeScript');
INSERT INTO public.language_code VALUES (59, '#e44b23', 'HTML');
INSERT INTO public.language_code VALUES (60, '#a54c4d', 'UnrealScript');
INSERT INTO public.language_code VALUES (61, '#ffac45', 'Swift');
INSERT INTO public.language_code VALUES (62, '#555', 'C');
INSERT INTO public.language_code VALUES (63, '#6594b9', 'AutoHotkey');
INSERT INTO public.language_code VALUES (64, '#fdcd00', 'Isabelle');
INSERT INTO public.language_code VALUES (65, '#d4bec1', 'Boo');
INSERT INTO public.language_code VALUES (66, '#36699B', 'AutoIt');
INSERT INTO public.language_code VALUES (67, '#db5855', 'Clojure');
INSERT INTO public.language_code VALUES (68, '#dea584', 'Rust');
INSERT INTO public.language_code VALUES (69, '#74283c', 'Prolog');
INSERT INTO public.language_code VALUES (70, '#f69e1d', 'SourcePawn');
INSERT INTO public.language_code VALUES (71, '#9DC3FF', 'ANTLR');
INSERT INTO public.language_code VALUES (72, '#0e60e3', 'Harbour');
INSERT INTO public.language_code VALUES (73, '#e4cc98', 'Tcl');
INSERT INTO public.language_code VALUES (74, '#cd6400', 'BlitzMax');
INSERT INTO public.language_code VALUES (75, '#fcd7de', 'PigLatin');
INSERT INTO public.language_code VALUES (76, '#2584c3', 'Lasso');
INSERT INTO public.language_code VALUES (77, '#8a1267', 'ECL');
INSERT INTO public.language_code VALUES (78, '#543978', 'VHDL');
INSERT INTO public.language_code VALUES (79, '#bd79d1', 'Arduino');
INSERT INTO public.language_code VALUES (80, '#2b446d', 'Propeller Spin');
INSERT INTO public.language_code VALUES (81, '#e3592c', 'IDL');
INSERT INTO public.language_code VALUES (82, '#1ac620', 'ATS');
INSERT INTO public.language_code VALUES (83, '#02f88c', 'Ada');
INSERT INTO public.language_code VALUES (84, '#c9df40', 'Nu');
INSERT INTO public.language_code VALUES (85, '#004200', 'LFE');
INSERT INTO public.language_code VALUES (86, '#77d9fb', 'RAML');
INSERT INTO public.language_code VALUES (87, '#5a63a3', 'Oxygene');
INSERT INTO public.language_code VALUES (88, '#6a40fd', 'ASP');
INSERT INTO public.language_code VALUES (89, '#6E4C13', 'Assembly');
INSERT INTO public.language_code VALUES (90, '#f0a9f0', 'Gnuplot');
INSERT INTO public.language_code VALUES (91, '#45f715', 'Turing');
INSERT INTO public.language_code VALUES (92, '#ee7d06', 'Vala');
INSERT INTO public.language_code VALUES (93, '#2779ab', 'Processing');
INSERT INTO public.language_code VALUES (94, '#33CCFF', 'FLUX');
INSERT INTO public.language_code VALUES (95, '#ff2b2b', 'NetLogo');
INSERT INTO public.language_code VALUES (96, '#178600', 'C Sharp');
INSERT INTO public.language_code VALUES (97, '#563d7c', 'CSS');
INSERT INTO public.language_code VALUES (98, '#499886', 'LiveScript');
INSERT INTO public.language_code VALUES (99, '#44a51c', 'QML');
INSERT INTO public.language_code VALUES (100, '#066ab2', 'Pike');
INSERT INTO public.language_code VALUES (101, '#cc9900', 'LOLCODE');
INSERT INTO public.language_code VALUES (102, '#b0b77e', 'ooc');
INSERT INTO public.language_code VALUES (103, '#f97732', 'Mask');
INSERT INTO public.language_code VALUES (104, '#f64e3e', 'EmberScript');
INSERT INTO public.language_code VALUES (105, '#3D6117', 'TeX');
INSERT INTO public.language_code VALUES (106, '#0d3c6e', 'Nemerle');
INSERT INTO public.language_code VALUES (107, '#f5c800', 'KRL');
INSERT INTO public.language_code VALUES (108, '#755223', 'Unified Parallel C');
INSERT INTO public.language_code VALUES (109, '#f6a51f', 'Golo');
INSERT INTO public.language_code VALUES (110, '#0298c3', 'Perl6');
INSERT INTO public.language_code VALUES (111, '#7b9db4', 'Fancy');
INSERT INTO public.language_code VALUES (112, '#3be133', 'OCaml');
INSERT INTO public.language_code VALUES (113, '#7582D1', 'wisp');
INSERT INTO public.language_code VALUES (114, '#b0ce4e', 'Pascal');
INSERT INTO public.language_code VALUES (115, '#b845fc', 'F#');
INSERT INTO public.language_code VALUES (116, '#cc5555', 'Puppet');
INSERT INTO public.language_code VALUES (117, '#e3491a', 'ActionScript');
INSERT INTO public.language_code VALUES (118, '#ff9c2e', 'Ragel in Ruby Host');
INSERT INTO public.language_code VALUES (119, '#dbded5', 'Fantom');
INSERT INTO public.language_code VALUES (120, '#118f9e', 'Zephir');
INSERT INTO public.language_code VALUES (121, '#596706', 'Smalltalk');
INSERT INTO public.language_code VALUES (122, '#075ff1', 'DM');
INSERT INTO public.language_code VALUES (123, '#078193', 'Ioke');
INSERT INTO public.language_code VALUES (124, '#d80074', 'PogoScript');
INSERT INTO public.language_code VALUES (125, '#c065db', 'Emacs Lisp');
INSERT INTO public.language_code VALUES (126, '#f1e05a', 'JavaScript');
INSERT INTO public.language_code VALUES (127, '#199c4b', 'VimL');
INSERT INTO public.language_code VALUES (128, '#bb92ac', 'Matlab');
INSERT INTO public.language_code VALUES (129, '#007eff', 'Slash');
INSERT INTO public.language_code VALUES (130, '#198ce7', 'R');
INSERT INTO public.language_code VALUES (131, '#0faf8d', 'Erlang');
INSERT INTO public.language_code VALUES (132, '#cc0000', 'Pan');
INSERT INTO public.language_code VALUES (133, '#652B81', 'LookML');
INSERT INTO public.language_code VALUES (134, '#3994bc', 'Eagle');
INSERT INTO public.language_code VALUES (135, '#1e4aec', 'Scheme');
INSERT INTO public.language_code VALUES (136, '#dbb284', 'PAWN');
INSERT INTO public.language_code VALUES (137, '#3581ba', 'Python');
INSERT INTO public.language_code VALUES (138, '#ce279c', 'Max');
INSERT INTO public.language_code VALUES (139, '#3fb68b', 'Common Lisp');
INSERT INTO public.language_code VALUES (140, '#A8FF97', 'Latte');
INSERT INTO public.language_code VALUES (141, '#2700e2', 'XQuery');
INSERT INTO public.language_code VALUES (142, '#cabbff', 'Omgrofl');
INSERT INTO public.language_code VALUES (143, '#37775b', 'Nimrod');
INSERT INTO public.language_code VALUES (144, '#0d8921', 'Nit');
INSERT INTO public.language_code VALUES (145, '#8dc63f', 'Chapel');
INSERT INTO public.language_code VALUES (146, '#e69f56', 'Groovy');
INSERT INTO public.language_code VALUES (147, '#3ebc27', 'Dylan');
INSERT INTO public.language_code VALUES (148, '#ccce35', 'E');
INSERT INTO public.language_code VALUES (149, '#f3ca0a', 'Parrot');
INSERT INTO public.language_code VALUES (150, '#ff0000', 'Grammatical Framework');
INSERT INTO public.language_code VALUES (151, '#8ad353', 'Game Maker Language');
INSERT INTO public.language_code VALUES (152, '#0298c3', 'VCL');
INSERT INTO public.language_code VALUES (153, '#6600cc', 'Papyrus');
INSERT INTO public.language_code VALUES (154, '#4d41b1', 'FORTRAN');
INSERT INTO public.language_code VALUES (155, '#3a81ad', 'Clean');
INSERT INTO public.language_code VALUES (156, '#cc5c24', 'Alloy');
INSERT INTO public.language_code VALUES (157, '#B9D9FF', 'AGS Script');
INSERT INTO public.language_code VALUES (158, '#ff8877', 'Slim');
INSERT INTO public.language_code VALUES (159, '#bcdc53', 'PureScript');
INSERT INTO public.language_code VALUES (160, '#a270ba', 'Julia');
INSERT INTO public.language_code VALUES (161, '#29b544', 'Haskell');
INSERT INTO public.language_code VALUES (162, '#a9188d', 'Io');
INSERT INTO public.language_code VALUES (163, '#cc0088', 'Rouge');
INSERT INTO public.language_code VALUES (164, '#f34b7d', 'cpp');
INSERT INTO public.language_code VALUES (165, '#120F14', 'Shen');
INSERT INTO public.language_code VALUES (166, '#cca760', 'Dogescript');
INSERT INTO public.language_code VALUES (167, '#ffce3b', 'nesC');
INSERT INTO public.language_code VALUES (168, '#ededed', 'Other');


--
-- TOC entry 3848 (class 0 OID 35536)
-- Dependencies: 243
-- Data for Name: login_history; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.login_history VALUES ('2024-11-11', 1, 1);
INSERT INTO public.login_history VALUES ('2024-11-11', 2, 2);
INSERT INTO public.login_history VALUES ('2024-11-11', 3, 3);
INSERT INTO public.login_history VALUES ('2024-11-11', 4, 4);
INSERT INTO public.login_history VALUES ('2024-11-11', 5, 5);
INSERT INTO public.login_history VALUES ('2024-11-11', 6, 6);
INSERT INTO public.login_history VALUES ('2024-11-11', 7, 7);
INSERT INTO public.login_history VALUES ('2024-11-12', 8, 3);
INSERT INTO public.login_history VALUES ('2024-11-12', 9, 4);
INSERT INTO public.login_history VALUES ('2024-11-12', 10, 6);
INSERT INTO public.login_history VALUES ('2024-11-12', 11, 1);
INSERT INTO public.login_history VALUES ('2024-11-12', 12, 2);
INSERT INTO public.login_history VALUES ('2024-11-13', 13, 3);
INSERT INTO public.login_history VALUES ('2024-11-13', 14, 2);
INSERT INTO public.login_history VALUES ('2024-11-13', 15, 4);
INSERT INTO public.login_history VALUES ('2024-11-13', 16, 6);
INSERT INTO public.login_history VALUES ('2024-11-13', 17, 1);
INSERT INTO public.login_history VALUES ('2024-11-14', 18, 6);
INSERT INTO public.login_history VALUES ('2024-11-14', 19, 1);
INSERT INTO public.login_history VALUES ('2024-11-14', 20, 4);
INSERT INTO public.login_history VALUES ('2024-11-14', 21, 3);
INSERT INTO public.login_history VALUES ('2024-11-14', 22, 2);
INSERT INTO public.login_history VALUES ('2024-11-14', 23, 7);
INSERT INTO public.login_history VALUES ('2024-11-14', 24, 8);
INSERT INTO public.login_history VALUES ('2024-11-14', 25, 9);
INSERT INTO public.login_history VALUES ('2024-11-14', 26, 10);
INSERT INTO public.login_history VALUES ('2024-11-15', 27, 9);
INSERT INTO public.login_history VALUES ('2024-11-15', 28, 11);
INSERT INTO public.login_history VALUES ('2024-11-15', 29, 3);
INSERT INTO public.login_history VALUES ('2024-11-15', 30, 4);
INSERT INTO public.login_history VALUES ('2024-11-15', 31, 1);
INSERT INTO public.login_history VALUES ('2024-11-15', 32, 6);
INSERT INTO public.login_history VALUES ('2024-11-15', 33, 2);
INSERT INTO public.login_history VALUES ('2024-11-16', 34, 4);
INSERT INTO public.login_history VALUES ('2024-11-16', 35, 3);
INSERT INTO public.login_history VALUES ('2024-11-16', 36, 2);
INSERT INTO public.login_history VALUES ('2024-11-16', 37, 1);
INSERT INTO public.login_history VALUES ('2024-11-17', 38, 12);
INSERT INTO public.login_history VALUES ('2024-11-17', 39, 13);
INSERT INTO public.login_history VALUES ('2024-11-17', 40, 4);
INSERT INTO public.login_history VALUES ('2024-11-17', 41, 14);
INSERT INTO public.login_history VALUES ('2024-11-17', 42, 3);
INSERT INTO public.login_history VALUES ('2024-11-17', 43, 6);
INSERT INTO public.login_history VALUES ('2024-11-18', 44, 2);
INSERT INTO public.login_history VALUES ('2024-11-18', 45, 3);
INSERT INTO public.login_history VALUES ('2024-11-18', 46, 6);
INSERT INTO public.login_history VALUES ('2024-11-18', 47, 1);
INSERT INTO public.login_history VALUES ('2024-11-18', 48, 9);
INSERT INTO public.login_history VALUES ('2024-11-18', 49, 14);
INSERT INTO public.login_history VALUES ('2024-11-18', 50, 4);
INSERT INTO public.login_history VALUES ('2024-11-18', 51, 15);


--
-- TOC entry 3850 (class 0 OID 35540)
-- Dependencies: 245
-- Data for Name: mr_info; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 7, '2024-11-11 17:17:22.917468', '2024-11-11 08:17:21', 199, 2, '2024-11-11 17:17:24.680196', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 7, '2024-11-11 17:58:02.880427', '2024-11-11 08:58:01', 200, 3, '2024-11-11 17:58:04.71978', 1);
INSERT INTO public.mr_info VALUES (8, 8, 7, 9, 8, 7, '2024-11-12 10:26:59.65881', '2024-11-12 01:26:57', 201, 4, '2024-11-12 10:27:02.561802', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 8, 9, '2024-11-12 10:42:11.656689', '2024-11-12 01:42:10', 202, 5, '2024-11-12 10:42:13.925451', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 9, '2024-11-12 11:00:56.470521', '2024-11-12 02:00:55', 203, 6, '2024-11-12 11:00:58.296186', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 9, 8, 9, '2024-11-12 13:05:06.128532', '2024-11-12 04:05:04', 204, 7, '2024-11-12 13:05:08.038548', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 9, 8, 7, '2024-11-12 13:12:36.688131', '2024-11-12 04:12:35', 205, 8, '2024-11-12 13:12:38.017041', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 6, '2024-11-12 13:17:42.465963', '2024-11-12 04:17:41', 206, 9, '2024-11-12 13:17:43.594588', 1);
INSERT INTO public.mr_info VALUES (9, 9, 8, 8, 8, 7, '2024-11-12 14:27:37.700904', '2024-11-12 05:27:36', 207, 10, '2024-11-12 14:27:39.407322', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 6, '2024-11-12 15:36:27.126487', '2024-11-12 06:36:25', 208, 11, '2024-11-12 15:36:28.594643', 1);
INSERT INTO public.mr_info VALUES (9, 8, 8, 8, 7, 7, '2024-11-12 16:06:10.798694', '2024-11-12 07:06:09', 209, 12, '2024-11-12 16:06:12.318064', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 8, 7, 7, '2024-11-12 16:16:23.776034', '2024-11-12 07:16:21', 210, 13, '2024-11-12 16:16:25.557664', 1);
INSERT INTO public.mr_info VALUES (6, 7, 7, 8, 5, 6, '2024-11-12 17:06:16.483779', '2024-11-12 08:06:15', 211, 14, '2024-11-12 17:06:18.54072', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 8, 6, 7, '2024-11-12 17:21:36.67812', '2024-11-12 08:21:35', 212, 15, '2024-11-12 17:21:38.24159', 1);
INSERT INTO public.mr_info VALUES (6, 7, 7, 7, 8, 6, '2024-11-12 17:38:17.036435', '2024-11-12 08:38:15', 213, 16, '2024-11-12 17:38:18.581296', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 6, 6, '2024-11-12 18:01:34.897357', '2024-11-12 09:01:33', 214, 17, '2024-11-12 18:01:36.405813', 1);
INSERT INTO public.mr_info VALUES (8, 8, 7, 8, 7, 7, '2024-11-13 09:50:09.339876', '2024-11-13 00:50:07', 215, 18, '2024-11-13 09:50:10.886387', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 6, '2024-11-13 10:20:00.418662', '2024-11-13 01:19:58', 216, 19, '2024-11-13 10:20:02.760491', 1);
INSERT INTO public.mr_info VALUES (6, 5, 5, 4, 5, 5, '2024-11-13 10:27:27.176938', '2024-11-13 01:27:25', 217, 20, '2024-11-13 10:27:28.509748', 1);
INSERT INTO public.mr_info VALUES (5, 5, 3, 2, 4, 4, '2024-11-13 10:37:48.051836', '2024-11-13 01:37:47', 218, 21, '2024-11-13 10:37:49.527105', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 8, 6, 6, '2024-11-13 13:00:21.509115', '2024-11-13 04:00:19', 219, 22, '2024-11-13 13:00:23.047031', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 9, 6, '2024-11-13 13:37:55.66137', '2024-11-13 04:37:54', 220, 23, '2024-11-13 13:37:57.295022', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 8, 6, '2024-11-13 13:47:29.168378', '2024-11-13 04:47:27', 221, 24, '2024-11-13 13:47:30.529558', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 7, 8, 8, '2024-11-13 14:21:56.777313', '2024-11-13 05:21:55', 222, 25, '2024-11-13 14:21:58.640882', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 7, '2024-11-13 16:56:45.307695', '2024-11-13 07:56:43', 223, 26, '2024-11-13 16:56:47.288516', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 5, '2024-11-13 17:28:23.810779', '2024-11-13 08:28:22', 224, 27, '2024-11-13 17:28:25.93229', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 9, 6, 8, '2024-11-13 17:36:07.547832', '2024-11-13 08:36:06', 225, 28, '2024-11-13 17:36:08.762598', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 8, 7, '2024-11-14 09:47:16.793059', '2024-11-14 00:47:15', 226, 29, '2024-11-14 09:47:19.168129', 1);
INSERT INTO public.mr_info VALUES (NULL, NULL, NULL, NULL, NULL, NULL, '2024-11-14 12:40:40.936063', '2024-11-14 03:40:39', 227, 30, '2024-11-14 12:40:40.936063', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 8, 7, 6, '2024-11-14 13:19:12.573069', '2024-11-14 04:19:11', 228, 31, '2024-11-14 13:19:13.949627', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 8, 7, 6, '2024-11-14 13:29:23.034695', '2024-11-14 04:29:21', 229, 32, '2024-11-14 13:29:24.560282', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 7, 8, 6, '2024-11-14 14:04:09.845318', '2024-11-14 05:04:08', 230, 33, '2024-11-14 14:04:12.231714', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 5, 6, 6, '2024-11-14 14:20:32.386308', '2024-11-14 05:20:31', 231, 34, '2024-11-14 14:20:33.651699', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 6, 7, '2024-11-14 14:26:16.726989', '2024-11-14 05:26:15', 232, 35, '2024-11-14 14:26:18.026792', 1);
INSERT INTO public.mr_info VALUES (6, 4, 5, 3, 4, 5, '2024-11-14 14:50:43.525452', '2024-11-14 05:50:42', 233, 36, '2024-11-14 14:50:44.796406', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 7, 7, '2024-11-14 15:26:18.97078', '2024-11-14 06:26:13', 234, 37, '2024-11-14 15:26:21.007628', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 7, 7, '2024-11-14 15:33:06.447538', '2024-11-14 06:33:04', 235, 38, '2024-11-14 15:33:08.182983', 1);
INSERT INTO public.mr_info VALUES (7, 6, 6, 5, 5, 6, '2024-11-14 15:40:36.026231', '2024-11-14 06:40:34', 236, 39, '2024-11-14 15:40:37.166038', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 8, 6, '2024-11-14 17:04:42.427698', '2024-11-14 08:04:41', 237, 40, '2024-11-14 17:04:44.559798', 1);
INSERT INTO public.mr_info VALUES (7, 7, 7, 7, 7, 7, '2024-11-18 14:28:57.758068', '2024-11-18 05:28:56', 256, 67, '2024-11-18 14:28:57.758068', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 6, '2024-11-15 12:46:54.543409', '2024-11-15 03:46:52', 238, 44, '2024-11-15 12:46:56.685801', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 6, '2024-11-15 13:29:08.451425', '2024-11-15 04:29:07', 239, 45, '2024-11-15 13:29:10.287654', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 8, 7, '2024-11-15 13:31:07.850225', '2024-11-15 04:31:06', 240, 46, '2024-11-15 13:31:09.164331', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 7, '2024-11-15 14:53:01.331411', '2024-11-15 05:53:00', 241, 47, '2024-11-15 14:53:02.875391', 1);
INSERT INTO public.mr_info VALUES (8, 8, 8, 6, 7, 6, '2024-11-15 19:15:42.867383', '2024-11-15 10:15:41', 242, 48, '2024-11-15 19:15:45.942857', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 7, 6, '2024-11-15 19:26:59.267966', '2024-11-15 10:26:57', 243, 49, '2024-11-15 19:27:00.607549', 1);
INSERT INTO public.mr_info VALUES (7, 8, 8, 7, 8, 6, '2024-11-16 14:23:01.465499', '2024-11-16 05:23:00', 244, 50, '2024-11-16 14:23:03.866833', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 7, 7, '2024-11-16 14:35:26.598897', '2024-11-16 05:35:25', 245, 52, '2024-11-16 14:35:27.823658', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 6, 7, '2024-11-17 18:10:38.040261', '2024-11-17 09:10:36', 246, 54, '2024-11-17 18:10:39.615961', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 6, '2024-11-18 10:10:40.331317', '2024-11-18 01:10:39', 247, 55, '2024-11-18 10:10:41.648677', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 7, '2024-11-18 10:18:13.380745', '2024-11-18 01:18:12', 248, 56, '2024-11-18 10:18:14.661437', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 6, 7, 5, '2024-11-18 10:30:24.752109', '2024-11-18 01:30:21', 249, 57, '2024-11-18 10:30:26.267112', 1);
INSERT INTO public.mr_info VALUES (7, 6, 6, 5, 6, 6, '2024-11-18 11:11:38.280749', '2024-11-18 02:11:34', 250, 58, '2024-11-18 11:11:39.608283', 1);
INSERT INTO public.mr_info VALUES (7, 7, 7, 6, 8, 6, '2024-11-18 11:12:58.647369', '2024-11-18 02:12:57', 251, 59, '2024-11-18 11:12:59.898245', 1);
INSERT INTO public.mr_info VALUES (8, 7, 7, 6, 7, 7, '2024-11-18 11:21:45.821813', '2024-11-18 02:21:44', 252, 60, '2024-11-18 11:21:47.201903', 1);
INSERT INTO public.mr_info VALUES (7, 7, 8, 7, 6, 6, '2024-11-18 11:32:43.857166', '2024-11-18 02:32:42', 253, 61, '2024-11-18 11:32:45.284059', 1);
INSERT INTO public.mr_info VALUES (7, 6, 6, 6, 5, 5, '2024-11-18 12:47:04.14954', '2024-11-18 03:47:02', 254, 62, '2024-11-18 12:47:05.757542', 1);
INSERT INTO public.mr_info VALUES (7, 7, 7, 7, 7, 7, '2024-11-18 14:46:45.619111', '2024-11-18 04:31:27', 255, 70, '2024-11-18 14:46:45.619111', 1);
INSERT INTO public.mr_info VALUES (7, 7, 7, 7, 7, 7, '2024-11-18 16:00:27.877178', '2024-11-18 07:00:26', 259, 73, '2024-11-18 16:00:27.877178', 1);
INSERT INTO public.mr_info VALUES (7, 8, 7, 7, 7, 7, '2024-11-18 15:54:03.547944', '2024-11-18 06:45:00', 258, 72, '2024-11-18 15:54:03.547944', 1);
INSERT INTO public.mr_info VALUES (8, 7, 8, 7, 7, 6, '2024-11-18 16:04:40.131068', '2024-11-18 05:39:16', 257, 74, '2024-11-18 16:04:41.435666', 1);


--
-- TOC entry 3873 (class 0 OID 36284)
-- Dependencies: 268
-- Data for Name: notification; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.notification VALUES (true, '2024-11-14 19:16:25.979658', 6, '2024-11-14 19:18:09.432961', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:15:33.158393', 5, '2024-11-14 19:18:10.686194', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:13:16.142574', 3, '2024-11-14 19:18:15.380525', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:14:28.295127', 4, '2024-11-14 19:18:16.964785', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:17:39.818757', 7, '2024-11-14 19:18:20.273457', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:07:23.207701', 1, '2024-11-14 19:18:25.419043', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:33:13.865962', 8, '2024-11-15 16:37:55.553082', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-14 19:12:36.004617', 2, '2024-11-15 17:04:04.11284', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 17:10:17.26574', 10, '2024-11-15 17:10:59.746347', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 17:10:15.959184', 9, '2024-11-15 17:11:06.64907', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 17:19:27.314529', 11, '2024-11-15 17:19:33.479962', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 17:21:58.348495', 12, '2024-11-15 17:22:11.864628', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 19:30:46.365404', 15, '2024-11-15 19:32:48.11777', 7, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 19:45:01.715767', 16, '2024-11-15 19:46:38.827952', 6, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 15:39:58.288736', 17, '2024-11-17 15:40:05.603273', 8, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 17:17:38.042272', 20, '2024-11-17 17:23:56.560655', 12, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 17:23:45.28891', 21, '2024-11-17 17:23:57.044287', 12, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 22:03:07.643872', 22, '2024-11-17 22:04:07.66932', 12, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 22:04:40.946614', 23, '2024-11-18 08:54:22.523588', 12, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 19:13:12.459557', 14, '2024-11-18 09:08:03.763923', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-15 18:48:32.507918', 13, '2024-11-18 09:08:06.890801', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-18 09:07:52.783109', 25, '2024-11-18 09:08:08.582173', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-18 09:00:55.221164', 24, '2024-11-18 09:22:31.517367', 12, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 15:51:15.587292', 19, '2024-11-18 10:00:05.505169', 17, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (false, '2024-11-18 10:10:06.340876', 26, '2024-11-18 10:10:06.340876', 1, 'AI 리뷰가 생성되었습니다.', NULL);
INSERT INTO public.notification VALUES (true, '2024-11-17 15:50:48.214427', 18, '2024-11-18 15:28:05.843745', 17, 'AI 리뷰가 생성되었습니다.', NULL);


--
-- TOC entry 3852 (class 0 OID 35544)
-- Dependencies: 247
-- Data for Name: project; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.project VALUES ('2024-10-15 15:24:18.057418', 825246, 1, '2024-11-11 15:24:18.057418', 'X95PAslFVmRYGXbmj75idD46H9asK5PI+SLl8ryl1ik=', 's11-final/S11P31A210', 'https://lab.ssafy.com/s11-final/S11P31A210.git', 'S11P31A210');
INSERT INTO public.project VALUES ('2024-11-16 12:14:34.257694', 847432, 2, '2024-11-16 12:14:34.257694', '4/k+RApfcsSiRHJM45+ujSdov0MV0tDHYrOdQ2fq9+E=', 'btothey99/ssafy_ai_codereview', 'https://lab.ssafy.com/btothey99/ssafy_ai_codereview.git', 'ssafy_ai_codereview');


--
-- TOC entry 3854 (class 0 OID 35550)
-- Dependencies: 249
-- Data for Name: prompt_history; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.prompt_history VALUES (1, '2024-11-11 15:40:25.676721', 1);
INSERT INTO public.prompt_history VALUES (2, '2024-11-11 15:40:31.695985', 1);
INSERT INTO public.prompt_history VALUES (3, '2024-11-11 15:41:01.062484', 1);
INSERT INTO public.prompt_history VALUES (4, '2024-11-11 17:01:31.837644', 1);
INSERT INTO public.prompt_history VALUES (5, '2024-11-11 17:01:36.061403', 1);
INSERT INTO public.prompt_history VALUES (6, '2024-11-11 17:01:42.68944', 2);
INSERT INTO public.prompt_history VALUES (7, '2024-11-11 17:07:55.139504', 7);
INSERT INTO public.prompt_history VALUES (8, '2024-11-11 17:08:22.544493', 3);
INSERT INTO public.prompt_history VALUES (9, '2024-11-11 17:08:30.417593', 2);
INSERT INTO public.prompt_history VALUES (10, '2024-11-11 17:08:36.995186', 3);
INSERT INTO public.prompt_history VALUES (11, '2024-11-11 17:10:10.65779', 6);
INSERT INTO public.prompt_history VALUES (22, '2024-11-11 17:28:47.499579', 6);
INSERT INTO public.prompt_history VALUES (23, '2024-11-12 09:38:39.554363', 1);
INSERT INTO public.prompt_history VALUES (24, '2024-11-12 09:38:43.927882', 1);
INSERT INTO public.prompt_history VALUES (25, '2024-11-12 14:20:22.75862', 3);
INSERT INTO public.prompt_history VALUES (26, '2024-11-12 17:01:05.79008', 3);
INSERT INTO public.prompt_history VALUES (27, '2024-11-12 18:13:31.237647', 6);
INSERT INTO public.prompt_history VALUES (28, '2024-11-12 18:13:43.784994', 6);
INSERT INTO public.prompt_history VALUES (29, '2024-11-12 19:16:59.819468', 6);
INSERT INTO public.prompt_history VALUES (30, '2024-11-13 12:24:30.622624', 6);
INSERT INTO public.prompt_history VALUES (31, '2024-11-13 12:27:57.112491', 6);
INSERT INTO public.prompt_history VALUES (32, '2024-11-13 12:31:38.112533', 6);
INSERT INTO public.prompt_history VALUES (33, '2024-11-13 13:46:50.57675', 6);
INSERT INTO public.prompt_history VALUES (34, '2024-11-13 15:23:57.67322', 1);
INSERT INTO public.prompt_history VALUES (35, '2024-11-13 15:29:17.819752', 1);
INSERT INTO public.prompt_history VALUES (36, '2024-11-13 15:34:16.566442', 1);
INSERT INTO public.prompt_history VALUES (37, '2024-11-13 15:34:26.918989', 1);
INSERT INTO public.prompt_history VALUES (38, '2024-11-13 15:36:02.118769', 1);
INSERT INTO public.prompt_history VALUES (39, '2024-11-13 17:33:41.582954', 2);
INSERT INTO public.prompt_history VALUES (40, '2024-11-13 17:58:09.948642', 2);
INSERT INTO public.prompt_history VALUES (41, '2024-11-14 17:12:53.040072', 2);
INSERT INTO public.prompt_history VALUES (42, '2024-11-14 17:15:34.340669', 7);
INSERT INTO public.prompt_history VALUES (43, '2024-11-17 15:50:03.434615', 14);
INSERT INTO public.prompt_history VALUES (44, '2024-11-17 16:03:04.677545', 4);


--
-- TOC entry 3856 (class 0 OID 35554)
-- Dependencies: 251
-- Data for Name: retrieval; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.108209', 1, 4, '2024-11-11 17:17:38.108209', 1, '@Transactional
    public void updateCustomPrompt(User user, String content, Long projectId) {
        CustomPrompt customPrompt =
                customPromptRepository
                        .findByProjectId(projectId)
                        .orElseThrow(() -> new BusinessException(CUSTOM_PROMPT_NOT_EXIST));
        customPrompt.updateContent(content);
        promptHistoryRepository.save(new PromptHistory(user.getId(), LocalDateTime.now()));
        badgeEventService.eventUpdateCustomPrompt(user);
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.113413', 2, 4, '2024-11-11 17:17:38.113413', 1, 'public CustomPromptResponse getCustomPrompt(Long projectId) {
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);

        return CustomPromptResponse.builder()
                .customPromptId(customPrompt.getId())
                .content(customPrompt.getContent().replace("\n", "<br>"))
                .build();
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.114784', 3, 4, '2024-11-11 17:17:38.114784', 1, 'private void saveBasicCustomPrompt(Project project) {
        CustomPrompt customPrompt = new CustomPrompt(project);
        customPromptRepository.save(customPrompt);
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.116102', 4, 4, '2024-11-11 17:17:38.116102', 1, '@PutMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 수정")
    public ApiResponse<Void> updateCustomPrompt(
            @AuthUser User user,
            @PathVariable("projectId") Long projectId,
            @ModelAttribute CustomPromptRequest customPromptRequest) {
        customPromptService.updateCustomPrompt(user, customPromptRequest.content(), projectId);
        return ApiSuccessResponse.success();
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.1176', 5, 4, '2024-11-11 17:17:38.1176', 1, '@GetMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 조회")
    public ApiResponse<CustomPromptResponse> getCustomPrompt(
            @PathVariable("projectId") Long projectId) {
        return ApiSuccessResponse.success(customPromptService.getCustomPrompt(projectId));
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.12031', 6, 4, '2024-11-11 17:17:38.12031', 1, '@Transactional
    public Project addProject(
            GitlabAccount gitlabAccount,
            Long gitlabProjectId,
            ProjectLinkRequest projectLinkRequest) {
        Project project = createAndSaveProject(gitlabAccount, gitlabProjectId, projectLinkRequest);
        saveBasicCustomPrompt(project);
        branchService.addBranches(projectLinkRequest, project);
        projectWebhookService.addGitlabProjectWebhooks(gitlabAccount.getDomain(), project);
        return project;
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.121536', 7, 4, '2024-11-11 17:17:38.121536', 1, 'public void eventUpdateCustomPrompt(User user) {
        long promptCount = promptHistoryRepository.countByUserId(user.getId());
        if (promptCount == PROMTPT_UPDATE_TARGET_COUNT) {
            userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.122627', 8, 4, '2024-11-11 17:17:38.122627', 1, 'public static GitlabMrDiffsContent createMock() {
        return new GitlabMrDiffsContent("33", "33", "33");
    }', 'GitlabMrDiffsContentFixture.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.123692', 9, 4, '2024-11-11 17:17:38.123692', 1, '@Bean
    GroupedOpenApi customPromptApi() {
        return GroupedOpenApi.builder()
                .group("custom-prompt")
                .pathsToMatch("/api/custom-prompts/**")
                .build();
    }', 'SwaggerConfig.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:17:38.12505', 10, 4, '2024-11-11 17:17:38.12505', 1, '@Transactional
    public void regenerateReview(User user, Long mrInfoId, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getById(mrInfoId);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.676058', 11, 4, '2024-11-11 17:58:14.676058', 2, '@Transactional
    public void regenerateReview(User user, Long mrInfoId, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getById(mrInfoId);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.68149', 12, 4, '2024-11-11 17:58:14.68149', 2, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(user, request.mrInfoId(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.682763', 13, 4, '2024-11-11 17:58:14.682763', 2, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.201654', 871, 2, '2024-11-13 13:18:51.201654', 104, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.684118', 14, 4, '2024-11-11 17:58:14.684118', 2, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.68554', 15, 4, '2024-11-11 17:58:14.68554', 2, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrResponse, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.687037', 16, 4, '2024-11-11 17:58:14.687037', 2, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.688372', 17, 4, '2024-11-11 17:58:14.688372', 2, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.689729', 18, 4, '2024-11-11 17:58:14.689729', 2, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.691016', 19, 4, '2024-11-11 17:58:14.691016', 2, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam(name = "projectId") Long projectId,
            @RequestParam(name = "state", defaultValue = "opened") String state,
            @RequestParam(name = "size", defaultValue = "10") int size,
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "keyword", defaultValue = "") String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-11 17:58:14.692325', 20, 4, '2024-11-11 17:58:14.692325', 2, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.161272', 21, 4, '2024-11-12 09:28:58.161272', 3, '@Transactional
    public void regenerateReview(User user, Long mrInfoId, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getById(mrInfoId);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.166544', 22, 4, '2024-11-12 09:28:58.166544', 3, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(user, request.mrInfoId(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.168451', 23, 4, '2024-11-12 09:28:58.168451', 3, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.170104', 24, 4, '2024-11-12 09:28:58.170104', 3, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.171783', 25, 4, '2024-11-12 09:28:58.171783', 3, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrResponse, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.174221', 26, 4, '2024-11-12 09:28:58.174221', 3, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.176122', 27, 4, '2024-11-12 09:28:58.176122', 3, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:28:58.177522', 28, 4, '2024-11-12 09:28:58.177522', 3, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.195755', 36, 4, '2024-11-12 09:53:01.195755', 5, '@Transactional
    public void updateCustomPrompt(User user, String content, Long projectId) {
        CustomPrompt customPrompt =
                customPromptRepository
                        .findByProjectId(projectId)
                        .orElseThrow(() -> new BusinessException(CUSTOM_PROMPT_NOT_EXIST));
        customPrompt.updateContent(content);
        promptHistoryRepository.save(new PromptHistory(user.getId(), LocalDateTime.now()));
        badgeEventService.eventUpdateCustomPrompt(user);
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.06373', 29, 4, '2024-11-12 09:49:34.06373', 4, '@Transactional
    public void regenerateReview(User user, Long mrInfoId, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getById(mrInfoId);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.065508', 30, 4, '2024-11-12 09:49:34.065508', 4, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(user, request.mrInfoId(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.066803', 31, 4, '2024-11-12 09:49:34.066803', 4, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.068152', 32, 4, '2024-11-12 09:49:34.068152', 4, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.069252', 33, 4, '2024-11-12 09:49:34.069252', 4, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrResponse gitlabMrResponse =
                GitlabMrResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrResponse, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.070315', 34, 4, '2024-11-12 09:49:34.070315', 4, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:49:34.071388', 35, 4, '2024-11-12 09:49:34.071388', 4, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.363815', 872, 2, '2024-11-13 13:22:02.363815', 105, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.262608', 1008, 4, '2024-11-13 13:58:10.262608', 119, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.197871', 37, 4, '2024-11-12 09:53:01.197871', 5, 'public CustomPromptResponse getCustomPrompt(Long projectId) {
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);

        return CustomPromptResponse.builder()
                .customPromptId(customPrompt.getId())
                .content(customPrompt.getContent().replace("\n", "<br>"))
                .build();
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.199821', 38, 4, '2024-11-12 09:53:01.199821', 5, 'private void saveBasicCustomPrompt(Project project) {
        CustomPrompt customPrompt = new CustomPrompt(project);
        customPromptRepository.save(customPrompt);
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.201499', 39, 4, '2024-11-12 09:53:01.201499', 5, '@PutMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 수정")
    public ApiResponse<Void> updateCustomPrompt(
            @AuthUser User user,
            @PathVariable("projectId") Long projectId,
            @ModelAttribute CustomPromptRequest customPromptRequest) {
        customPromptService.updateCustomPrompt(user, customPromptRequest.content(), projectId);
        return ApiSuccessResponse.success();
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.202965', 40, 4, '2024-11-12 09:53:01.202965', 5, '@GetMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 조회")
    public ApiResponse<CustomPromptResponse> getCustomPrompt(
            @PathVariable("projectId") Long projectId) {
        return ApiSuccessResponse.success(customPromptService.getCustomPrompt(projectId));
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.204479', 41, 4, '2024-11-12 09:53:01.204479', 5, '@Transactional
    public Project addProject(
            GitlabAccount gitlabAccount,
            Long gitlabProjectId,
            ProjectLinkRequest projectLinkRequest) {
        Project project = createAndSaveProject(gitlabAccount, gitlabProjectId, projectLinkRequest);
        saveBasicCustomPrompt(project);
        branchService.addBranches(projectLinkRequest, project);
        projectWebhookService.addGitlabProjectWebhooks(gitlabAccount.getDomain(), project);
        return project;
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 09:53:01.205805', 42, 4, '2024-11-12 09:53:01.205805', 5, 'public void eventUpdateCustomPrompt(User user) {
        long promptCount = promptHistoryRepository.countByUserId(user.getId());
        if (promptCount == PROMTPT_UPDATE_TARGET_COUNT) {
            userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.069813', 43, 4, '2024-11-12 10:27:13.069813', 6, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrResponse gitlabMrResponse =
                gitLabClient.getSingleMergeRequest(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mergeRequestIid);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrResponse, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.075046', 44, 4, '2024-11-12 10:27:13.075046', 6, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.076562', 45, 4, '2024-11-12 10:27:13.076562', 6, '@Transactional
    public void regenerateReview(User user, Long mrInfoId, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getById(mrInfoId);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrResponse gitlabMrResponse =
                gitLabClient.getSingleMergeRequest(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.078281', 46, 4, '2024-11-12 10:27:13.078281', 6, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.079813', 47, 4, '2024-11-12 10:27:13.079813', 6, '@ServiceActivator(inputChannel = "reviewRequestChannel")
    public void createReview(String reviewRequestMessage) {
        ReviewRequestMessage reviewRequest =
                jsonUtil.fromJson(reviewRequestMessage, new TypeReference<>() {});
        Long projectId = reviewRequest.projectId();
        Long branchId = reviewRequest.branchId();
        log.info(
                "리뷰 생성 시작 - GitLab URL: {}, MR Info ID: {}, Project ID: {}, Branch ID: {}",
                reviewRequest.gitlabUrl(),
                reviewRequest.mrInfoId(),
                projectId,
                branchId);
        // 1. mr 임베딩
        EmbeddingResponse embeddingResponse =
                openaiClient.generateEmbedding(reviewRequest.mrContent().mrDiffs());
        float[] embedding = embeddingResponse.data().getFirst().embedding();
        // 2. 참고자료 검색
        List<ChunkedCode> chunkedCodes =
                chunkedCodeRepository.retrieveRelevantData(projectId, branchId, 10, embedding);
        List<RetrievalMessage> retrievals =
                chunkedCodes.stream().map(RetrievalMessage::from).toList();
        // 3. 프롬프트 생성
        String prompt =
                buildPrompt(reviewRequest.mrContent(), reviewRequest.customPrompt(), retrievals);
        // 4. 리뷰 생성
        ChatCompletionResponse chatCompletionResponse = openaiClient.chat(prompt);
        String chatMessage = chatCompletionResponse.choices().getFirst().message().content();
        // 5. 리뷰 생성 완료
        ReviewResponseMessage reviewResponse =
                new ReviewResponseMessage(
                        reviewRequest.gitlabUrl(),
                        reviewRequest.mrInfoId(),
                        chatMessage,
                        retrievals);
        log.info(
                "리뷰 생성 완료 - GitLab URL: {}, MR Info ID: {}, 참고자료 수: {}",
                reviewResponse.gitlabUrl(),
                reviewResponse.mrInfoId(),
                reviewResponse.retrievals().size());
        redisGateway.sendReview(reviewResponse);
    }', 'ReviewCreateService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.082209', 48, 4, '2024-11-12 10:27:13.082209', 6, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam(name = "projectId") Long projectId,
            @RequestParam(name = "state") String state,
            @RequestBody GitlabSearchRequest gitlabSearchRequest) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(), projectId, state, gitlabSearchRequest);
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.083889', 49, 4, '2024-11-12 10:27:13.083889', 6, '@Test
    public void shouldCreateReviewSuccessfully() {
        // given
        String gitlabUrl = "https://gitlab.com";
        String token = "token";
        Long gitlabProjectId = 1L;
        Long iid = 100L;
        String mrDescription = "This is an MR description";
        Long projectId = 1L;

        // GitlabMrDiffsContent mock data
        GitlabMrDiffsContent mrDiffs =
                new GitlabMrDiffsContent("old/path", "new/path", "diff content");

        // ChatCompletionContent mock data
        String chatResult = "This is a review suggestion";
        ChatMessage chatCompletionMessage = new ChatMessage("assistant", chatResult);
        ChatCompletionContent.Choice chatCompletionChoice =
                ChatCompletionContent.Choice.builder().message(chatCompletionMessage).build();
        List<ChatCompletionContent.Choice> chatCompletionChoices = List.of(chatCompletionChoice);
        ChatCompletionContent chatCompletionContent =
                ChatCompletionContent.builder().choices(chatCompletionChoices).build();

        given(gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid))
                .willReturn(List.of(mrDiffs));
        given(openAIApiService.chat(anyString())).willReturn(chatCompletionContent);

        // when
        reviewCreateService.makeCodeReviewWhenCalledByWebhook(
                gitlabUrl, token, gitlabProjectId, iid, mrDescription, projectId);

        // then
        then(gitLabClient).should().getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        then(openAIApiService).should().chat(anyString());
        then(reviewService).should().saveReview(projectId, iid, chatResult);
        then(gitLabClient).should().addNoteToMr(gitlabUrl, token, gitlabProjectId, iid, chatResult);
    }', 'ReviewCreateServiceTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.085326', 50, 4, '2024-11-12 10:27:13.085326', 6, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam(name = "projectId") Long projectId) {
        List<GitlabMrResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.086686', 51, 4, '2024-11-12 10:27:13.086686', 6, 'public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            Long projectId) {
        // 1. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 2. 프롬프트 빌드
        String prompt = buildPrompt(mrDescription, mrDiffs);
        // 2. openAI API 호출
        ChatCompletionContent chatCompletionContent = openAIApiService.chat(prompt);
        String chatMessage = chatCompletionContent.choices().getFirst().message().content();
        // 3. 리뷰 저장
        reviewService.saveReview(projectId, iid, chatMessage);
        // 4. 응답 반환(gitlab service)
        gitLabClient.addNoteToMr(gitlabUrl, token, gitlabProjectId, iid, chatMessage);
    }', 'ReviewCreateService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 10:27:13.088032', 52, 4, '2024-11-12 10:27:13.088032', 6, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            String mergeRequestState,
            GitlabSearchRequest gitlabSearchRequest,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl,
                        gitlabProjectId,
                        mergeRequestState,
                        gitlabSearchRequest,
                        this.convertToGitlabDateFormat(createdAt));
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.787664', 53, 4, '2024-11-12 11:04:24.787664', 9, '@Transactional
    public void updateCustomPrompt(User user, String content, Long projectId) {
        CustomPrompt customPrompt =
                customPromptRepository
                        .findByProjectId(projectId)
                        .orElseThrow(() -> new BusinessException(CUSTOM_PROMPT_NOT_EXIST));
        customPrompt.updateContent(content);
        promptHistoryRepository.save(new PromptHistory(user.getId(), LocalDateTime.now()));
        badgeEventService.eventUpdateCustomPrompt(user);
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.792835', 54, 4, '2024-11-12 11:04:24.792835', 9, 'public CustomPromptResponse getCustomPrompt(Long projectId) {
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);

        return CustomPromptResponse.builder()
                .customPromptId(customPrompt.getId())
                .content(customPrompt.getContent().replace("\n", "<br>"))
                .build();
    }', 'CustomPromptService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.794334', 55, 4, '2024-11-12 11:04:24.794334', 9, 'private void saveBasicCustomPrompt(Project project) {
        CustomPrompt customPrompt = new CustomPrompt(project);
        customPromptRepository.save(customPrompt);
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.79596', 56, 4, '2024-11-12 11:04:24.79596', 9, '@PutMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 수정")
    public ApiResponse<Void> updateCustomPrompt(
            @AuthUser User user,
            @PathVariable("projectId") Long projectId,
            @ModelAttribute CustomPromptRequest customPromptRequest) {
        customPromptService.updateCustomPrompt(user, customPromptRequest.content(), projectId);
        return ApiSuccessResponse.success();
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.797826', 57, 4, '2024-11-12 11:04:24.797826', 9, '@GetMapping("/{projectId}")
    @Operation(summary = "연동된 프로젝트의 Custom Prompt 조회")
    public ApiResponse<CustomPromptResponse> getCustomPrompt(
            @PathVariable("projectId") Long projectId) {
        return ApiSuccessResponse.success(customPromptService.getCustomPrompt(projectId));
    }', 'CustomPromptController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.365367', 873, 4, '2024-11-13 13:22:02.365367', 105, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.799974', 58, 4, '2024-11-12 11:04:24.799974', 9, '@Transactional
    public Project addProject(
            GitlabAccount gitlabAccount,
            Long gitlabProjectId,
            ProjectLinkRequest projectLinkRequest) {
        Project project = createAndSaveProject(gitlabAccount, gitlabProjectId, projectLinkRequest);
        saveBasicCustomPrompt(project);
        branchService.addBranches(projectLinkRequest, project);
        projectWebhookService.addGitlabProjectWebhooks(gitlabAccount.getDomain(), project);
        return project;
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:04:24.80158', 59, 4, '2024-11-12 11:04:24.80158', 9, 'public void eventUpdateCustomPrompt(User user) {
        long promptCount = promptHistoryRepository.countByUserId(user.getId());
        if (promptCount == PROMTPT_UPDATE_TARGET_COUNT) {
            userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 11:19:02.750017', 60, 2, '2024-11-12 11:19:02.750017', 10, '// JavaScript
console.log("Hello, World!");
', 'ㅁㅁㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.214589', 61, 4, '2024-11-12 15:36:39.214589', 15, 'public GitlabMrQueryContent getSingleMergeRequest(
            String gitlabUrl, String token, String fullPath, Long mergeRequestIid) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(
                                            graphqlUtil.buildMergeRequestQuery(
                                                    fullPath, mergeRequestIid))
                                    .executeSync();
                    return response.field("project.mergeRequest")
                            .toEntity(GitlabMrQueryContent.class);
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.220474', 62, 4, '2024-11-12 15:36:39.220474', 15, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.221965', 63, 4, '2024-11-12 15:36:39.221965', 15, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.223272', 64, 4, '2024-11-12 15:36:39.223272', 15, 'public String buildMergeRequestQuery(String fullPath, Long gitMergeRequestIid) {
        return String.format(
                "query { "
                        + "  project(fullPath: \"%s\") { "
                        + "    mergeRequest(iid: \"%d\") { "
                        + "      id "
                        + "      iid "
                        + "      title "
                        + "      description "
                        + "      state "
                        + "      mergedAt "
                        + "      createdAt "
                        + "      updatedAt "
                        + "      sourceBranch "
                        + "      targetBranch "
                        + "      labels { "
                        + "        nodes { "
                        + "          title "
                        + "          color "
                        + "        } "
                        + "      } "
                        + "      assignees(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "      reviewers(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "    } "
                        + "  } "
                        + "}",
                fullPath, gitMergeRequestIid);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.224906', 65, 4, '2024-11-12 15:36:39.224906', 15, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.226186', 66, 4, '2024-11-12 15:36:39.226186', 15, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.682815', 74, 4, '2024-11-12 16:06:27.682815', 16, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.366669', 874, 4, '2024-11-13 13:22:02.366669', 105, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.219975', 1026, 4, '2024-11-13 14:12:20.219975', 121, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.227394', 67, 4, '2024-11-12 15:36:39.227394', 15, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.228664', 68, 4, '2024-11-12 15:36:39.228664', 15, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.229955', 69, 4, '2024-11-12 15:36:39.229955', 15, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 15:36:39.231043', 70, 4, '2024-11-12 15:36:39.231043', 15, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.673514', 71, 4, '2024-11-12 16:06:27.673514', 16, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.679546', 72, 4, '2024-11-12 16:06:27.679546', 16, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.681174', 73, 4, '2024-11-12 16:06:27.681174', 16, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.41035', 155, 2, '2024-11-12 17:40:33.41035', 33, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.748993', 156, 4, '2024-11-12 18:01:51.748993', 34, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.684338', 75, 4, '2024-11-12 16:06:27.684338', 16, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.68677', 76, 4, '2024-11-12 16:06:27.68677', 16, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.688237', 77, 4, '2024-11-12 16:06:27.688237', 16, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.689579', 78, 4, '2024-11-12 16:06:27.689579', 16, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.691097', 79, 4, '2024-11-12 16:06:27.691097', 16, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 16:06:27.692516', 80, 4, '2024-11-12 16:06:27.692516', 16, 'private void handleOpen(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug("#handleOpen");
        // 1. 필요한 정보 추출
        String gitlabUrl = getGitlabUrl(gitlabEventRequest);
        Long gitlabProjectId = gitlabEventRequest.project().id();
        Long iid = gitlabEventRequest.objectAttributes().iid();
        String mrDescription = gitlabEventRequest.objectAttributes().description();
        String targetBranch = gitlabEventRequest.objectAttributes().targetBranch();
        LocalDateTime gitlabCreatedDate =
                gitlabEventRequest.objectAttributes().createdAt().toLocalDateTime();
        // 2. gitlab project token 찾기
        Project project = projectRepository.getById(projectId);
        String token = project.getBotToken();
        // 3. 리뷰 달기
        reviewCreateService.makeCodeReviewWhenCalledByWebhook(
                gitlabUrl,
                token,
                gitlabProjectId,
                iid,
                mrDescription,
                targetBranch,
                gitlabCreatedDate,
                projectId);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:06:31.428524', 81, 4, '2024-11-12 17:06:31.428524', 18, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:06:31.434352', 82, 4, '2024-11-12 17:06:31.434352', 18, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:10:18.538186', 83, 4, '2024-11-12 17:10:18.538186', 19, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:10:18.540605', 84, 4, '2024-11-12 17:10:18.540605', 19, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:10:18.54206', 85, 17, '2024-11-12 17:10:18.54206', 19, '레이아웃은 유동적이어야함', '참고자료 1');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:14:30.835227', 86, 4, '2024-11-12 17:14:30.835227', 20, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:14:30.83709', 87, 4, '2024-11-12 17:14:30.83709', 20, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:14:30.83863', 88, 17, '2024-11-12 17:14:30.83863', 20, '레이아웃은 유동적이어야함', '참고자료 1');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:14:30.840521', 89, 2, '2024-11-12 17:14:30.840521', 20, '// JavaScript
console.log("Hello, World!");
', 'asdasdadsa');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:15:31.14969', 90, 4, '2024-11-12 17:15:31.14969', 21, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:15:31.151309', 91, 4, '2024-11-12 17:15:31.151309', 21, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:15:31.152629', 92, 17, '2024-11-12 17:15:31.152629', 21, '레이아웃은 유동적이어야함', '참고자료 1');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:15:31.153768', 93, 2, '2024-11-12 17:15:31.153768', 21, '// JavaScript
console.log("Hello, World!");
', 'asdasdadsa');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:15:31.154859', 94, 2, '2024-11-12 17:15:31.154859', 21, '// JavaScript
console.log("Hello, World!");
', 'asdsadsad/tss');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:17:10.008142', 95, 4, '2024-11-12 17:17:10.008142', 22, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:19:05.043101', 96, 4, '2024-11-12 17:19:05.043101', 23, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:19:05.044548', 97, 2, '2024-11-12 17:19:05.044548', 23, '// JavaScript
console.log("Hello, World!");
', 'asdsadsadasd');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.40275', 224, 2, '2024-11-12 18:24:52.40275', 41, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.48612', 98, 4, '2024-11-12 17:21:54.48612', 24, 'public String buildMergeRequestQuery(String fullPath, Long gitMergeRequestIid) {
        return String.format(
                "query { "
                        + "  project(fullPath: \"%s\") { "
                        + "    mergeRequest(iid: \"%d\") { "
                        + "      id "
                        + "      iid "
                        + "      title "
                        + "      description "
                        + "      state "
                        + "      mergedAt "
                        + "      createdAt "
                        + "      updatedAt "
                        + "      sourceBranch "
                        + "      targetBranch "
                        + "      labels { "
                        + "        nodes { "
                        + "          title "
                        + "          color "
                        + "        } "
                        + "      } "
                        + "      assignees(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "      reviewers(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "    } "
                        + "  } "
                        + "}",
                fullPath, gitMergeRequestIid);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.487841', 99, 4, '2024-11-12 17:21:54.487841', 24, 'public String createSingleProjectQuery(Long gitlabProjectId) {
        return String.format(
                "query { "
                        + "  projects(membership: true, ids: [\"gid://gitlab/Project/%d\"]) { "
                        + "    nodes { "
                        + "      id "
                        + "      name "
                        + "      description "
                        + "      httpUrlToRepo "
                        + "      fullPath "
                        + "    } "
                        + "  } "
                        + "}",
                gitlabProjectId);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.488978', 100, 4, '2024-11-12 17:21:54.488978', 24, 'public ProjectInfoContent getProjectInfoDetail(
            String gitlabUrl, String token, Long gitlabProjectId, String fullPath) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(graphqlUtil.createProjectInfoQuery(fullPath))
                                    .executeSync();
                    GitlabProjectInfoContent content =
                            response.field("project").toEntity(GitlabProjectInfoContent.class);
                    Long branchCount = getProjectBranchCount(gitlabUrl, token, gitlabProjectId);

                    int commitCount =
                            (content != null && content.statistics() != null)
                                    ? content.statistics().commitCount()
                                    : 0;

                    Long mergeRequestCount =
                            (content != null && content.mergeRequests() != null)
                                    ? content.mergeRequests().count()
                                    : 0L;

                    return ProjectInfoContent.of(
                            commitCount, branchCount, mergeRequestCount, content.languages());
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.49011', 101, 4, '2024-11-12 17:21:54.49011', 24, 'public GitlabMrQueryContent getSingleMergeRequest(
            String gitlabUrl, String token, String fullPath, Long mergeRequestIid) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(
                                            graphqlUtil.buildMergeRequestQuery(
                                                    fullPath, mergeRequestIid))
                                    .executeSync();
                    return response.field("project.mergeRequest")
                            .toEntity(GitlabMrQueryContent.class);
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.49126', 102, 4, '2024-11-12 17:21:54.49126', 24, 'public String createProjectInfoQuery(String fullPath) {
        return String.format(
                "query { "
                        + "  project(fullPath: \"%s\") { "
                        + "    mergeRequests { count } "
                        + "    languages { name color share } "
                        + "    statistics { commitCount } "
                        + "  } "
                        + "}",
                fullPath);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.492671', 103, 4, '2024-11-12 17:21:54.492671', 24, 'public static String createMRDiffsUrl(String gitlabUrl, Long gitlabProjectId, Long iid) {
        return URL_PROTOCOL_HTTPS
                + gitlabUrl
                + SINGLE_PROJECT_ENDPOINT
                + gitlabProjectId
                + "/merge_requests/"
                + iid
                + "/diffs";
    }', 'GitLabApiUrlBuilder.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.493803', 104, 4, '2024-11-12 17:21:54.493803', 24, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.494906', 105, 4, '2024-11-12 17:21:54.494906', 24, 'public String createSearchProjectQuery(GitlabSearchRequest gitlabSearchRequest) {
        return String.format(
                "query { "
                        + "  projects(membership: true, search: \"%s\"%s) { "
                        + "    nodes { "
                        + "      id "
                        + "      fullPath "
                        + "    } "
                        + "    pageInfo { "
                        + "      startCursor "
                        + "      hasNextPage "
                        + "      hasPreviousPage "
                        + "      endCursor "
                        + "    } "
                        + "  } "
                        + "}",
                gitlabSearchRequest.keyword(), createPagination(gitlabSearchRequest));
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.49616', 106, 4, '2024-11-12 17:21:54.49616', 24, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:21:54.497301', 107, 4, '2024-11-12 17:21:54.497301', 24, 'public static String createSearchMergeRequestUrl(
            String gitlabUrl, Long gitlabProjectId, GitlabMrPageRequest request, String createAt) {
        return URL_PROTOCOL_HTTPS
                + gitlabUrl
                + SINGLE_PROJECT_ENDPOINT
                + gitlabProjectId
                + "/merge_requests"
                + "?state="
                + request.state()
                + "&search="
                + request.keyword()
                + "&page="
                + request.page()
                + "&per_page="
                + request.size()
                + "&created_after="
                + createAt;
    }', 'GitLabApiUrlBuilder.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:22:18.319686', 108, 4, '2024-11-12 17:22:18.319686', 25, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:22:18.322327', 109, 3, '2024-11-12 17:22:18.322327', 25, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:25:47.039252', 110, 4, '2024-11-12 17:25:47.039252', 26, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:25:47.040836', 111, 3, '2024-11-12 17:25:47.040836', 26, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:25:47.042063', 112, 2, '2024-11-12 17:25:47.042063', 26, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:28:56.086288', 113, 4, '2024-11-12 17:28:56.086288', 27, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:28:56.08763', 114, 3, '2024-11-12 17:28:56.08763', 27, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:28:56.088818', 115, 2, '2024-11-12 17:28:56.088818', 27, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:28:56.089862', 116, 2, '2024-11-12 17:28:56.089862', 27, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:33:49.775268', 117, 4, '2024-11-12 17:33:49.775268', 28, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:33:49.776534', 118, 3, '2024-11-12 17:33:49.776534', 28, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:33:49.777964', 119, 2, '2024-11-12 17:33:49.777964', 28, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:33:49.779232', 120, 2, '2024-11-12 17:33:49.779232', 28, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:34:25.847889', 121, 4, '2024-11-12 17:34:25.847889', 29, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:34:25.849131', 122, 3, '2024-11-12 17:34:25.849131', 29, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:34:25.850509', 123, 2, '2024-11-12 17:34:25.850509', 29, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:34:25.851942', 124, 2, '2024-11-12 17:34:25.851942', 29, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:34:25.853093', 125, 2, '2024-11-12 17:34:25.853093', 29, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.883519', 126, 4, '2024-11-12 17:35:45.883519', 30, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.885021', 127, 3, '2024-11-12 17:35:45.885021', 30, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.886219', 128, 2, '2024-11-12 17:35:45.886219', 30, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.887391', 129, 2, '2024-11-12 17:35:45.887391', 30, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.888938', 130, 2, '2024-11-12 17:35:45.888938', 30, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:35:45.890223', 131, 2, '2024-11-12 17:35:45.890223', 30, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㅁ', 'ㅁㄴㅇㄴㅁㅇㅁㅁㄴㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:02.996822', 132, 4, '2024-11-12 17:38:02.996822', 31, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:02.998684', 133, 3, '2024-11-12 17:38:02.998684', 31, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:02.999946', 134, 2, '2024-11-12 17:38:02.999946', 31, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:03.001181', 135, 2, '2024-11-12 17:38:03.001181', 31, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:03.002332', 136, 2, '2024-11-12 17:38:03.002332', 31, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:03.003846', 137, 2, '2024-11-12 17:38:03.003846', 31, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㅁ', 'ㅁㄴㅇㄴㅁㅇㅁㅁㄴㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:03.005167', 138, 2, '2024-11-12 17:38:03.005167', 31, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.977266', 139, 4, '2024-11-12 17:38:36.977266', 32, 'public String buildMergeRequestQuery(String fullPath, Long gitMergeRequestIid) {
        return String.format(
                "query { "
                        + "  project(fullPath: \"%s\") { "
                        + "    mergeRequest(iid: \"%d\") { "
                        + "      id "
                        + "      iid "
                        + "      title "
                        + "      description "
                        + "      state "
                        + "      mergedAt "
                        + "      createdAt "
                        + "      updatedAt "
                        + "      sourceBranch "
                        + "      targetBranch "
                        + "      labels { "
                        + "        nodes { "
                        + "          title "
                        + "          color "
                        + "        } "
                        + "      } "
                        + "      assignees(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "      reviewers(first: 1) { "
                        + "        nodes { "
                        + "          username "
                        + "          name "
                        + "          avatarUrl "
                        + "        } "
                        + "      } "
                        + "    } "
                        + "  } "
                        + "}",
                fullPath, gitMergeRequestIid);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.404191', 225, 2, '2024-11-12 18:24:52.404191', 41, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.405284', 226, 2, '2024-11-12 18:24:52.405284', 41, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.40652', 227, 2, '2024-11-12 18:24:52.40652', 41, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㅁ', 'ㅁㄴㅇㄴㅁㅇㅁㅁㄴㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.978867', 140, 4, '2024-11-12 17:38:36.978867', 32, 'public String createSingleProjectQuery(Long gitlabProjectId) {
        return String.format(
                "query { "
                        + "  projects(membership: true, ids: [\"gid://gitlab/Project/%d\"]) { "
                        + "    nodes { "
                        + "      id "
                        + "      name "
                        + "      description "
                        + "      httpUrlToRepo "
                        + "      fullPath "
                        + "    } "
                        + "  } "
                        + "}",
                gitlabProjectId);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.980438', 141, 4, '2024-11-12 17:38:36.980438', 32, 'public ProjectInfoContent getProjectInfoDetail(
            String gitlabUrl, String token, Long gitlabProjectId, String fullPath) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(graphqlUtil.createProjectInfoQuery(fullPath))
                                    .executeSync();
                    GitlabProjectInfoContent content =
                            response.field("project").toEntity(GitlabProjectInfoContent.class);
                    Long branchCount = getProjectBranchCount(gitlabUrl, token, gitlabProjectId);

                    int commitCount =
                            (content != null && content.statistics() != null)
                                    ? content.statistics().commitCount()
                                    : 0;

                    Long mergeRequestCount =
                            (content != null && content.mergeRequests() != null)
                                    ? content.mergeRequests().count()
                                    : 0L;

                    return ProjectInfoContent.of(
                            commitCount, branchCount, mergeRequestCount, content.languages());
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.981668', 142, 4, '2024-11-12 17:38:36.981668', 32, 'public GitlabMrQueryContent getSingleMergeRequest(
            String gitlabUrl, String token, String fullPath, Long mergeRequestIid) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(
                                            graphqlUtil.buildMergeRequestQuery(
                                                    fullPath, mergeRequestIid))
                                    .executeSync();
                    return response.field("project.mergeRequest")
                            .toEntity(GitlabMrQueryContent.class);
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.982941', 143, 4, '2024-11-12 17:38:36.982941', 32, 'public String createProjectInfoQuery(String fullPath) {
        return String.format(
                "query { "
                        + "  project(fullPath: \"%s\") { "
                        + "    mergeRequests { count } "
                        + "    languages { name color share } "
                        + "    statistics { commitCount } "
                        + "  } "
                        + "}",
                fullPath);
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.984094', 144, 4, '2024-11-12 17:38:36.984094', 32, 'public static String createMRDiffsUrl(String gitlabUrl, Long gitlabProjectId, Long iid) {
        return URL_PROTOCOL_HTTPS
                + gitlabUrl
                + SINGLE_PROJECT_ENDPOINT
                + gitlabProjectId
                + "/merge_requests/"
                + iid
                + "/diffs";
    }', 'GitLabApiUrlBuilder.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.98537', 145, 4, '2024-11-12 17:38:36.98537', 32, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.98644', 146, 4, '2024-11-12 17:38:36.98644', 32, 'public String createSearchProjectQuery(GitlabSearchRequest gitlabSearchRequest) {
        return String.format(
                "query { "
                        + "  projects(membership: true, search: \"%s\"%s) { "
                        + "    nodes { "
                        + "      id "
                        + "      fullPath "
                        + "    } "
                        + "    pageInfo { "
                        + "      startCursor "
                        + "      hasNextPage "
                        + "      hasPreviousPage "
                        + "      endCursor "
                        + "    } "
                        + "  } "
                        + "}",
                gitlabSearchRequest.keyword(), createPagination(gitlabSearchRequest));
    }', 'GraphQlUtil.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.98742', 147, 4, '2024-11-12 17:38:36.98742', 32, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:38:36.988491', 148, 4, '2024-11-12 17:38:36.988491', 32, 'public static String createSearchMergeRequestUrl(
            String gitlabUrl, Long gitlabProjectId, GitlabMrPageRequest request, String createAt) {
        return URL_PROTOCOL_HTTPS
                + gitlabUrl
                + SINGLE_PROJECT_ENDPOINT
                + gitlabProjectId
                + "/merge_requests"
                + "?state="
                + request.state()
                + "&search="
                + request.keyword()
                + "&page="
                + request.page()
                + "&per_page="
                + request.size()
                + "&created_after="
                + createAt;
    }', 'GitLabApiUrlBuilder.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.404083', 149, 4, '2024-11-12 17:40:33.404083', 33, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.40534', 150, 3, '2024-11-12 17:40:33.40534', 33, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.406333', 151, 2, '2024-11-12 17:40:33.406333', 33, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.407392', 152, 2, '2024-11-12 17:40:33.407392', 33, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.408441', 153, 2, '2024-11-12 17:40:33.408441', 33, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 17:40:33.409395', 154, 2, '2024-11-12 17:40:33.409395', 33, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㅁ', 'ㅁㄴㅇㄴㅁㅇㅁㅁㄴㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.750686', 157, 4, '2024-11-12 18:01:51.750686', 34, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.75178', 158, 4, '2024-11-12 18:01:51.75178', 34, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.753282', 159, 4, '2024-11-12 18:01:51.753282', 34, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.754316', 160, 4, '2024-11-12 18:01:51.754316', 34, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.75537', 161, 4, '2024-11-12 18:01:51.75537', 34, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.756407', 162, 4, '2024-11-12 18:01:51.756407', 34, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.757834', 163, 4, '2024-11-12 18:01:51.757834', 34, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.759119', 164, 4, '2024-11-12 18:01:51.759119', 34, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:01:51.760201', 165, 4, '2024-11-12 18:01:51.760201', 34, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.984717', 166, 4, '2024-11-12 18:04:31.984717', 35, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.407735', 228, 2, '2024-11-12 18:24:52.407735', 41, '// JavaScript
console.log("Hello, World!");
ㄴ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.990579', 167, 4, '2024-11-12 18:04:31.990579', 35, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.992703', 168, 4, '2024-11-12 18:04:31.992703', 35, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.994243', 169, 4, '2024-11-12 18:04:31.994243', 35, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.995798', 170, 4, '2024-11-12 18:04:31.995798', 35, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:31.998054', 171, 4, '2024-11-12 18:04:31.998054', 35, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:32.000805', 172, 4, '2024-11-12 18:04:32.000805', 35, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.977916', 173, 4, '2024-11-12 18:04:48.977916', 36, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.979665', 174, 4, '2024-11-12 18:04:48.979665', 36, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.222173', 1027, 2, '2024-11-13 14:12:20.222173', 121, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.984211', 175, 4, '2024-11-12 18:04:48.984211', 36, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.98636', 176, 4, '2024-11-12 18:04:48.98636', 36, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.988164', 177, 4, '2024-11-12 18:04:48.988164', 36, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.989556', 178, 4, '2024-11-12 18:04:48.989556', 36, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.990946', 179, 4, '2024-11-12 18:04:48.990946', 36, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.992484', 180, 4, '2024-11-12 18:04:48.992484', 36, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.993858', 181, 4, '2024-11-12 18:04:48.993858', 36, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:04:48.995315', 182, 4, '2024-11-12 18:04:48.995315', 36, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.868685', 183, 2, '2024-11-12 18:10:45.868685', 37, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.870435', 184, 4, '2024-11-12 18:10:45.870435', 37, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.871831', 185, 3, '2024-11-12 18:10:45.871831', 37, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.873566', 186, 2, '2024-11-12 18:10:45.873566', 37, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.874895', 187, 2, '2024-11-12 18:10:45.874895', 37, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.876261', 188, 2, '2024-11-12 18:10:45.876261', 37, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.877573', 189, 2, '2024-11-12 18:10:45.877573', 37, '// JavaScript
console.log("Hello, World!");
ㅁㄴㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㅁ', 'ㅁㄴㅇㄴㅁㅇㅁㅁㄴㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:10:45.878777', 190, 2, '2024-11-12 18:10:45.878777', 37, '// JavaScript
console.log("Hello, World!");
ㄴ', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.012379', 191, 4, '2024-11-12 18:16:59.012379', 38, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.235905', 229, 4, '2024-11-12 18:33:28.235905', 42, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.014011', 192, 4, '2024-11-12 18:16:59.014011', 38, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.015354', 193, 4, '2024-11-12 18:16:59.015354', 38, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.016556', 194, 4, '2024-11-12 18:16:59.016556', 38, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.01783', 195, 4, '2024-11-12 18:16:59.01783', 38, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.019032', 196, 4, '2024-11-12 18:16:59.019032', 38, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.02025', 197, 4, '2024-11-12 18:16:59.02025', 38, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.021518', 198, 4, '2024-11-12 18:16:59.021518', 38, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.022765', 199, 4, '2024-11-12 18:16:59.022765', 38, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:16:59.024115', 200, 4, '2024-11-12 18:16:59.024115', 38, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.608723', 201, 4, '2024-11-12 18:17:51.608723', 39, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.610687', 202, 4, '2024-11-12 18:17:51.610687', 39, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.611911', 203, 4, '2024-11-12 18:17:51.611911', 39, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.613054', 204, 4, '2024-11-12 18:17:51.613054', 39, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.614223', 205, 4, '2024-11-12 18:17:51.614223', 39, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.61531', 206, 4, '2024-11-12 18:17:51.61531', 39, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.616423', 207, 4, '2024-11-12 18:17:51.616423', 39, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.617791', 208, 4, '2024-11-12 18:17:51.617791', 39, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.61891', 209, 4, '2024-11-12 18:17:51.61891', 39, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:17:51.620118', 210, 4, '2024-11-12 18:17:51.620118', 39, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.711904', 211, 4, '2024-11-12 18:18:25.711904', 40, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.713529', 212, 4, '2024-11-12 18:18:25.713529', 40, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.715067', 213, 4, '2024-11-12 18:18:25.715067', 40, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.71632', 214, 4, '2024-11-12 18:18:25.71632', 40, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.717499', 215, 4, '2024-11-12 18:18:25.717499', 40, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.718697', 216, 4, '2024-11-12 18:18:25.718697', 40, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.719811', 217, 4, '2024-11-12 18:18:25.719811', 40, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.721106', 218, 4, '2024-11-12 18:18:25.721106', 40, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.722384', 219, 4, '2024-11-12 18:18:25.722384', 40, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:18:25.723741', 220, 4, '2024-11-12 18:18:25.723741', 40, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.398792', 221, 2, '2024-11-12 18:24:52.398792', 41, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.400318', 222, 4, '2024-11-12 18:24:52.400318', 41, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:24:52.401428', 223, 3, '2024-11-12 18:24:52.401428', 41, '# Python
print("Hello, World!")
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.238437', 230, 4, '2024-11-12 18:33:28.238437', 42, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.240237', 231, 4, '2024-11-12 18:33:28.240237', 42, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.241498', 232, 4, '2024-11-12 18:33:28.241498', 42, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.242724', 233, 4, '2024-11-12 18:33:28.242724', 42, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.244089', 234, 4, '2024-11-12 18:33:28.244089', 42, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.24549', 235, 4, '2024-11-12 18:33:28.24549', 42, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.246609', 236, 4, '2024-11-12 18:33:28.246609', 42, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:33:28.247718', 237, 16, '2024-11-12 18:33:28.247718', 42, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.163643', 238, 4, '2024-11-12 18:42:12.163643', 43, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.999681', 294, 4, '2024-11-13 09:50:18.999681', 48, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:30:17.595562', 1108, 4, '2024-11-14 10:30:17.595562', 145, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.165302', 239, 4, '2024-11-12 18:42:12.165302', 43, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.166573', 240, 4, '2024-11-12 18:42:12.166573', 43, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.167614', 241, 4, '2024-11-12 18:42:12.167614', 43, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.168819', 242, 4, '2024-11-12 18:42:12.168819', 43, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.169923', 243, 4, '2024-11-12 18:42:12.169923', 43, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.171305', 244, 4, '2024-11-12 18:42:12.171305', 43, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.172412', 245, 4, '2024-11-12 18:42:12.172412', 43, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.173449', 246, 16, '2024-11-12 18:42:12.173449', 43, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:12.174476', 247, 2, '2024-11-12 18:42:12.174476', 43, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.184126', 248, 4, '2024-11-12 18:42:30.184126', 44, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.349945', 295, 4, '2024-11-13 10:00:28.349945', 49, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:13:12.229543', 1279, 4, '2024-11-15 19:13:12.229543', 179, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:13:12.230993', 1280, 2, '2024-11-15 19:13:12.230993', 179, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.368044', 875, 4, '2024-11-13 13:22:02.368044', 105, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:13:12.23256', 1281, 2, '2024-11-15 19:13:12.23256', 179, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.185449', 249, 4, '2024-11-12 18:42:30.185449', 44, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.186732', 250, 4, '2024-11-12 18:42:30.186732', 44, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.187852', 251, 4, '2024-11-12 18:42:30.187852', 44, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.18885', 252, 4, '2024-11-12 18:42:30.18885', 44, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.189831', 253, 4, '2024-11-12 18:42:30.189831', 44, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.19101', 254, 4, '2024-11-12 18:42:30.19101', 44, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.19216', 255, 4, '2024-11-12 18:42:30.19216', 44, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.193358', 256, 16, '2024-11-12 18:42:30.193358', 44, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:30.194438', 257, 2, '2024-11-12 18:42:30.194438', 44, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.881761', 258, 4, '2024-11-12 18:42:38.881761', 45, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.940126', 377, 4, '2024-11-13 10:20:12.940126', 57, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.369503', 876, 4, '2024-11-13 13:22:02.369503', 105, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.45184', 1297, 4, '2024-11-15 19:45:01.45184', 183, '@Bean
    public MessageChannel reviewResponseChannel() {
        return new DirectChannel();
    }', 'RedisIntegrationConfig.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.883319', 259, 4, '2024-11-12 18:42:38.883319', 45, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.884553', 260, 4, '2024-11-12 18:42:38.884553', 45, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.885591', 261, 4, '2024-11-12 18:42:38.885591', 45, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.886672', 262, 4, '2024-11-12 18:42:38.886672', 45, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.887768', 263, 4, '2024-11-12 18:42:38.887768', 45, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.889053', 264, 4, '2024-11-12 18:42:38.889053', 45, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.890144', 265, 4, '2024-11-12 18:42:38.890144', 45, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:42:38.89121', 266, 16, '2024-11-12 18:42:38.89121', 45, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.816554', 267, 4, '2024-11-12 18:43:04.816554', 46, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.941723', 378, 4, '2024-11-13 10:20:12.941723', 57, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.270225', 894, 2, '2024-11-13 13:30:26.270225', 107, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.271702', 895, 4, '2024-11-13 13:30:26.271702', 107, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.818258', 268, 4, '2024-11-12 18:43:04.818258', 46, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.819607', 269, 4, '2024-11-12 18:43:04.819607', 46, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.820781', 270, 4, '2024-11-12 18:43:04.820781', 46, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.82187', 271, 4, '2024-11-12 18:43:04.82187', 46, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.823011', 272, 4, '2024-11-12 18:43:04.823011', 46, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.824305', 273, 4, '2024-11-12 18:43:04.824305', 46, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.825434', 274, 4, '2024-11-12 18:43:04.825434', 46, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-12 18:43:04.826587', 275, 16, '2024-11-12 18:43:04.826587', 46, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.590767', 276, 4, '2024-11-13 09:12:56.590767', 47, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.943868', 379, 4, '2024-11-13 10:20:12.943868', 57, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.27286', 896, 4, '2024-11-13 13:30:26.27286', 107, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:23:15.31697', 1306, 4, '2024-11-16 14:23:15.31697', 184, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.594691', 277, 4, '2024-11-13 09:12:56.594691', 47, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.596166', 278, 4, '2024-11-13 09:12:56.596166', 47, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.600123', 280, 4, '2024-11-13 09:12:56.600123', 47, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.601549', 281, 4, '2024-11-13 09:12:56.601549', 47, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.603074', 282, 4, '2024-11-13 09:12:56.603074', 47, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.604329', 283, 4, '2024-11-13 09:12:56.604329', 47, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:12:56.605525', 284, 16, '2024-11-13 09:12:56.605525', 47, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.986529', 285, 4, '2024-11-13 09:50:18.986529', 48, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:23:15.320575', 1307, 4, '2024-11-16 14:23:15.320575', 184, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.988763', 286, 4, '2024-11-13 09:50:18.988763', 48, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.990242', 287, 4, '2024-11-13 09:50:18.990242', 48, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.991806', 288, 4, '2024-11-13 09:50:18.991806', 48, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.99308', 289, 4, '2024-11-13 09:50:18.99308', 48, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.994374', 290, 4, '2024-11-13 09:50:18.994374', 48, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.995674', 291, 4, '2024-11-13 09:50:18.995674', 48, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.996917', 292, 4, '2024-11-13 09:50:18.996917', 48, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 09:50:18.998057', 293, 4, '2024-11-13 09:50:18.998057', 48, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.774231', 1367, 4, '2024-11-17 18:10:42.774231', 194, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.357574', 296, 4, '2024-11-13 10:00:28.357574', 49, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.361536', 297, 4, '2024-11-13 10:00:28.361536', 49, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.36436', 298, 4, '2024-11-13 10:00:28.36436', 49, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.366153', 299, 4, '2024-11-13 10:00:28.366153', 49, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.368879', 300, 4, '2024-11-13 10:00:28.368879', 49, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.372132', 301, 4, '2024-11-13 10:00:28.372132', 49, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.374949', 302, 4, '2024-11-13 10:00:28.374949', 49, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.377523', 303, 16, '2024-11-13 10:00:28.377523', 49, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:00:28.378943', 304, 2, '2024-11-13 10:00:28.378943', 49, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.903837', 305, 4, '2024-11-13 10:02:39.903837', 50, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.944995', 380, 4, '2024-11-13 10:20:12.944995', 57, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.946132', 381, 4, '2024-11-13 10:20:12.946132', 57, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.905593', 306, 4, '2024-11-13 10:02:39.905593', 50, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.906903', 307, 4, '2024-11-13 10:02:39.906903', 50, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.908124', 308, 4, '2024-11-13 10:02:39.908124', 50, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.909245', 309, 4, '2024-11-13 10:02:39.909245', 50, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.910597', 310, 4, '2024-11-13 10:02:39.910597', 50, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.911865', 311, 4, '2024-11-13 10:02:39.911865', 50, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.913009', 312, 4, '2024-11-13 10:02:39.913009', 50, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.914612', 313, 16, '2024-11-13 10:02:39.914612', 50, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:39.915744', 314, 2, '2024-11-13 10:02:39.915744', 50, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.257218', 315, 4, '2024-11-13 10:02:40.257218', 51, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.263817', 388, 4, '2024-11-13 10:21:50.263817', 58, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.274185', 897, 4, '2024-11-13 13:30:26.274185', 107, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.258827', 316, 4, '2024-11-13 10:02:40.258827', 51, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.260188', 317, 4, '2024-11-13 10:02:40.260188', 51, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.261416', 318, 4, '2024-11-13 10:02:40.261416', 51, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.262552', 319, 4, '2024-11-13 10:02:40.262552', 51, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.263651', 320, 4, '2024-11-13 10:02:40.263651', 51, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.264859', 321, 4, '2024-11-13 10:02:40.264859', 51, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.265972', 322, 4, '2024-11-13 10:02:40.265972', 51, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.267335', 323, 16, '2024-11-13 10:02:40.267335', 51, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.26874', 324, 2, '2024-11-13 10:02:40.26874', 51, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.63553', 325, 4, '2024-11-13 10:02:40.63553', 52, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.26509', 389, 4, '2024-11-13 10:21:50.26509', 58, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.144835', 448, 4, '2024-11-13 10:36:50.144835', 63, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.275267', 898, 4, '2024-11-13 13:30:26.275267', 107, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.637081', 326, 4, '2024-11-13 10:02:40.637081', 52, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.638382', 327, 4, '2024-11-13 10:02:40.638382', 52, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.640089', 328, 4, '2024-11-13 10:02:40.640089', 52, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.641305', 329, 4, '2024-11-13 10:02:40.641305', 52, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.642522', 330, 4, '2024-11-13 10:02:40.642522', 52, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.644087', 331, 4, '2024-11-13 10:02:40.644087', 52, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.645275', 332, 4, '2024-11-13 10:02:40.645275', 52, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.646706', 333, 16, '2024-11-13 10:02:40.646706', 52, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:40.647934', 334, 2, '2024-11-13 10:02:40.647934', 52, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.210353', 335, 4, '2024-11-13 10:02:41.210353', 53, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.266171', 390, 4, '2024-11-13 10:21:50.266171', 58, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.211711', 336, 4, '2024-11-13 10:02:41.211711', 53, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.213011', 337, 4, '2024-11-13 10:02:41.213011', 53, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.214368', 338, 4, '2024-11-13 10:02:41.214368', 53, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.215561', 339, 4, '2024-11-13 10:02:41.215561', 53, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.216779', 340, 4, '2024-11-13 10:02:41.216779', 53, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.218091', 341, 4, '2024-11-13 10:02:41.218091', 53, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.219183', 342, 4, '2024-11-13 10:02:41.219183', 53, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.220802', 343, 16, '2024-11-13 10:02:41.220802', 53, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.2219', 344, 2, '2024-11-13 10:02:41.2219', 53, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.886669', 345, 4, '2024-11-13 10:02:41.886669', 54, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.267265', 391, 4, '2024-11-13 10:21:50.267265', 58, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.465364', 460, 4, '2024-11-13 10:38:02.465364', 64, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.418427', 916, 2, '2024-11-13 13:34:21.418427', 109, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.888407', 346, 4, '2024-11-13 10:02:41.888407', 54, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.889824', 347, 4, '2024-11-13 10:02:41.889824', 54, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.890874', 348, 4, '2024-11-13 10:02:41.890874', 54, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.891936', 349, 4, '2024-11-13 10:02:41.891936', 54, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.893059', 350, 4, '2024-11-13 10:02:41.893059', 54, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.894236', 351, 4, '2024-11-13 10:02:41.894236', 54, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.895328', 352, 4, '2024-11-13 10:02:41.895328', 54, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.896789', 353, 16, '2024-11-13 10:02:41.896789', 54, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:41.898143', 354, 2, '2024-11-13 10:02:41.898143', 54, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.145446', 355, 4, '2024-11-13 10:02:42.145446', 55, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.268279', 392, 4, '2024-11-13 10:21:50.268279', 58, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.147', 356, 4, '2024-11-13 10:02:42.147', 55, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.148459', 357, 4, '2024-11-13 10:02:42.148459', 55, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.149658', 358, 4, '2024-11-13 10:02:42.149658', 55, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.151154', 359, 4, '2024-11-13 10:02:42.151154', 55, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.152251', 360, 4, '2024-11-13 10:02:42.152251', 55, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.153538', 361, 4, '2024-11-13 10:02:42.153538', 55, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.154734', 362, 4, '2024-11-13 10:02:42.154734', 55, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.155845', 363, 16, '2024-11-13 10:02:42.155845', 55, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.157037', 364, 2, '2024-11-13 10:02:42.157037', 55, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.566489', 365, 4, '2024-11-13 10:02:42.566489', 56, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.269325', 393, 4, '2024-11-13 10:21:50.269325', 58, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.261372', 485, 2, '2024-11-13 10:44:37.261372', 66, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.262553', 486, 2, '2024-11-13 10:44:37.262553', 66, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.420366', 917, 4, '2024-11-13 13:34:21.420366', 109, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.567771', 366, 4, '2024-11-13 10:02:42.567771', 56, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.568991', 367, 4, '2024-11-13 10:02:42.568991', 56, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.569968', 368, 4, '2024-11-13 10:02:42.569968', 56, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.571093', 369, 4, '2024-11-13 10:02:42.571093', 56, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.572458', 370, 4, '2024-11-13 10:02:42.572458', 56, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.573692', 371, 4, '2024-11-13 10:02:42.573692', 56, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.574775', 372, 4, '2024-11-13 10:02:42.574775', 56, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.576113', 373, 16, '2024-11-13 10:02:42.576113', 56, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:02:42.577181', 374, 2, '2024-11-13 10:02:42.577181', 56, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.936953', 375, 4, '2024-11-13 10:20:12.936953', 57, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.938855', 376, 4, '2024-11-13 10:20:12.938855', 57, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.870614', 1368, 4, '2024-11-17 18:10:42.870614', 195, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.947113', 382, 4, '2024-11-13 10:20:12.947113', 57, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.948271', 383, 4, '2024-11-13 10:20:12.948271', 57, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:20:12.949262', 384, 4, '2024-11-13 10:20:12.949262', 57, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.26012', 385, 4, '2024-11-13 10:21:50.26012', 58, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.261486', 386, 4, '2024-11-13 10:21:50.261486', 58, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.262697', 387, 4, '2024-11-13 10:21:50.262697', 58, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.131683', 504, 4, '2024-11-13 10:49:23.131683', 68, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.421556', 918, 4, '2024-11-13 13:34:21.421556', 109, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.270352', 394, 4, '2024-11-13 10:21:50.270352', 58, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:21:50.271406', 395, 2, '2024-11-13 10:21:50.271406', 58, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.013551', 396, 4, '2024-11-13 10:23:17.013551', 59, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.014912', 397, 4, '2024-11-13 10:23:17.014912', 59, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.015952', 398, 4, '2024-11-13 10:23:17.015952', 59, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.017015', 399, 4, '2024-11-13 10:23:17.017015', 59, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.018187', 400, 4, '2024-11-13 10:23:17.018187', 59, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.927929', 523, 2, '2024-11-13 10:50:45.927929', 69, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.928997', 524, 2, '2024-11-13 10:50:45.928997', 69, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.929908', 525, 2, '2024-11-13 10:50:45.929908', 69, '// JavaScript
console.log("Hello, World!");
', 'asdasdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.931089', 526, 2, '2024-11-13 10:50:45.931089', 69, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.736732', 1282, 4, '2024-11-15 19:15:58.736732', 180, 'public List<ChannelCodeResponse> getChannelCodeList() {
        List<ChannelCode> channelCodes = channelCodeRepository.findAll();
        return channelCodes.stream().map(ChannelCodeResponse::of).toList();
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.019226', 401, 4, '2024-11-13 10:23:17.019226', 59, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.020392', 402, 4, '2024-11-13 10:23:17.020392', 59, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.021368', 403, 4, '2024-11-13 10:23:17.021368', 59, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.022376', 404, 4, '2024-11-13 10:23:17.022376', 59, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.023435', 405, 4, '2024-11-13 10:23:17.023435', 59, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:23:17.024518', 406, 2, '2024-11-13 10:23:17.024518', 59, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.893418', 407, 4, '2024-11-13 10:27:42.893418', 60, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.896229', 408, 4, '2024-11-13 10:27:42.896229', 60, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.898009', 409, 4, '2024-11-13 10:27:42.898009', 60, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.73868', 1283, 4, '2024-11-15 19:15:58.73868', 180, '@Bean
    public MessageChannel reviewResponseChannel() {
        return new DirectChannel();
    }', 'RedisIntegrationConfig.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.899216', 410, 4, '2024-11-13 10:27:42.899216', 60, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.900444', 411, 4, '2024-11-13 10:27:42.900444', 60, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.901615', 412, 4, '2024-11-13 10:27:42.901615', 60, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.902737', 413, 4, '2024-11-13 10:27:42.902737', 60, 'private GitlabProjectResponse createGitlabProjectResponse(
            GitlabProjectSimpleContent content, Long gitlabAccountId) {
        return projectRepository
                .findByGitlabProjectId(GraphQlUtil.extractIdFromId(content.id()))
                .map(
                        project -> {
                            boolean isLinked = isProjectLinked(gitlabAccountId, project.getId());
                            return GitlabProjectResponse.ofLinkable(content, isLinked);
                        })
                .orElseGet(() -> GitlabProjectResponse.ofNonLinkable(content));
    }', 'GitlabApiService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.903782', 414, 4, '2024-11-13 10:27:42.903782', 60, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.904824', 415, 4, '2024-11-13 10:27:42.904824', 60, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:27:42.90627', 416, 4, '2024-11-13 10:27:42.90627', 60, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.021815', 1215, 4, '2024-11-14 19:14:28.021815', 162, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.023902', 1216, 4, '2024-11-14 19:14:28.023902', 162, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:27:19.005739', 1292, 4, '2024-11-15 19:27:19.005739', 181, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:27:19.007896', 1293, 4, '2024-11-15 19:27:19.007896', 181, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:30:46.151526', 1294, 4, '2024-11-15 19:30:46.151526', 182, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.025102', 1217, 4, '2024-11-14 19:14:28.025102', 162, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.026639', 1218, 4, '2024-11-14 19:14:28.026639', 162, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.028063', 1219, 4, '2024-11-14 19:14:28.028063', 162, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.029346', 1220, 4, '2024-11-14 19:14:28.029346', 162, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.030601', 1221, 4, '2024-11-14 19:14:28.030601', 162, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.032139', 1222, 4, '2024-11-14 19:14:28.032139', 162, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.0335', 1223, 4, '2024-11-14 19:14:28.0335', 162, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:14:28.034906', 1224, 4, '2024-11-14 19:14:28.034906', 162, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:16:25.745426', 1225, 4, '2024-11-14 19:16:25.745426', 164, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:16:25.747099', 1226, 4, '2024-11-14 19:16:25.747099', 164, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:17:39.605403', 1227, 4, '2024-11-14 19:17:39.605403', 165, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:17:39.606658', 1228, 4, '2024-11-14 19:17:39.606658', 165, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.620898', 1232, 4, '2024-11-14 19:33:13.620898', 166, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.622263', 1233, 4, '2024-11-14 19:33:13.622263', 166, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.623708', 1234, 4, '2024-11-14 19:33:13.623708', 166, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.625186', 1235, 4, '2024-11-14 19:33:13.625186', 166, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.626376', 1236, 4, '2024-11-14 19:33:13.626376', 166, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.627479', 1237, 4, '2024-11-14 19:33:13.627479', 166, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.628575', 1238, 4, '2024-11-14 19:33:13.628575', 166, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:30:46.155645', 1295, 4, '2024-11-15 19:30:46.155645', 182, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.131899', 440, 4, '2024-11-13 10:36:50.131899', 63, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.422793', 919, 4, '2024-11-13 13:34:21.422793', 109, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.133765', 441, 4, '2024-11-13 10:36:50.133765', 63, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.135489', 442, 4, '2024-11-13 10:36:50.135489', 63, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.137248', 443, 4, '2024-11-13 10:36:50.137248', 63, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.13881', 444, 4, '2024-11-13 10:36:50.13881', 63, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.140381', 445, 4, '2024-11-13 10:36:50.140381', 63, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.142042', 446, 4, '2024-11-13 10:36:50.142042', 63, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.143538', 447, 4, '2024-11-13 10:36:50.143538', 63, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.423974', 920, 4, '2024-11-13 13:34:21.423974', 109, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.146276', 449, 4, '2024-11-13 10:36:50.146276', 63, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.148909', 450, 2, '2024-11-13 10:36:50.148909', 63, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:36:50.150243', 451, 2, '2024-11-13 10:36:50.150243', 63, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.453748', 452, 4, '2024-11-13 10:38:02.453748', 64, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.455425', 453, 4, '2024-11-13 10:38:02.455425', 64, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.456982', 454, 4, '2024-11-13 10:38:02.456982', 64, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.458635', 455, 4, '2024-11-13 10:38:02.458635', 64, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.459943', 456, 4, '2024-11-13 10:38:02.459943', 64, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.461252', 457, 4, '2024-11-13 10:38:02.461252', 64, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.46254', 458, 4, '2024-11-13 10:38:02.46254', 64, 'private GitlabProjectResponse createGitlabProjectResponse(
            GitlabProjectSimpleContent content, Long gitlabAccountId) {
        return projectRepository
                .findByGitlabProjectId(GraphQlUtil.extractIdFromId(content.id()))
                .map(
                        project -> {
                            boolean isLinked = isProjectLinked(gitlabAccountId, project.getId());
                            return GitlabProjectResponse.ofLinkable(content, isLinked);
                        })
                .orElseGet(() -> GitlabProjectResponse.ofNonLinkable(content));
    }', 'GitlabApiService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.463761', 459, 4, '2024-11-13 10:38:02.463761', 64, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:02.466561', 461, 4, '2024-11-13 10:38:02.466561', 64, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.927025', 462, 4, '2024-11-13 10:38:45.927025', 65, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.928708', 463, 4, '2024-11-13 10:38:45.928708', 65, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.929987', 464, 4, '2024-11-13 10:38:45.929987', 65, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.931508', 465, 4, '2024-11-13 10:38:45.931508', 65, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.93276', 466, 4, '2024-11-13 10:38:45.93276', 65, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.130466', 503, 4, '2024-11-13 10:49:23.130466', 68, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.933857', 467, 4, '2024-11-13 10:38:45.933857', 65, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.934979', 468, 4, '2024-11-13 10:38:45.934979', 65, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.936038', 469, 4, '2024-11-13 10:38:45.936038', 65, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.937091', 470, 4, '2024-11-13 10:38:45.937091', 65, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.938599', 471, 4, '2024-11-13 10:38:45.938599', 65, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.939674', 472, 2, '2024-11-13 10:38:45.939674', 65, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:38:45.940874', 473, 2, '2024-11-13 10:38:45.940874', 65, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.248313', 474, 4, '2024-11-13 10:44:37.248313', 66, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.249721', 475, 4, '2024-11-13 10:44:37.249721', 66, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.007872', 938, 2, '2024-11-13 13:45:45.007872', 112, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.251008', 476, 4, '2024-11-13 10:44:37.251008', 66, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.252447', 477, 4, '2024-11-13 10:44:37.252447', 66, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.25369', 478, 4, '2024-11-13 10:44:37.25369', 66, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.254933', 479, 4, '2024-11-13 10:44:37.254933', 66, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.255944', 480, 4, '2024-11-13 10:44:37.255944', 66, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.257132', 481, 4, '2024-11-13 10:44:37.257132', 66, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.258229', 482, 4, '2024-11-13 10:44:37.258229', 66, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.259227', 483, 4, '2024-11-13 10:44:37.259227', 66, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:44:37.260201', 484, 2, '2024-11-13 10:44:37.260201', 66, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.181418', 487, 4, '2024-11-13 10:45:39.181418', 67, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.183155', 488, 4, '2024-11-13 10:45:39.183155', 67, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.184473', 489, 4, '2024-11-13 10:45:39.184473', 67, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.185531', 490, 4, '2024-11-13 10:45:39.185531', 67, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.186678', 491, 4, '2024-11-13 10:45:39.186678', 67, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.187728', 492, 4, '2024-11-13 10:45:39.187728', 67, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.188687', 493, 4, '2024-11-13 10:45:39.188687', 67, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.010003', 939, 4, '2024-11-13 13:45:45.010003', 112, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.189615', 494, 4, '2024-11-13 10:45:39.189615', 67, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.190686', 495, 4, '2024-11-13 10:45:39.190686', 67, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.191647', 496, 4, '2024-11-13 10:45:39.191647', 67, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.192608', 497, 2, '2024-11-13 10:45:39.192608', 67, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.196237', 498, 2, '2024-11-13 10:45:39.196237', 67, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:45:39.197142', 499, 2, '2024-11-13 10:45:39.197142', 67, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.126931', 500, 4, '2024-11-13 10:49:23.126931', 68, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.128246', 501, 4, '2024-11-13 10:49:23.128246', 68, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.129257', 502, 4, '2024-11-13 10:49:23.129257', 68, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.011549', 940, 4, '2024-11-13 13:45:45.011549', 112, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.132742', 505, 4, '2024-11-13 10:49:23.132742', 68, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.133878', 506, 4, '2024-11-13 10:49:23.133878', 68, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.13484', 507, 4, '2024-11-13 10:49:23.13484', 68, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.135954', 508, 4, '2024-11-13 10:49:23.135954', 68, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.13705', 509, 4, '2024-11-13 10:49:23.13705', 68, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.13811', 510, 2, '2024-11-13 10:49:23.13811', 68, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.139004', 511, 2, '2024-11-13 10:49:23.139004', 68, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:49:23.139952', 512, 2, '2024-11-13 10:49:23.139952', 68, '// JavaScript
console.log("Hello, World!");
', 'asdasdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.915823', 513, 4, '2024-11-13 10:50:45.915823', 69, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.917358', 514, 4, '2024-11-13 10:50:45.917358', 69, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.918706', 515, 4, '2024-11-13 10:50:45.918706', 69, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.01295', 941, 4, '2024-11-13 13:45:45.01295', 112, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.920045', 516, 4, '2024-11-13 10:50:45.920045', 69, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.921175', 517, 4, '2024-11-13 10:50:45.921175', 69, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.922439', 518, 4, '2024-11-13 10:50:45.922439', 69, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.923496', 519, 4, '2024-11-13 10:50:45.923496', 69, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.924808', 520, 4, '2024-11-13 10:50:45.924808', 69, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.925957', 521, 4, '2024-11-13 10:50:45.925957', 69, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:50:45.926916', 522, 4, '2024-11-13 10:50:45.926916', 69, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.611143', 527, 4, '2024-11-13 10:53:42.611143', 70, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.612626', 528, 4, '2024-11-13 10:53:42.612626', 70, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.613681', 529, 4, '2024-11-13 10:53:42.613681', 70, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.61468', 530, 4, '2024-11-13 10:53:42.61468', 70, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.615659', 531, 4, '2024-11-13 10:53:42.615659', 70, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.616797', 532, 4, '2024-11-13 10:53:42.616797', 70, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.618419', 533, 4, '2024-11-13 10:53:42.618419', 70, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.014231', 942, 4, '2024-11-13 13:45:45.014231', 112, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.872478', 1369, 4, '2024-11-17 18:10:42.872478', 195, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.619975', 534, 4, '2024-11-13 10:53:42.619975', 70, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.6211', 535, 4, '2024-11-13 10:53:42.6211', 70, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.622326', 536, 4, '2024-11-13 10:53:42.622326', 70, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.623313', 537, 2, '2024-11-13 10:53:42.623313', 70, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.624247', 538, 2, '2024-11-13 10:53:42.624247', 70, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.625151', 539, 2, '2024-11-13 10:53:42.625151', 70, '// JavaScript
console.log("Hello, World!");
', 'asdasdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:53:42.626077', 540, 2, '2024-11-13 10:53:42.626077', 70, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.011521', 541, 4, '2024-11-13 10:54:07.011521', 71, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.013676', 542, 4, '2024-11-13 10:54:07.013676', 71, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.014866', 543, 4, '2024-11-13 10:54:07.014866', 71, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.01619', 544, 4, '2024-11-13 10:54:07.01619', 71, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.017295', 545, 4, '2024-11-13 10:54:07.017295', 71, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.824412', 655, 4, '2024-11-13 12:09:44.824412', 81, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.018424', 546, 4, '2024-11-13 10:54:07.018424', 71, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.019589', 547, 4, '2024-11-13 10:54:07.019589', 71, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.020575', 548, 4, '2024-11-13 10:54:07.020575', 71, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.021492', 549, 4, '2024-11-13 10:54:07.021492', 71, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:07.022371', 550, 4, '2024-11-13 10:54:07.022371', 71, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.031188', 551, 4, '2024-11-13 10:54:55.031188', 72, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.032993', 552, 4, '2024-11-13 10:54:55.032993', 72, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.034155', 553, 4, '2024-11-13 10:54:55.034155', 72, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.035231', 554, 4, '2024-11-13 10:54:55.035231', 72, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.439443', 960, 2, '2024-11-13 13:49:10.439443', 115, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.441262', 961, 4, '2024-11-13 13:49:10.441262', 115, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.03635', 555, 4, '2024-11-13 10:54:55.03635', 72, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.037619', 556, 4, '2024-11-13 10:54:55.037619', 72, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.038864', 557, 4, '2024-11-13 10:54:55.038864', 72, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.039934', 558, 4, '2024-11-13 10:54:55.039934', 72, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.040846', 559, 16, '2024-11-13 10:54:55.040846', 72, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.042085', 560, 2, '2024-11-13 10:54:55.042085', 72, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:54:55.042944', 561, 2, '2024-11-13 10:54:55.042944', 72, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.774402', 562, 4, '2024-11-13 10:57:04.774402', 73, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.77561', 563, 4, '2024-11-13 10:57:04.77561', 73, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.776652', 564, 4, '2024-11-13 10:57:04.776652', 73, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.777712', 565, 4, '2024-11-13 10:57:04.777712', 73, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.442736', 962, 4, '2024-11-13 13:49:10.442736', 115, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.77878', 566, 4, '2024-11-13 10:57:04.77878', 73, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.779791', 567, 4, '2024-11-13 10:57:04.779791', 73, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.780743', 568, 4, '2024-11-13 10:57:04.780743', 73, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.781606', 569, 4, '2024-11-13 10:57:04.781606', 73, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.782495', 570, 4, '2024-11-13 10:57:04.782495', 73, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.783399', 571, 4, '2024-11-13 10:57:04.783399', 73, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.784334', 572, 2, '2024-11-13 10:57:04.784334', 73, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:57:04.785489', 573, 2, '2024-11-13 10:57:04.785489', 73, '// JavaScript
console.log("Hello, World!");
', 'asdasdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.808749', 574, 4, '2024-11-13 10:59:44.808749', 74, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.425199', 622, 4, '2024-11-13 11:06:07.425199', 78, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.810064', 575, 4, '2024-11-13 10:59:44.810064', 74, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.811276', 576, 4, '2024-11-13 10:59:44.811276', 74, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.812423', 577, 4, '2024-11-13 10:59:44.812423', 74, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.81363', 578, 4, '2024-11-13 10:59:44.81363', 74, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.814578', 579, 4, '2024-11-13 10:59:44.814578', 74, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.81557', 580, 4, '2024-11-13 10:59:44.81557', 74, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.816623', 581, 4, '2024-11-13 10:59:44.816623', 74, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.817538', 582, 16, '2024-11-13 10:59:44.817538', 74, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.818401', 583, 2, '2024-11-13 10:59:44.818401', 74, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 10:59:44.819259', 584, 2, '2024-11-13 10:59:44.819259', 74, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.651254', 585, 4, '2024-11-13 11:00:52.651254', 75, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.42657', 623, 4, '2024-11-13 11:06:07.42657', 78, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.652995', 586, 4, '2024-11-13 11:00:52.652995', 75, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.654002', 587, 4, '2024-11-13 11:00:52.654002', 75, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.655489', 588, 4, '2024-11-13 11:00:52.655489', 75, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.656438', 589, 4, '2024-11-13 11:00:52.656438', 75, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.657348', 590, 4, '2024-11-13 11:00:52.657348', 75, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.658339', 591, 4, '2024-11-13 11:00:52.658339', 75, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.659298', 592, 4, '2024-11-13 11:00:52.659298', 75, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.660192', 593, 16, '2024-11-13 11:00:52.660192', 75, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.661145', 594, 2, '2024-11-13 11:00:52.661145', 75, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.661989', 595, 2, '2024-11-13 11:00:52.661989', 75, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:00:52.662843', 596, 2, '2024-11-13 11:00:52.662843', 75, '// JavaScript
console.log("Hello, World!");
', 'asdas');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.030985', 597, 4, '2024-11-13 11:03:14.030985', 76, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.427786', 624, 4, '2024-11-13 11:06:07.427786', 78, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.443844', 963, 4, '2024-11-13 13:49:10.443844', 115, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.036967', 598, 4, '2024-11-13 11:03:14.036967', 76, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.038951', 599, 4, '2024-11-13 11:03:14.038951', 76, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.040728', 600, 4, '2024-11-13 11:03:14.040728', 76, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.042863', 601, 4, '2024-11-13 11:03:14.042863', 76, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.045497', 602, 4, '2024-11-13 11:03:14.045497', 76, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.047394', 603, 4, '2024-11-13 11:03:14.047394', 76, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.049145', 604, 4, '2024-11-13 11:03:14.049145', 76, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.050651', 605, 16, '2024-11-13 11:03:14.050651', 76, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.052276', 606, 2, '2024-11-13 11:03:14.052276', 76, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.054439', 607, 2, '2024-11-13 11:03:14.054439', 76, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:14.055925', 608, 2, '2024-11-13 11:03:14.055925', 76, '// JavaScript
console.log("Hello, World!");
', 'asdsada');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.724658', 609, 4, '2024-11-13 11:03:57.724658', 77, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.428968', 625, 4, '2024-11-13 11:06:07.428968', 78, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.445045', 964, 4, '2024-11-13 13:49:10.445045', 115, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.043202', 1370, 4, '2024-11-17 18:10:43.043202', 196, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.726437', 610, 4, '2024-11-13 11:03:57.726437', 77, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.728056', 611, 4, '2024-11-13 11:03:57.728056', 77, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.729618', 612, 4, '2024-11-13 11:03:57.729618', 77, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.731121', 613, 4, '2024-11-13 11:03:57.731121', 77, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.732622', 614, 4, '2024-11-13 11:03:57.732622', 77, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.734228', 615, 4, '2024-11-13 11:03:57.734228', 77, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.735527', 616, 4, '2024-11-13 11:03:57.735527', 77, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.736974', 617, 16, '2024-11-13 11:03:57.736974', 77, '/* CSS */
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: sans-serif;
}

h1 {
    color: #333;
    font-size: 2em;
}
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.738341', 618, 2, '2024-11-13 11:03:57.738341', 77, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㄴㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.739686', 619, 2, '2024-11-13 11:03:57.739686', 77, '// JavaScript
console.log("Hello, World!");
', 'asdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:03:57.741009', 620, 2, '2024-11-13 11:03:57.741009', 77, '// JavaScript
console.log("Hello, World!");
', 'asdsadasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.423448', 621, 4, '2024-11-13 11:06:07.423448', 78, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.066332', 982, 2, '2024-11-13 13:52:22.066332', 117, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.068113', 983, 4, '2024-11-13 13:52:22.068113', 117, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.430286', 626, 4, '2024-11-13 11:06:07.430286', 78, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.431609', 627, 4, '2024-11-13 11:06:07.431609', 78, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.432883', 628, 4, '2024-11-13 11:06:07.432883', 78, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.434639', 629, 4, '2024-11-13 11:06:07.434639', 78, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:06:07.435769', 630, 4, '2024-11-13 11:06:07.435769', 78, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.936842', 631, 4, '2024-11-13 11:17:28.936842', 79, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.938141', 632, 4, '2024-11-13 11:17:28.938141', 79, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.939219', 633, 4, '2024-11-13 11:17:28.939219', 79, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.940235', 634, 4, '2024-11-13 11:17:28.940235', 79, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.35503', 644, 4, '2024-11-13 11:20:35.35503', 80, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.941568', 635, 4, '2024-11-13 11:17:28.941568', 79, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.942953', 636, 4, '2024-11-13 11:17:28.942953', 79, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.944109', 637, 4, '2024-11-13 11:17:28.944109', 79, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.945197', 638, 4, '2024-11-13 11:17:28.945197', 79, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.946278', 639, 4, '2024-11-13 11:17:28.946278', 79, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:17:28.947355', 640, 4, '2024-11-13 11:17:28.947355', 79, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.351179', 641, 4, '2024-11-13 11:20:35.351179', 80, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.352677', 642, 4, '2024-11-13 11:20:35.352677', 80, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.353919', 643, 4, '2024-11-13 11:20:35.353919', 80, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.069184', 984, 4, '2024-11-13 13:52:22.069184', 117, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.04523', 1371, 4, '2024-11-17 18:10:43.04523', 196, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.778632', 1374, 4, '2024-11-17 18:10:43.778632', 198, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.3562', 645, 4, '2024-11-13 11:20:35.3562', 80, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.357451', 646, 4, '2024-11-13 11:20:35.357451', 80, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.358631', 647, 4, '2024-11-13 11:20:35.358631', 80, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.359763', 648, 4, '2024-11-13 11:20:35.359763', 80, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.360923', 649, 4, '2024-11-13 11:20:35.360923', 80, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.361992', 650, 4, '2024-11-13 11:20:35.361992', 80, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 11:20:35.362982', 651, 2, '2024-11-13 11:20:35.362982', 80, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.816759', 652, 4, '2024-11-13 12:09:44.816759', 81, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.81937', 653, 4, '2024-11-13 12:09:44.81937', 81, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.822314', 654, 4, '2024-11-13 12:09:44.822314', 81, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.181054', 1372, 4, '2024-11-17 18:10:43.181054', 197, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.826063', 656, 4, '2024-11-13 12:09:44.826063', 81, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.828139', 657, 4, '2024-11-13 12:09:44.828139', 81, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.829959', 658, 4, '2024-11-13 12:09:44.829959', 81, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.831098', 659, 4, '2024-11-13 12:09:44.831098', 81, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.832611', 660, 4, '2024-11-13 12:09:44.832611', 81, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.834344', 661, 4, '2024-11-13 12:09:44.834344', 81, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:09:44.83608', 662, 2, '2024-11-13 12:09:44.83608', 81, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.75141', 663, 4, '2024-11-13 12:10:40.75141', 82, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.752928', 664, 4, '2024-11-13 12:10:40.752928', 82, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.754082', 665, 4, '2024-11-13 12:10:40.754082', 82, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.73104', 686, 4, '2024-11-13 12:12:39.73104', 84, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.755235', 666, 4, '2024-11-13 12:10:40.755235', 82, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.756473', 667, 4, '2024-11-13 12:10:40.756473', 82, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.758017', 668, 4, '2024-11-13 12:10:40.758017', 82, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.759303', 669, 4, '2024-11-13 12:10:40.759303', 82, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.760717', 670, 4, '2024-11-13 12:10:40.760717', 82, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.761922', 671, 4, '2024-11-13 12:10:40.761922', 82, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.763597', 672, 4, '2024-11-13 12:10:40.763597', 82, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:10:40.764703', 673, 2, '2024-11-13 12:10:40.764703', 82, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.693473', 674, 4, '2024-11-13 12:11:54.693473', 83, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.695015', 675, 4, '2024-11-13 12:11:54.695015', 83, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.07024', 985, 4, '2024-11-13 13:52:22.07024', 117, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.071426', 986, 4, '2024-11-13 13:52:22.071426', 117, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.696239', 676, 4, '2024-11-13 12:11:54.696239', 83, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.697577', 677, 4, '2024-11-13 12:11:54.697577', 83, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.698953', 678, 4, '2024-11-13 12:11:54.698953', 83, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.700345', 679, 4, '2024-11-13 12:11:54.700345', 83, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.701566', 680, 4, '2024-11-13 12:11:54.701566', 83, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.702878', 681, 4, '2024-11-13 12:11:54.702878', 83, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.704077', 682, 4, '2024-11-13 12:11:54.704077', 83, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.705273', 683, 4, '2024-11-13 12:11:54.705273', 83, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:11:54.706352', 684, 2, '2024-11-13 12:11:54.706352', 83, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.729637', 685, 4, '2024-11-13 12:12:39.729637', 84, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.257995', 1004, 2, '2024-11-13 13:58:10.257995', 119, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.732424', 687, 4, '2024-11-13 12:12:39.732424', 84, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.733703', 688, 4, '2024-11-13 12:12:39.733703', 84, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.734847', 689, 4, '2024-11-13 12:12:39.734847', 84, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.736203', 690, 4, '2024-11-13 12:12:39.736203', 84, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.73748', 691, 4, '2024-11-13 12:12:39.73748', 84, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.738516', 692, 4, '2024-11-13 12:12:39.738516', 84, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.73954', 693, 4, '2024-11-13 12:12:39.73954', 84, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.74093', 694, 4, '2024-11-13 12:12:39.74093', 84, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:12:39.743901', 695, 2, '2024-11-13 12:12:39.743901', 84, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.791605', 696, 4, '2024-11-13 12:13:11.791605', 85, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.182846', 1373, 4, '2024-11-17 18:10:43.182846', 197, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.793321', 697, 4, '2024-11-13 12:13:11.793321', 85, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.794946', 698, 4, '2024-11-13 12:13:11.794946', 85, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.796198', 699, 4, '2024-11-13 12:13:11.796198', 85, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.797533', 700, 4, '2024-11-13 12:13:11.797533', 85, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.798624', 701, 4, '2024-11-13 12:13:11.798624', 85, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.799649', 702, 4, '2024-11-13 12:13:11.799649', 85, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.800732', 703, 4, '2024-11-13 12:13:11.800732', 85, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.801814', 704, 4, '2024-11-13 12:13:11.801814', 85, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.802937', 705, 4, '2024-11-13 12:13:11.802937', 85, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.804159', 706, 2, '2024-11-13 12:13:11.804159', 85, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:11.805136', 707, 2, '2024-11-13 12:13:11.805136', 85, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.296113', 708, 4, '2024-11-13 12:13:40.296113', 86, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.297727', 709, 4, '2024-11-13 12:13:40.297727', 86, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.299229', 710, 4, '2024-11-13 12:13:40.299229', 86, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.300445', 711, 4, '2024-11-13 12:13:40.300445', 86, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.30148', 712, 4, '2024-11-13 12:13:40.30148', 86, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.30324', 713, 4, '2024-11-13 12:13:40.30324', 86, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.305392', 714, 4, '2024-11-13 12:13:40.305392', 86, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.306455', 715, 4, '2024-11-13 12:13:40.306455', 86, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.307578', 716, 4, '2024-11-13 12:13:40.307578', 86, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.259486', 1005, 4, '2024-11-13 13:58:10.259486', 119, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.308675', 717, 4, '2024-11-13 12:13:40.308675', 86, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.309875', 718, 2, '2024-11-13 12:13:40.309875', 86, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:13:40.3109', 719, 2, '2024-11-13 12:13:40.3109', 86, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.399276', 720, 4, '2024-11-13 12:22:22.399276', 87, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.400694', 721, 4, '2024-11-13 12:22:22.400694', 87, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.401765', 722, 4, '2024-11-13 12:22:22.401765', 87, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.402743', 723, 4, '2024-11-13 12:22:22.402743', 87, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.40394', 724, 4, '2024-11-13 12:22:22.40394', 87, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.405698', 725, 4, '2024-11-13 12:22:22.405698', 87, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.406975', 726, 4, '2024-11-13 12:22:22.406975', 87, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.47664', 737, 4, '2024-11-13 12:26:18.47664', 88, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.47765', 738, 4, '2024-11-13 12:26:18.47765', 88, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.408278', 727, 4, '2024-11-13 12:22:22.408278', 87, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.409514', 728, 4, '2024-11-13 12:22:22.409514', 87, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.4106', 729, 4, '2024-11-13 12:22:22.4106', 87, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.411834', 730, 2, '2024-11-13 12:22:22.411834', 87, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:22:22.41299', 731, 2, '2024-11-13 12:22:22.41299', 87, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.470744', 732, 4, '2024-11-13 12:26:18.470744', 88, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.47232', 733, 4, '2024-11-13 12:26:18.47232', 88, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.473399', 734, 4, '2024-11-13 12:26:18.473399', 88, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.474448', 735, 4, '2024-11-13 12:26:18.474448', 88, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.475495', 736, 4, '2024-11-13 12:26:18.475495', 88, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.946512', 751, 4, '2024-11-13 12:28:28.946512', 89, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.478661', 739, 4, '2024-11-13 12:26:18.478661', 88, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.479805', 740, 4, '2024-11-13 12:26:18.479805', 88, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.480876', 741, 4, '2024-11-13 12:26:18.480876', 88, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.481957', 742, 2, '2024-11-13 12:26:18.481957', 88, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.483015', 743, 2, '2024-11-13 12:26:18.483015', 88, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:26:18.484037', 744, 2, '2024-11-13 12:26:18.484037', 88, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.940542', 745, 4, '2024-11-13 12:28:28.940542', 89, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.941855', 746, 4, '2024-11-13 12:28:28.941855', 89, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.942795', 747, 4, '2024-11-13 12:28:28.942795', 89, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.943727', 748, 4, '2024-11-13 12:28:28.943727', 89, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.94471', 749, 4, '2024-11-13 12:28:28.94471', 89, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.945617', 750, 4, '2024-11-13 12:28:28.945617', 89, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.521041', 795, 2, '2024-11-13 12:33:38.521041', 92, '// JavaScript
console.log("Hello, World!");
', 'asdasda');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.521969', 796, 2, '2024-11-13 12:33:38.521969', 92, '// JavaScript
console.log("Hello, World!");
', 'asdasdasd');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.947535', 752, 4, '2024-11-13 12:28:28.947535', 89, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.948838', 753, 4, '2024-11-13 12:28:28.948838', 89, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.949963', 754, 4, '2024-11-13 12:28:28.949963', 89, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.951288', 755, 2, '2024-11-13 12:28:28.951288', 89, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.952438', 756, 2, '2024-11-13 12:28:28.952438', 89, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.95356', 757, 2, '2024-11-13 12:28:28.95356', 89, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:28.954696', 758, 2, '2024-11-13 12:28:28.954696', 89, '// JavaScript
console.log("Hello, World!");
', 'ㄴㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.209208', 759, 4, '2024-11-13 12:28:43.209208', 90, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.210648', 760, 4, '2024-11-13 12:28:43.210648', 90, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.211684', 761, 4, '2024-11-13 12:28:43.211684', 90, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.212747', 762, 4, '2024-11-13 12:28:43.212747', 90, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.213806', 763, 4, '2024-11-13 12:28:43.213806', 90, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.214814', 764, 4, '2024-11-13 12:28:43.214814', 90, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.215734', 765, 4, '2024-11-13 12:28:43.215734', 90, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.216937', 766, 4, '2024-11-13 12:28:43.216937', 90, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.218145', 767, 4, '2024-11-13 12:28:43.218145', 90, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.219225', 768, 4, '2024-11-13 12:28:43.219225', 90, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.22037', 769, 2, '2024-11-13 12:28:43.22037', 90, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.221537', 770, 2, '2024-11-13 12:28:43.221537', 90, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:28:43.222552', 771, 2, '2024-11-13 12:28:43.222552', 90, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.104547', 772, 4, '2024-11-13 12:32:15.104547', 91, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.106311', 773, 4, '2024-11-13 12:32:15.106311', 91, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.107486', 774, 4, '2024-11-13 12:32:15.107486', 91, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.108813', 775, 4, '2024-11-13 12:32:15.108813', 91, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.109927', 776, 4, '2024-11-13 12:32:15.109927', 91, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.522857', 797, 2, '2024-11-13 12:33:38.522857', 92, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.260548', 1006, 4, '2024-11-13 13:58:10.260548', 119, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.111129', 777, 4, '2024-11-13 12:32:15.111129', 91, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.112321', 778, 4, '2024-11-13 12:32:15.112321', 91, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.113402', 779, 4, '2024-11-13 12:32:15.113402', 91, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.11447', 780, 4, '2024-11-13 12:32:15.11447', 91, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.115459', 781, 4, '2024-11-13 12:32:15.115459', 91, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.116573', 782, 2, '2024-11-13 12:32:15.116573', 91, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.117561', 783, 2, '2024-11-13 12:32:15.117561', 91, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:32:15.118578', 784, 2, '2024-11-13 12:32:15.118578', 91, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.509211', 785, 4, '2024-11-13 12:33:38.509211', 92, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.511391', 786, 4, '2024-11-13 12:33:38.511391', 92, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.512488', 787, 4, '2024-11-13 12:33:38.512488', 92, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.26156', 1007, 4, '2024-11-13 13:58:10.26156', 119, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.513387', 788, 4, '2024-11-13 12:33:38.513387', 92, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.514849', 789, 4, '2024-11-13 12:33:38.514849', 92, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.516054', 790, 4, '2024-11-13 12:33:38.516054', 92, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.517073', 791, 4, '2024-11-13 12:33:38.517073', 92, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.518153', 792, 4, '2024-11-13 12:33:38.518153', 92, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.519096', 793, 4, '2024-11-13 12:33:38.519096', 92, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:33:38.520072', 794, 4, '2024-11-13 12:33:38.520072', 92, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:35:27.590478', 798, 4, '2024-11-13 12:35:27.590478', 93, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:35:27.592051', 799, 4, '2024-11-13 12:35:27.592051', 93, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:40:19.491103', 800, 2, '2024-11-13 12:40:19.491103', 94, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:44:46.669897', 801, 2, '2024-11-13 12:44:46.669897', 95, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:44:46.670935', 802, 2, '2024-11-13 12:44:46.670935', 95, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:45:54.743462', 803, 2, '2024-11-13 12:45:54.743462', 96, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:45:54.744508', 804, 2, '2024-11-13 12:45:54.744508', 96, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:57:14.390696', 805, 2, '2024-11-13 12:57:14.390696', 97, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:57:14.39211', 806, 2, '2024-11-13 12:57:14.39211', 97, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:57:38.99977', 807, 2, '2024-11-13 12:57:38.99977', 98, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㅇㄴㅁㅇㄴㅁㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 12:57:39.0017', 808, 2, '2024-11-13 12:57:39.0017', 98, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㄴㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.512551', 809, 4, '2024-11-13 13:00:39.512551', 99, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.514568', 810, 4, '2024-11-13 13:00:39.514568', 99, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.515767', 811, 4, '2024-11-13 13:00:39.515767', 99, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.516908', 812, 4, '2024-11-13 13:00:39.516908', 99, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.518125', 813, 4, '2024-11-13 13:00:39.518125', 99, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.519358', 814, 4, '2024-11-13 13:00:39.519358', 99, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.520504', 815, 4, '2024-11-13 13:00:39.520504', 99, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.521532', 816, 4, '2024-11-13 13:00:39.521532', 99, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.220084', 850, 4, '2024-11-13 13:12:36.220084', 103, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.522683', 817, 4, '2024-11-13 13:00:39.522683', 99, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:00:39.524049', 818, 4, '2024-11-13 13:00:39.524049', 99, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.473039', 819, 4, '2024-11-13 13:05:16.473039', 100, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.478609', 820, 4, '2024-11-13 13:05:16.478609', 100, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.480309', 821, 4, '2024-11-13 13:05:16.480309', 100, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.481939', 822, 4, '2024-11-13 13:05:16.481939', 100, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.483578', 823, 4, '2024-11-13 13:05:16.483578', 100, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.485835', 824, 4, '2024-11-13 13:05:16.485835', 100, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.487508', 825, 4, '2024-11-13 13:05:16.487508', 100, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.488964', 826, 4, '2024-11-13 13:05:16.488964', 100, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.490327', 827, 4, '2024-11-13 13:05:16.490327', 100, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:05:16.491778', 828, 4, '2024-11-13 13:05:16.491778', 100, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.596397', 829, 4, '2024-11-13 13:07:05.596397', 101, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.598309', 830, 4, '2024-11-13 13:07:05.598309', 101, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.599764', 831, 4, '2024-11-13 13:07:05.599764', 101, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.601289', 832, 4, '2024-11-13 13:07:05.601289', 101, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.222065', 851, 4, '2024-11-13 13:12:36.222065', 103, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.223399', 852, 4, '2024-11-13 13:12:36.223399', 103, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.224677', 853, 4, '2024-11-13 13:12:36.224677', 103, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.602644', 833, 4, '2024-11-13 13:07:05.602644', 101, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.604226', 834, 4, '2024-11-13 13:07:05.604226', 101, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.605578', 835, 4, '2024-11-13 13:07:05.605578', 101, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.606849', 836, 4, '2024-11-13 13:07:05.606849', 101, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.608274', 837, 4, '2024-11-13 13:07:05.608274', 101, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:07:05.609734', 838, 4, '2024-11-13 13:07:05.609734', 101, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.159897', 839, 4, '2024-11-13 13:10:41.159897', 102, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.161473', 840, 4, '2024-11-13 13:10:41.161473', 102, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.162602', 841, 4, '2024-11-13 13:10:41.162602', 102, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.164112', 842, 4, '2024-11-13 13:10:41.164112', 102, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.165559', 843, 4, '2024-11-13 13:10:41.165559', 102, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.166815', 844, 4, '2024-11-13 13:10:41.166815', 102, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.168052', 845, 4, '2024-11-13 13:10:41.168052', 102, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.169221', 846, 4, '2024-11-13 13:10:41.169221', 102, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.17039', 847, 4, '2024-11-13 13:10:41.17039', 102, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.171674', 848, 4, '2024-11-13 13:10:41.171674', 102, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:10:41.172792', 849, 2, '2024-11-13 13:10:41.172792', 102, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.225952', 854, 4, '2024-11-13 13:12:36.225952', 103, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.227361', 855, 4, '2024-11-13 13:12:36.227361', 103, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.228507', 856, 4, '2024-11-13 13:12:36.228507', 103, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.229688', 857, 4, '2024-11-13 13:12:36.229688', 103, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.230943', 858, 4, '2024-11-13 13:12:36.230943', 103, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.232282', 859, 4, '2024-11-13 13:12:36.232282', 103, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:12:36.233466', 860, 2, '2024-11-13 13:12:36.233466', 103, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.189606', 861, 4, '2024-11-13 13:18:51.189606', 104, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.191048', 862, 4, '2024-11-13 13:18:51.191048', 104, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.19261', 863, 4, '2024-11-13 13:18:51.19261', 104, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.193757', 864, 4, '2024-11-13 13:18:51.193757', 104, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.194812', 865, 4, '2024-11-13 13:18:51.194812', 104, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.195887', 866, 4, '2024-11-13 13:18:51.195887', 104, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.197049', 867, 4, '2024-11-13 13:18:51.197049', 104, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.198131', 868, 4, '2024-11-13 13:18:51.198131', 104, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.199255', 869, 4, '2024-11-13 13:18:51.199255', 104, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:18:51.200615', 870, 4, '2024-11-13 13:18:51.200615', 104, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.370675', 877, 4, '2024-11-13 13:22:02.370675', 105, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.372037', 878, 4, '2024-11-13 13:22:02.372037', 105, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.373231', 879, 4, '2024-11-13 13:22:02.373231', 105, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.374681', 880, 4, '2024-11-13 13:22:02.374681', 105, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.375956', 881, 4, '2024-11-13 13:22:02.375956', 105, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:22:02.377467', 882, 4, '2024-11-13 13:22:02.377467', 105, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.952515', 883, 2, '2024-11-13 13:23:01.952515', 106, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.954107', 884, 4, '2024-11-13 13:23:01.954107', 106, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.955524', 885, 4, '2024-11-13 13:23:01.955524', 106, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.956779', 886, 4, '2024-11-13 13:23:01.956779', 106, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.957853', 887, 4, '2024-11-13 13:23:01.957853', 106, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.958957', 888, 4, '2024-11-13 13:23:01.958957', 106, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.959966', 889, 4, '2024-11-13 13:23:01.959966', 106, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.961024', 890, 4, '2024-11-13 13:23:01.961024', 106, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.962021', 891, 4, '2024-11-13 13:23:01.962021', 106, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.963063', 892, 4, '2024-11-13 13:23:01.963063', 106, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:23:01.964219', 893, 4, '2024-11-13 13:23:01.964219', 106, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.276558', 899, 4, '2024-11-13 13:30:26.276558', 107, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.277886', 900, 4, '2024-11-13 13:30:26.277886', 107, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.279152', 901, 4, '2024-11-13 13:30:26.279152', 107, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.280261', 902, 4, '2024-11-13 13:30:26.280261', 107, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.281348', 903, 4, '2024-11-13 13:30:26.281348', 107, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:30:26.282559', 904, 4, '2024-11-13 13:30:26.282559', 107, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.280451', 905, 2, '2024-11-13 13:33:20.280451', 108, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.281831', 906, 4, '2024-11-13 13:33:20.281831', 108, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.282919', 907, 4, '2024-11-13 13:33:20.282919', 108, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.283905', 908, 4, '2024-11-13 13:33:20.283905', 108, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.285016', 909, 4, '2024-11-13 13:33:20.285016', 108, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.286058', 910, 4, '2024-11-13 13:33:20.286058', 108, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.287153', 911, 4, '2024-11-13 13:33:20.287153', 108, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.288284', 912, 4, '2024-11-13 13:33:20.288284', 108, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.289554', 913, 4, '2024-11-13 13:33:20.289554', 108, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.290709', 914, 4, '2024-11-13 13:33:20.290709', 108, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:33:20.291822', 915, 4, '2024-11-13 13:33:20.291822', 108, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.425242', 921, 4, '2024-11-13 13:34:21.425242', 109, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.426417', 922, 4, '2024-11-13 13:34:21.426417', 109, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.427766', 923, 4, '2024-11-13 13:34:21.427766', 109, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.428888', 924, 4, '2024-11-13 13:34:21.428888', 109, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.430082', 925, 4, '2024-11-13 13:34:21.430082', 109, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:21.43128', 926, 4, '2024-11-13 13:34:21.43128', 109, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.136962', 927, 2, '2024-11-13 13:34:36.136962', 110, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.138964', 928, 4, '2024-11-13 13:34:36.138964', 110, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.140225', 929, 4, '2024-11-13 13:34:36.140225', 110, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.141593', 930, 4, '2024-11-13 13:34:36.141593', 110, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.143082', 931, 4, '2024-11-13 13:34:36.143082', 110, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.144552', 932, 4, '2024-11-13 13:34:36.144552', 110, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.145795', 933, 4, '2024-11-13 13:34:36.145795', 110, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.147392', 934, 4, '2024-11-13 13:34:36.147392', 110, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.149886', 935, 4, '2024-11-13 13:34:36.149886', 110, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.151015', 936, 4, '2024-11-13 13:34:36.151015', 110, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:34:36.15232', 937, 4, '2024-11-13 13:34:36.15232', 110, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.015583', 943, 4, '2024-11-13 13:45:45.015583', 112, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.016846', 944, 4, '2024-11-13 13:45:45.016846', 112, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.018013', 945, 4, '2024-11-13 13:45:45.018013', 112, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.01908', 946, 4, '2024-11-13 13:45:45.01908', 112, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.020679', 947, 4, '2024-11-13 13:45:45.020679', 112, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:45:45.021849', 948, 4, '2024-11-13 13:45:45.021849', 112, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.176675', 949, 2, '2024-11-13 13:47:33.176675', 113, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.178251', 950, 4, '2024-11-13 13:47:33.178251', 113, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.179293', 951, 4, '2024-11-13 13:47:33.179293', 113, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.180355', 952, 4, '2024-11-13 13:47:33.180355', 113, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.181455', 953, 4, '2024-11-13 13:47:33.181455', 113, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.182583', 954, 4, '2024-11-13 13:47:33.182583', 113, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.183683', 955, 4, '2024-11-13 13:47:33.183683', 113, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.184719', 956, 4, '2024-11-13 13:47:33.184719', 113, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.185758', 957, 4, '2024-11-13 13:47:33.185758', 113, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.186768', 958, 4, '2024-11-13 13:47:33.186768', 113, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:47:33.188016', 959, 4, '2024-11-13 13:47:33.188016', 113, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.446255', 965, 4, '2024-11-13 13:49:10.446255', 115, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.447492', 966, 4, '2024-11-13 13:49:10.447492', 115, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.448546', 967, 4, '2024-11-13 13:49:10.448546', 115, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.44958', 968, 4, '2024-11-13 13:49:10.44958', 115, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.450548', 969, 4, '2024-11-13 13:49:10.450548', 115, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:10.451727', 970, 4, '2024-11-13 13:49:10.451727', 115, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.607579', 971, 2, '2024-11-13 13:49:38.607579', 116, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.609206', 972, 4, '2024-11-13 13:49:38.609206', 116, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.610309', 973, 4, '2024-11-13 13:49:38.610309', 116, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.611756', 974, 4, '2024-11-13 13:49:38.611756', 116, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.612811', 975, 4, '2024-11-13 13:49:38.612811', 116, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.61377', 976, 4, '2024-11-13 13:49:38.61377', 116, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.614731', 977, 4, '2024-11-13 13:49:38.614731', 116, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.615695', 978, 4, '2024-11-13 13:49:38.615695', 116, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.616694', 979, 4, '2024-11-13 13:49:38.616694', 116, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.617666', 980, 4, '2024-11-13 13:49:38.617666', 116, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:49:38.61903', 981, 4, '2024-11-13 13:49:38.61903', 116, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.072492', 987, 4, '2024-11-13 13:52:22.072492', 117, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.073761', 988, 4, '2024-11-13 13:52:22.073761', 117, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.074901', 989, 4, '2024-11-13 13:52:22.074901', 117, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.075918', 990, 4, '2024-11-13 13:52:22.075918', 117, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.07692', 991, 4, '2024-11-13 13:52:22.07692', 117, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:52:22.077968', 992, 4, '2024-11-13 13:52:22.077968', 117, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.449549', 993, 2, '2024-11-13 13:54:34.449549', 118, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.45101', 994, 4, '2024-11-13 13:54:34.45101', 118, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.452164', 995, 4, '2024-11-13 13:54:34.452164', 118, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.453207', 996, 4, '2024-11-13 13:54:34.453207', 118, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.454226', 997, 4, '2024-11-13 13:54:34.454226', 118, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.455354', 998, 4, '2024-11-13 13:54:34.455354', 118, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.456459', 999, 4, '2024-11-13 13:54:34.456459', 118, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.457463', 1000, 4, '2024-11-13 13:54:34.457463', 118, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.458512', 1001, 4, '2024-11-13 13:54:34.458512', 118, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.459511', 1002, 4, '2024-11-13 13:54:34.459511', 118, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:54:34.460563', 1003, 4, '2024-11-13 13:54:34.460563', 118, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.263667', 1009, 4, '2024-11-13 13:58:10.263667', 119, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.264831', 1010, 4, '2024-11-13 13:58:10.264831', 119, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.26602', 1011, 4, '2024-11-13 13:58:10.26602', 119, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.266982', 1012, 4, '2024-11-13 13:58:10.266982', 119, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.268171', 1013, 4, '2024-11-13 13:58:10.268171', 119, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 13:58:10.269577', 1014, 4, '2024-11-13 13:58:10.269577', 119, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.657988', 1015, 4, '2024-11-13 14:03:43.657988', 120, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.659432', 1016, 2, '2024-11-13 14:03:43.659432', 120, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.660444', 1017, 4, '2024-11-13 14:03:43.660444', 120, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.661354', 1018, 4, '2024-11-13 14:03:43.661354', 120, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.662372', 1019, 4, '2024-11-13 14:03:43.662372', 120, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.66343', 1020, 4, '2024-11-13 14:03:43.66343', 120, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.664515', 1021, 4, '2024-11-13 14:03:43.664515', 120, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.665611', 1022, 4, '2024-11-13 14:03:43.665611', 120, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.66662', 1023, 4, '2024-11-13 14:03:43.66662', 120, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.667638', 1024, 4, '2024-11-13 14:03:43.667638', 120, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:03:43.668955', 1025, 4, '2024-11-13 14:03:43.668955', 120, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.223515', 1028, 4, '2024-11-13 14:12:20.223515', 121, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.224842', 1029, 4, '2024-11-13 14:12:20.224842', 121, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.226139', 1030, 4, '2024-11-13 14:12:20.226139', 121, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.227457', 1031, 4, '2024-11-13 14:12:20.227457', 121, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.228613', 1032, 4, '2024-11-13 14:12:20.228613', 121, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.229633', 1033, 4, '2024-11-13 14:12:20.229633', 121, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.230819', 1034, 4, '2024-11-13 14:12:20.230819', 121, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.231959', 1035, 4, '2024-11-13 14:12:20.231959', 121, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:12:20.23328', 1036, 4, '2024-11-13 14:12:20.23328', 121, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.973536', 1037, 4, '2024-11-13 14:14:25.973536', 122, 'public SseEmitter get(Long id) {
        return emitters.get(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.974974', 1038, 2, '2024-11-13 14:14:25.974974', 122, '// JavaScript
console.log("Hello, World!");
', 'ㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.975963', 1039, 4, '2024-11-13 14:14:25.975963', 122, 'private SseEmitter createEmitter(Long id) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        emitterRepository.save(id, emitter);

        emitter.onCompletion(() -> emitterRepository.deleteById(id));
        emitter.onTimeout(() -> emitterRepository.deleteById(id));
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.977103', 1040, 4, '2024-11-13 14:14:25.977103', 122, 'public void save(Long id, SseEmitter emitter) {
        emitters.put(id, emitter);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.978091', 1041, 4, '2024-11-13 14:14:25.978091', 122, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.979161', 1042, 4, '2024-11-13 14:14:25.979161', 122, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.980321', 1043, 4, '2024-11-13 14:14:25.980321', 122, 'public SseEmitter subscribe(Long userId) {
        SseEmitter emitter = createEmitter(userId);

        sendToClient(userId, "EventStream Created. [userId=" + userId + "]");
        return emitter;
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.981449', 1044, 4, '2024-11-13 14:14:25.981449', 122, 'public void deleteById(Long id) {
        emitters.remove(id);
    }', 'EmitterRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.982947', 1045, 4, '2024-11-13 14:14:25.982947', 122, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.506638', 1159, 4, '2024-11-14 14:36:22.506638', 152, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.984352', 1046, 4, '2024-11-13 14:14:25.984352', 122, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:14:25.985847', 1047, 4, '2024-11-13 14:14:25.985847', 122, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.433348', 1048, 4, '2024-11-13 14:22:12.433348', 123, '@PostMapping("/me")
    @Operation(summary = "현재 로그인 된 사용자의 연동된 Gitlab 정보 확인")
    public ApiResponse<Void> addGitlabAccount(
            @AuthUser User user, @Valid @RequestBody GitlabAccountRequest gitlabAccountRequest) {
        userService.addGitlabAccount(
                gitlabAccountRequest.domain(), gitlabAccountRequest.userToken(), user.getId());
        return ApiSuccessResponse.success();
    }', 'UserController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.434739', 1049, 4, '2024-11-13 14:22:12.434739', 123, '@DeleteMapping("/{gitlabProjectId}")
    @Operation(summary = "연동된 프로젝트 삭제")
    public ApiResponse<Map<String, Long>> deleteUserProject(
            @AuthUser User user, @PathVariable("gitlabProjectId") Long gitlabProjectId) {
        Long projectId = userProjectService.unlinkGitlabProject(user, gitlabProjectId);
        return ApiSuccessResponse.success("projectId", projectId);
    }', 'UserProjectController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.435682', 1050, 4, '2024-11-13 14:22:12.435682', 123, '@Transactional
    public void addGitlabAccount(String domain, String userToken, Long userId) {
        User user = userRepository.getById(userId);
        badgeEventService.eventFirstLogin(user);
        gitLabClient.getUserInfo(domain, userToken);

        try {
            gitlabAccountRepository.save(
                    GitlabAccount.builder().user(user).domain(domain).userToken(userToken).build());
        } catch (DataIntegrityViolationException e) {
            throw new BusinessException(ErrorCode.USER_TOKEN_ALREADY_EXIST);
        }

        if (user.getUsername() == null) synchronizeUserInfo(userId);
    }', 'UserService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.436792', 1051, 4, '2024-11-13 14:22:12.436792', 123, '@PatchMapping("/recent-project/{projectId}")
    @Operation(summary = "최근 조회한 프로젝트 식별자", description = "GitlabAccount의 recentProjectId 변경")
    public ApiResponse<Void> updateRecentProject(
            @AuthUser User user, @PathVariable Long projectId) {
        userService.updateRecentProjectId(user.getId(), projectId);
        return ApiSuccessResponse.success();
    }', 'UserController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.437852', 1052, 4, '2024-11-13 14:22:12.437852', 123, '@Override
    public void onAuthenticationSuccess(
            HttpServletRequest request, HttpServletResponse response, Authentication authentication)
            throws IOException, ServletException {
        UserDetails principal = (UserDetails) authentication.getPrincipal();
        User user = principal.getUser();
        Long userId = user.getId();
        String username = user.getUsername();

        log.info("=== 로그인 성공 ===");
        Map<String, Object> responseMap = Map.of("userId", userId);
        String accessToken = JwtProvider.generateToken(responseMap, JwtConstants.ACCESS_EXP_TIME);
        String refreshToken = JwtProvider.generateToken(responseMap, JwtConstants.REFRESH_EXP_TIME);

        Cookie accessTokenCookie =
                cookieUtil.createCookie(
                        JwtConstants.ACCESS_NAME, accessToken, JwtConstants.ACCESS_EXP_TIME * 60);
        Cookie refreshTokenCookie =
                cookieUtil.createCookie(
                        JwtConstants.REFRESH_NAME,
                        refreshToken,
                        JwtConstants.REFRESH_EXP_TIME * 60);

        response.addCookie(accessTokenCookie);
        response.addCookie(refreshTokenCookie);

        redisUtil.set(userId.toString(), refreshToken, JwtConstants.REFRESH_EXP_TIME);
        loginHistoryService.recordLogin(user);
        badgeEventService.eventRandom(user);

        boolean isSignUp = username == null ? false : true;
        boolean isConnect = userService.isConnect(userId);
        Long projectId = userService.getRecentVisitProjectId(user);

        if (isConnect && projectId == null) {
            UserProject userProject =
                    userProjectRepository.findTopByUserIdOrderByCreatedDateDesc(userId);
            projectId = userProject.getProject().getId();
        }

        String redirectUrl = cookieUtil.getCookieValue(request, "redirect_url");
        redirectUrl =
                String.format(
                        "%s?isSignup=%b&isConnect=%b&projectId=%s",
                        redirectUrl, isSignUp, isConnect, projectId != null ? projectId : "");

        cookieUtil.deleteCookie(request, response, "redirect_url");

        log.info("redirect_url={}", redirectUrl);
        response.sendRedirect(redirectUrl);
    }', 'CommonLoginSuccessHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.438986', 1053, 4, '2024-11-13 14:22:12.438986', 123, '@PostMapping("/{gitlabProjectId}")
    @Operation(summary = "프로젝트 연동 추가")
    public ApiResponse<Map<String, Long>> addUserProject(
            @AuthUser User user,
            @PathVariable("gitlabProjectId") Long gitlabProjectId,
            @RequestBody(required = false) ProjectLinkRequest projectLinkRequest) {
        Long projectId =
                userProjectService.linkGitlabProject(user, gitlabProjectId, projectLinkRequest);
        return ApiSuccessResponse.success("projectId", projectId);
    }', 'UserProjectController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.439865', 1054, 4, '2024-11-13 14:22:12.439865', 123, '@Transactional
    public Long unlinkGitlabProject(User user, Long gitlabProjectId) {
        GitlabAccount gitlabAccount = gitlabAccountRepository.getFirstByUserId(user.getId());
        Project project = projectRepository.getByGitlabProjectId(gitlabProjectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);
        userProjectRepository.delete(userProject);
        return userProject.getId();
    }', 'UserProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.440851', 1055, 4, '2024-11-13 14:22:12.440851', 123, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.441977', 1056, 4, '2024-11-13 14:22:12.441977', 123, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 14:22:12.443061', 1057, 4, '2024-11-13 14:22:12.443061', 123, '@Transactional
    public void synchronizeUserInfo(Long userId) {
        User user = userRepository.getById(userId);
        GitlabUserInfoContent userInfo =
                gitLabClient.getUserInfo(
                        user.getGitlabAccounts().getFirst().getDomain(),
                        user.getGitlabAccounts().getFirst().getUserToken());
        user.updateUserInfo(userInfo.username(), userInfo.avatarUrl());
    }', 'UserService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.28674', 1058, 4, '2024-11-13 15:37:24.28674', 124, '@PostMapping("/me")
    @Operation(summary = "현재 로그인 된 사용자의 연동된 Gitlab 정보 확인")
    public ApiResponse<Void> addGitlabAccount(
            @AuthUser User user, @Valid @RequestBody GitlabAccountRequest gitlabAccountRequest) {
        userService.addGitlabAccount(
                gitlabAccountRequest.domain(), gitlabAccountRequest.userToken(), user.getId());
        return ApiSuccessResponse.success();
    }', 'UserController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.291774', 1059, 4, '2024-11-13 15:37:24.291774', 124, '@DeleteMapping("/{gitlabProjectId}")
    @Operation(summary = "연동된 프로젝트 삭제")
    public ApiResponse<Map<String, Long>> deleteUserProject(
            @AuthUser User user, @PathVariable("gitlabProjectId") Long gitlabProjectId) {
        Long projectId = userProjectService.unlinkGitlabProject(user, gitlabProjectId);
        return ApiSuccessResponse.success("projectId", projectId);
    }', 'UserProjectController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.293125', 1060, 4, '2024-11-13 15:37:24.293125', 124, '@Transactional
    public void addGitlabAccount(String domain, String userToken, Long userId) {
        User user = userRepository.getById(userId);
        badgeEventService.eventFirstLogin(user);
        gitLabClient.getUserInfo(domain, userToken);

        try {
            gitlabAccountRepository.save(
                    GitlabAccount.builder().user(user).domain(domain).userToken(userToken).build());
        } catch (DataIntegrityViolationException e) {
            throw new BusinessException(ErrorCode.USER_TOKEN_ALREADY_EXIST);
        }

        if (user.getUsername() == null) synchronizeUserInfo(userId);
    }', 'UserService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.294326', 1061, 4, '2024-11-13 15:37:24.294326', 124, '@PatchMapping("/recent-project/{projectId}")
    @Operation(summary = "최근 조회한 프로젝트 식별자", description = "GitlabAccount의 recentProjectId 변경")
    public ApiResponse<Void> updateRecentProject(
            @AuthUser User user, @PathVariable Long projectId) {
        userService.updateRecentProjectId(user.getId(), projectId);
        return ApiSuccessResponse.success();
    }', 'UserController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.295696', 1062, 4, '2024-11-13 15:37:24.295696', 124, '@Override
    public void onAuthenticationSuccess(
            HttpServletRequest request, HttpServletResponse response, Authentication authentication)
            throws IOException, ServletException {
        UserDetails principal = (UserDetails) authentication.getPrincipal();
        User user = principal.getUser();
        Long userId = user.getId();
        String username = user.getUsername();

        log.info("=== 로그인 성공 ===");
        Map<String, Object> responseMap = Map.of("userId", userId);
        String accessToken = JwtProvider.generateToken(responseMap, JwtConstants.ACCESS_EXP_TIME);
        String refreshToken = JwtProvider.generateToken(responseMap, JwtConstants.REFRESH_EXP_TIME);

        Cookie accessTokenCookie =
                cookieUtil.createCookie(
                        JwtConstants.ACCESS_NAME, accessToken, JwtConstants.ACCESS_EXP_TIME * 60);
        Cookie refreshTokenCookie =
                cookieUtil.createCookie(
                        JwtConstants.REFRESH_NAME,
                        refreshToken,
                        JwtConstants.REFRESH_EXP_TIME * 60);

        response.addCookie(accessTokenCookie);
        response.addCookie(refreshTokenCookie);

        redisUtil.set(userId.toString(), refreshToken, JwtConstants.REFRESH_EXP_TIME);
        loginHistoryService.recordLogin(user);
        badgeEventService.eventRandom(user);

        boolean isSignUp = username == null ? false : true;
        boolean isConnect = userService.isConnect(userId);
        Long projectId = userService.getRecentVisitProjectId(user);

        if (isConnect && projectId == null) {
            UserProject userProject =
                    userProjectRepository.findTopByUserIdOrderByCreatedDateDesc(userId);
            projectId = userProject.getProject().getId();
        }

        String redirectUrl = cookieUtil.getCookieValue(request, "redirect_url");
        redirectUrl =
                String.format(
                        "%s?isSignup=%b&isConnect=%b&projectId=%s",
                        redirectUrl, isSignUp, isConnect, projectId != null ? projectId : "");

        cookieUtil.deleteCookie(request, response, "redirect_url");

        log.info("redirect_url={}", redirectUrl);
        response.sendRedirect(redirectUrl);
    }', 'CommonLoginSuccessHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.297205', 1063, 4, '2024-11-13 15:37:24.297205', 124, '@PostMapping("/{gitlabProjectId}")
    @Operation(summary = "프로젝트 연동 추가")
    public ApiResponse<Map<String, Long>> addUserProject(
            @AuthUser User user,
            @PathVariable("gitlabProjectId") Long gitlabProjectId,
            @RequestBody(required = false) ProjectLinkRequest projectLinkRequest) {
        Long projectId =
                userProjectService.linkGitlabProject(user, gitlabProjectId, projectLinkRequest);
        return ApiSuccessResponse.success("projectId", projectId);
    }', 'UserProjectController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.298497', 1064, 4, '2024-11-13 15:37:24.298497', 124, '@Transactional
    public Long unlinkGitlabProject(User user, Long gitlabProjectId) {
        GitlabAccount gitlabAccount = gitlabAccountRepository.getFirstByUserId(user.getId());
        Project project = projectRepository.getByGitlabProjectId(gitlabProjectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);
        userProjectRepository.delete(userProject);
        return userProject.getId();
    }', 'UserProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.299576', 1065, 4, '2024-11-13 15:37:24.299576', 124, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:43.78104', 1375, 4, '2024-11-17 18:10:43.78104', 198, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.300932', 1066, 4, '2024-11-13 15:37:24.300932', 124, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 15:37:24.302313', 1067, 4, '2024-11-13 15:37:24.302313', 124, '@Transactional
    public void synchronizeUserInfo(Long userId) {
        User user = userRepository.getById(userId);
        GitlabUserInfoContent userInfo =
                gitLabClient.getUserInfo(
                        user.getGitlabAccounts().getFirst().getDomain(),
                        user.getGitlabAccounts().getFirst().getUserToken());
        user.updateUserInfo(userInfo.username(), userInfo.avatarUrl());
    }', 'UserService.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 16:56:58.914812', 1068, 4, '2024-11-13 16:56:58.914812', 125, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 16:56:58.920122', 1069, 4, '2024-11-13 16:56:58.920122', 125, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 17:28:40.302948', 1070, 4, '2024-11-13 17:28:40.302948', 126, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 17:28:40.30499', 1071, 4, '2024-11-13 17:28:40.30499', 126, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 17:36:22.278082', 1072, 4, '2024-11-13 17:36:22.278082', 127, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 17:36:22.279481', 1073, 4, '2024-11-13 17:36:22.279481', 127, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:12:23.353117', 1074, 4, '2024-11-13 18:12:23.353117', 128, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:12:23.354749', 1075, 4, '2024-11-13 18:12:23.354749', 128, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:13:33.274626', 1076, 4, '2024-11-13 18:13:33.274626', 129, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:13:33.28047', 1077, 4, '2024-11-13 18:13:33.28047', 129, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:13:33.281924', 1078, 2, '2024-11-13 18:13:33.281924', 129, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㅇㅁㅇㅁㅇ');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:18:14.218521', 1079, 4, '2024-11-13 18:18:14.218521', 130, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:18:14.220228', 1080, 4, '2024-11-13 18:18:14.220228', 130, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:21:51.883395', 1081, 4, '2024-11-13 18:21:51.883395', 131, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:21:51.884705', 1082, 4, '2024-11-13 18:21:51.884705', 131, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:23:22.227613', 1083, 4, '2024-11-13 18:23:22.227613', 132, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:23:22.229259', 1084, 4, '2024-11-13 18:23:22.229259', 132, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:23:46.580979', 1085, 4, '2024-11-13 18:23:46.580979', 133, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:23:46.58249', 1086, 4, '2024-11-13 18:23:46.58249', 133, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:24:17.517438', 1087, 4, '2024-11-13 18:24:17.517438', 134, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:24:17.518669', 1088, 4, '2024-11-13 18:24:17.518669', 134, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:24:47.859671', 1089, 4, '2024-11-13 18:24:47.859671', 135, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:24:47.861581', 1090, 4, '2024-11-13 18:24:47.861581', 135, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:25:50.304036', 1091, 4, '2024-11-13 18:25:50.304036', 136, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:25:50.305459', 1092, 4, '2024-11-13 18:25:50.305459', 136, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:26:10.140303', 1093, 4, '2024-11-13 18:26:10.140303', 137, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:26:10.142172', 1094, 4, '2024-11-13 18:26:10.142172', 137, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:27:51.072681', 1095, 4, '2024-11-13 18:27:51.072681', 138, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:27:51.076748', 1096, 4, '2024-11-13 18:27:51.076748', 138, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:13.618741', 1097, 4, '2024-11-13 18:28:13.618741', 139, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:13.62033', 1098, 4, '2024-11-13 18:28:13.62033', 139, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:32.005567', 1099, 4, '2024-11-13 18:28:32.005567', 140, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:32.008769', 1100, 4, '2024-11-13 18:28:32.008769', 140, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:53.585925', 1101, 4, '2024-11-13 18:28:53.585925', 141, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-13 18:28:53.58725', 1102, 4, '2024-11-13 18:28:53.58725', 141, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:00:42.68337', 1103, 4, '2024-11-14 10:00:42.68337', 143, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:00:42.68714', 1104, 4, '2024-11-14 10:00:42.68714', 143, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:01:19.505849', 1105, 4, '2024-11-14 10:01:19.505849', 144, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:01:19.508183', 1106, 4, '2024-11-14 10:01:19.508183', 144, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 10:30:17.594012', 1107, 4, '2024-11-14 10:30:17.594012', 145, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:44.24629', 1376, 4, '2024-11-17 18:10:44.24629', 199, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.597003', 1109, 4, '2024-11-14 13:19:28.597003', 146, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.59874', 1110, 4, '2024-11-14 13:19:28.59874', 146, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.599961', 1111, 4, '2024-11-14 13:19:28.599961', 146, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.601122', 1112, 4, '2024-11-14 13:19:28.601122', 146, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.602136', 1113, 4, '2024-11-14 13:19:28.602136', 146, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.603214', 1114, 4, '2024-11-14 13:19:28.603214', 146, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.604344', 1115, 4, '2024-11-14 13:19:28.604344', 146, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.605417', 1116, 4, '2024-11-14 13:19:28.605417', 146, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:44.248431', 1377, 4, '2024-11-17 18:10:44.248431', 199, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.606398', 1117, 4, '2024-11-14 13:19:28.606398', 146, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:19:28.607445', 1118, 4, '2024-11-14 13:19:28.607445', 146, 'public ProjectTeamDetailResponse getTeamDetail(User user, Long projectId) {
        GitlabAccount gitlabAccount = gitlabAccountRepository.getFirstByUserId(user.getId());
        Project project = projectRepository.getById(projectId);
        ProjectInfoContent projectInfoContent =
                gitLabClient.getProjectInfoDetail(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        project.getFullPath());
        Long aiReviewCount = projectRepository.findReviewCountByProjectId(project.getId());
        return ProjectTeamDetailResponse.of(projectInfoContent, aiReviewCount);
    }', 'ProjectTeamStatisticsService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.722387', 1119, 4, '2024-11-14 13:29:38.722387', 147, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.727327', 1120, 4, '2024-11-14 13:29:38.727327', 147, '@Operation(summary = "SSE 연결", description = "SSE를 연결합니다.")
    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@AuthUser User user) {
        return sseService.subscribe(user.getId());
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.728746', 1121, 4, '2024-11-14 13:29:38.728746', 147, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.730302', 1122, 4, '2024-11-14 13:29:38.730302', 147, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.731828', 1123, 4, '2024-11-14 13:29:38.731828', 147, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.734186', 1124, 4, '2024-11-14 13:29:38.734186', 147, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.735605', 1125, 4, '2024-11-14 13:29:38.735605', 147, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.736964', 1126, 4, '2024-11-14 13:29:38.736964', 147, '@PostMapping
    public void sendDataTest(@AuthUser User user) {
        sseService.notify(user.getId(), "data");
    }', 'SseController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.738429', 1127, 4, '2024-11-14 13:29:38.738429', 147, 'private void sendToClient(Long id, Object data) {
        SseEmitter emitter = emitterRepository.get(id);
        if (emitter != null) {
            try {
                String jsonData = objectMapper.writeValueAsString(data);
                System.out.println("Sending data: " + jsonData);
                emitter.send(
                        SseEmitter.event()
                                .id(String.valueOf(id))
                                .name("notification")
                                .data(jsonData));
            } catch (JsonProcessingException e) {
                e.printStackTrace();
                throw new RuntimeException("JSON 변환 오류!", e);
            } catch (IOException e) {
                e.printStackTrace();
                emitterRepository.deleteById(id);
                throw new RuntimeException("연결 오류!", e);
            }
        } else {
            System.err.println("Emitter not found for id: " + id);
        }
    }', 'SseService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 13:29:38.7398', 1128, 4, '2024-11-14 13:29:38.7398', 147, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:04:25.15743', 1129, 4, '2024-11-14 14:04:25.15743', 148, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:04:25.162543', 1130, 4, '2024-11-14 14:04:25.162543', 148, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.514168', 1131, 4, '2024-11-14 14:26:37.514168', 150, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.51594', 1132, 4, '2024-11-14 14:26:37.51594', 150, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.517224', 1133, 4, '2024-11-14 14:26:37.517224', 150, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:15.745195', 1261, 4, '2024-11-15 17:10:15.745195', 174, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:15.753419', 1262, 4, '2024-11-15 17:10:15.753419', 174, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:46.88599', 1378, 4, '2024-11-17 18:10:46.88599', 200, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.518474', 1134, 4, '2024-11-14 14:26:37.518474', 150, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.519747', 1135, 4, '2024-11-14 14:26:37.519747', 150, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.521152', 1136, 4, '2024-11-14 14:26:37.521152', 150, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.522503', 1137, 4, '2024-11-14 14:26:37.522503', 150, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.52392', 1138, 4, '2024-11-14 14:26:37.52392', 150, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.525215', 1139, 4, '2024-11-14 14:26:37.525215', 150, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:26:37.526286', 1140, 4, '2024-11-14 14:26:37.526286', 150, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.018154', 1141, 4, '2024-11-14 14:35:33.018154', 151, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.023679', 1142, 4, '2024-11-14 14:35:33.023679', 151, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:15.754999', 1263, 2, '2024-11-15 17:10:15.754999', 174, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.025103', 1143, 4, '2024-11-14 14:35:33.025103', 151, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.026643', 1144, 4, '2024-11-14 14:35:33.026643', 151, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.028157', 1145, 4, '2024-11-14 14:35:33.028157', 151, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.030468', 1146, 4, '2024-11-14 14:35:33.030468', 151, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.031915', 1147, 4, '2024-11-14 14:35:33.031915', 151, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.033239', 1148, 4, '2024-11-14 14:35:33.033239', 151, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.034583', 1149, 4, '2024-11-14 14:35:33.034583', 151, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:35:33.035861', 1150, 4, '2024-11-14 14:35:33.035861', 151, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.95851', 1194, 4, '2024-11-14 19:07:22.95851', 159, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:17.033953', 1264, 4, '2024-11-15 17:10:17.033953', 175, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.495583', 1151, 4, '2024-11-14 14:36:22.495583', 152, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.497472', 1152, 4, '2024-11-14 14:36:22.497472', 152, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.498792', 1153, 4, '2024-11-14 14:36:22.498792', 152, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.499935', 1154, 4, '2024-11-14 14:36:22.499935', 152, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.501302', 1155, 4, '2024-11-14 14:36:22.501302', 152, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.502764', 1156, 4, '2024-11-14 14:36:22.502764', 152, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.504159', 1157, 4, '2024-11-14 14:36:22.504159', 152, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.505402', 1158, 4, '2024-11-14 14:36:22.505402', 152, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 14:36:22.50783', 1160, 4, '2024-11-14 14:36:22.50783', 152, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 15:33:25.60368', 1161, 4, '2024-11-14 15:33:25.60368', 155, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 15:33:25.605493', 1162, 4, '2024-11-14 15:33:25.605493', 155, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 15:40:47.761745', 1163, 4, '2024-11-14 15:40:47.761745', 156, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 15:40:47.763237', 1164, 4, '2024-11-14 15:40:47.763237', 156, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.639321', 1165, 4, '2024-11-14 17:04:57.639321', 157, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.645305', 1166, 4, '2024-11-14 17:04:57.645305', 157, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.647036', 1167, 4, '2024-11-14 17:04:57.647036', 157, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.648924', 1168, 4, '2024-11-14 17:04:57.648924', 157, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.650401', 1169, 4, '2024-11-14 17:04:57.650401', 157, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:17.036217', 1265, 4, '2024-11-15 17:10:17.036217', 175, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:10:17.038931', 1266, 2, '2024-11-15 17:10:17.038931', 175, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:46.887879', 1379, 4, '2024-11-17 18:10:46.887879', 200, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.652273', 1170, 4, '2024-11-14 17:04:57.652273', 157, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.654037', 1171, 4, '2024-11-14 17:04:57.654037', 157, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.655391', 1172, 4, '2024-11-14 17:04:57.655391', 157, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.656616', 1173, 4, '2024-11-14 17:04:57.656616', 157, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:04:57.658033', 1174, 4, '2024-11-14 17:04:57.658033', 157, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.755368', 1175, 4, '2024-11-14 17:16:02.755368', 158, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.75721', 1176, 4, '2024-11-14 17:16:02.75721', 158, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.702222', 1195, 4, '2024-11-14 19:12:35.702222', 160, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:19:27.041024', 1267, 4, '2024-11-15 17:19:27.041024', 176, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.758442', 1177, 4, '2024-11-14 17:16:02.758442', 158, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.760188', 1178, 4, '2024-11-14 17:16:02.760188', 158, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.761461', 1179, 4, '2024-11-14 17:16:02.761461', 158, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.762645', 1180, 4, '2024-11-14 17:16:02.762645', 158, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.76387', 1181, 4, '2024-11-14 17:16:02.76387', 158, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.765207', 1182, 4, '2024-11-14 17:16:02.765207', 158, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.766539', 1183, 4, '2024-11-14 17:16:02.766539', 158, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 17:16:02.767573', 1184, 4, '2024-11-14 17:16:02.767573', 158, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.94135', 1185, 4, '2024-11-14 19:07:22.94135', 159, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.946474', 1186, 4, '2024-11-14 19:07:22.946474', 159, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.948026', 1187, 4, '2024-11-14 19:07:22.948026', 159, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.949579', 1188, 4, '2024-11-14 19:07:22.949579', 159, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.951172', 1189, 4, '2024-11-14 19:07:22.951172', 159, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.953486', 1190, 4, '2024-11-14 19:07:22.953486', 159, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.954847', 1191, 4, '2024-11-14 19:07:22.954847', 159, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.956057', 1192, 4, '2024-11-14 19:07:22.956057', 159, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:07:22.957371', 1193, 4, '2024-11-14 19:07:22.957371', 159, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:19:27.043489', 1268, 4, '2024-11-15 17:19:27.043489', 176, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:19:27.044818', 1269, 2, '2024-11-15 17:19:27.044818', 176, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.703768', 1196, 4, '2024-11-14 19:12:35.703768', 160, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.705312', 1197, 4, '2024-11-14 19:12:35.705312', 160, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.706557', 1198, 4, '2024-11-14 19:12:35.706557', 160, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.707762', 1199, 4, '2024-11-14 19:12:35.707762', 160, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.708915', 1200, 4, '2024-11-14 19:12:35.708915', 160, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.710001', 1201, 4, '2024-11-14 19:12:35.710001', 160, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.711069', 1202, 4, '2024-11-14 19:12:35.711069', 160, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:21:58.1337', 1270, 4, '2024-11-15 17:21:58.1337', 177, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:21:58.13568', 1271, 4, '2024-11-15 17:21:58.13568', 177, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.712499', 1203, 4, '2024-11-14 19:12:35.712499', 160, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:12:35.713916', 1204, 4, '2024-11-14 19:12:35.713916', 160, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.908946', 1205, 4, '2024-11-14 19:13:15.908946', 161, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.910341', 1206, 4, '2024-11-14 19:13:15.910341', 161, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.911436', 1207, 4, '2024-11-14 19:13:15.911436', 161, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.912707', 1208, 4, '2024-11-14 19:13:15.912707', 161, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.914047', 1209, 4, '2024-11-14 19:13:15.914047', 161, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.616541', 1229, 4, '2024-11-14 19:33:13.616541', 166, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:21:58.137342', 1272, 2, '2024-11-15 17:21:58.137342', 177, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-15 17:21:58.138833', 1273, 2, '2024-11-15 17:21:58.138833', 177, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:46.970753', 1380, 4, '2024-11-17 18:10:46.970753', 201, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.915218', 1210, 4, '2024-11-14 19:13:15.915218', 161, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.916499', 1211, 4, '2024-11-14 19:13:15.916499', 161, 'private int saveRetrievals(ReviewResponseMessage reviewResponse, Review review) {
        List<Retrieval> retrievals =
                reviewResponse.retrievals().stream()
                        .map(
                                message ->
                                        Retrieval.builder()
                                                .review(review)
                                                .fileName(message.fileName())
                                                .content(message.content())
                                                .language(
                                                        languageRepository.getByType(
                                                                LanguageType.fromType(
                                                                        message.language())))
                                                .build())
                        .toList();
        List<Retrieval> saved = retrievalRepository.saveAll(retrievals);
        log.debug("참고자료가 저장되었습니다. Saved Retrieval Count: {}", saved.size());
        return saved.size();
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.91755', 1212, 4, '2024-11-14 19:13:15.91755', 161, '@PostMapping
    @Operation(summary = "리뷰 재생성 요청", description = "참고 자료 수정/삭제 후 요청")
    public ApiResponse<Void> regenerateReview(
            @AuthUser User user, @Valid @RequestBody RegenerateReviewRequest request) {
        reviewService.regenerateReview(
                user, request.projectId(), request.gitlabMrIid(), request.retrievals());
        return ApiSuccessResponse.success();
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.918594', 1213, 4, '2024-11-14 19:13:15.918594', 161, '@GetMapping("/{reviewId}/retrievals")
    @Operation(summary = "참고 자료 상세 조회", description = "리뷰에 사용된 참고 자료 조회")
    public ApiResponse<List<RetrievalDetailResponse>> getRetrievalDetail(
            @PathVariable Long reviewId) {
        List<RetrievalDetailResponse> retrievalDetailResponse =
                reviewService.getRetrievalDetail(reviewId);
        return ApiSuccessResponse.success(retrievalDetailResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:13:15.919694', 1214, 4, '2024-11-14 19:13:15.919694', 161, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.618259', 1230, 4, '2024-11-14 19:33:13.618259', 166, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-14 19:33:13.619632', 1231, 4, '2024-11-14 19:33:13.619632', 166, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 18:48:32.200449', 1274, 4, '2024-11-15 18:48:32.200449', 178, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 18:48:32.204837', 1275, 4, '2024-11-15 18:48:32.204837', 178, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 18:48:32.206626', 1276, 2, '2024-11-15 18:48:32.206626', 178, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴ');
INSERT INTO public.retrieval VALUES ('2024-11-15 18:48:32.208189', 1277, 2, '2024-11-15 18:48:32.208189', 178, '// JavaScript
console.log("Hello, World!");
', 'ㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㅇㅁ');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.450014', 1296, 4, '2024-11-15 19:45:01.450014', 183, 'public List<ChannelCodeResponse> getChannelCodeList() {
        List<ChannelCode> channelCodes = channelCodeRepository.findAll();
        return channelCodes.stream().map(ChannelCodeResponse::of).toList();
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:13:12.227319', 1278, 4, '2024-11-15 19:13:12.227319', 179, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.739968', 1284, 4, '2024-11-15 19:15:58.739968', 180, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.741427', 1285, 4, '2024-11-15 19:15:58.741427', 180, '@GetMapping("/codes")
    @Operation(summary = "채널 코드 목록 조회")
    public ApiResponse<List<ChannelCodeResponse>> getChannelCodeList() {
        return ApiSuccessResponse.success(webhookChannelService.getChannelCodeList());
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.742907', 1286, 4, '2024-11-15 19:15:58.742907', 180, '@Transactional
    public void addWebhookChannel(Long projectId, Long channelCodeId, String webhookUrl) {
        Project project = projectRepository.getById(projectId);
        ChannelCode channelCode = channelCodeRepository.findChannelCodeById(channelCodeId);

        WebhookChannel webhookChannel =
                WebhookChannel.builder()
                        .project(project)
                        .channelCode(channelCode)
                        .webhookUrl(webhookUrl)
                        .build();

        webhookChannelRepository.save(webhookChannel);
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.744542', 1287, 4, '2024-11-15 19:15:58.744542', 180, '@Bean
    public MessageChannel mrEvalResponseChannel() {
        return new DirectChannel();
    }', 'RedisIntegrationConfig.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.746403', 1288, 4, '2024-11-15 19:15:58.746403', 180, '@PatchMapping("/{webhookChannelId}")
    @Operation(summary = "연동된 웹훅 정보 수정")
    public ApiResponse<Void> updateWebhookChannel(
            @PathVariable("webhookChannelId") Long webhookChannelId,
            @Valid @RequestBody UpdateWebhookChannelRequest updateWebhookChannelRequest) {
        webhookChannelService.updateWebhookChannel(
                webhookChannelId, updateWebhookChannelRequest.webhookUrl());
        return ApiSuccessResponse.success();
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.748049', 1289, 4, '2024-11-15 19:15:58.748049', 180, '@Transactional
    public void updateWebhookChannel(Long webhookChannelId, String webhookUrl) {
        WebhookChannel webhookChannel = webhookChannelRepository.getById(webhookChannelId);
        webhookChannel.updateWebhookUrl(webhookUrl);
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.749135', 1290, 4, '2024-11-15 19:15:58.749135', 180, '@PostMapping
    @Operation(summary = "웹훅 채널 신규 등록")
    public ApiResponse<Void> addWebhookChannel(
            @Valid @RequestBody WebhookChannelRequest webhookChannelRequest) {
        webhookChannelService.addWebhookChannel(
                webhookChannelRequest.projectId(),
                webhookChannelRequest.channelCodeId(),
                webhookChannelRequest.webhookUrl());

        return ApiSuccessResponse.success();
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:15:58.750269', 1291, 4, '2024-11-15 19:15:58.750269', 180, 'private void send(String url, String content, ChannelCode channelCode) {
        HttpHeaders headers = restTemplateUtil.createHeaders(APPLICATION_JSON_VALUE);
        WebhookContent webhookContent = getWebhookContent(content, channelCode.getName());

        String body;
        try {
            body = objectMapper.writeValueAsString(webhookContent);
        } catch (JsonProcessingException e) {
            throw new BusinessException(WEBHOOK_REQUEST_SERIALIZATION_ERROR, e);
        }

        restTemplateUtil.sendPostRequest(
                url, headers, body, new ParameterizedTypeReference<String>() {});
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.453241', 1298, 4, '2024-11-15 19:45:01.453241', 183, '@Transactional
    @ServiceActivator(inputChannel = "reviewResponseChannel")
    public void handleReviewResponse(String reviewResponseMessage) {
        ReviewResponseMessage reviewResponse;
        try {
            reviewResponse =
                    objectMapper.readValue(reviewResponseMessage, ReviewResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(reviewResponse.mrInfoId());
        Project project = mrInfo.getProject();

        Review review = Review.builder().mrInfo(mrInfo).content(reviewResponse.content()).build();
        Review savedReview = reviewRepository.save(review);
        log.debug("리뷰가 저장되었습니다. Saved Review Id: {}", savedReview.getId());
        int savedRetrievalCount = saveRetrievals(reviewResponse, review);

        gitLabClient.addNoteToMr(
                reviewResponse.gitlabUrl(),
                project.getBotToken(),
                project.getGitlabProjectId(),
                mrInfo.getGitlabMrIid(),
                reviewResponse.content());
        log.debug(
                "Gitlab에 리뷰를 달았습니다. Saved Review Id: {}, Saved Retrieval Count: {}",
                savedReview.getId(),
                savedRetrievalCount);

        if (!project.getWebhookChannels().isEmpty()) {
            webhookChannelService.sendData(project.getId(), AI_REVIEW_COMPLETE_MESSAGE);
        }
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.45453', 1299, 4, '2024-11-15 19:45:01.45453', 183, '@GetMapping("/codes")
    @Operation(summary = "채널 코드 목록 조회")
    public ApiResponse<List<ChannelCodeResponse>> getChannelCodeList() {
        return ApiSuccessResponse.success(webhookChannelService.getChannelCodeList());
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.455558', 1300, 4, '2024-11-15 19:45:01.455558', 183, '@Transactional
    public void addWebhookChannel(Long projectId, Long channelCodeId, String webhookUrl) {
        Project project = projectRepository.getById(projectId);
        ChannelCode channelCode = channelCodeRepository.findChannelCodeById(channelCodeId);

        WebhookChannel webhookChannel =
                WebhookChannel.builder()
                        .project(project)
                        .channelCode(channelCode)
                        .webhookUrl(webhookUrl)
                        .build();

        webhookChannelRepository.save(webhookChannel);
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.456674', 1301, 4, '2024-11-15 19:45:01.456674', 183, '@Bean
    public MessageChannel mrEvalResponseChannel() {
        return new DirectChannel();
    }', 'RedisIntegrationConfig.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.464549', 1302, 4, '2024-11-15 19:45:01.464549', 183, '@PatchMapping("/{webhookChannelId}")
    @Operation(summary = "연동된 웹훅 정보 수정")
    public ApiResponse<Void> updateWebhookChannel(
            @PathVariable("webhookChannelId") Long webhookChannelId,
            @Valid @RequestBody UpdateWebhookChannelRequest updateWebhookChannelRequest) {
        webhookChannelService.updateWebhookChannel(
                webhookChannelId, updateWebhookChannelRequest.webhookUrl());
        return ApiSuccessResponse.success();
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.466', 1303, 4, '2024-11-15 19:45:01.466', 183, '@Transactional
    public void updateWebhookChannel(Long webhookChannelId, String webhookUrl) {
        WebhookChannel webhookChannel = webhookChannelRepository.getById(webhookChannelId);
        webhookChannel.updateWebhookUrl(webhookUrl);
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.467077', 1304, 4, '2024-11-15 19:45:01.467077', 183, '@PostMapping
    @Operation(summary = "웹훅 채널 신규 등록")
    public ApiResponse<Void> addWebhookChannel(
            @Valid @RequestBody WebhookChannelRequest webhookChannelRequest) {
        webhookChannelService.addWebhookChannel(
                webhookChannelRequest.projectId(),
                webhookChannelRequest.channelCodeId(),
                webhookChannelRequest.webhookUrl());

        return ApiSuccessResponse.success();
    }', 'WebhookChannelController.java');
INSERT INTO public.retrieval VALUES ('2024-11-15 19:45:01.468369', 1305, 4, '2024-11-15 19:45:01.468369', 183, 'private void send(String url, String content, ChannelCode channelCode) {
        HttpHeaders headers = restTemplateUtil.createHeaders(APPLICATION_JSON_VALUE);
        WebhookContent webhookContent = getWebhookContent(content, channelCode.getName());

        String body;
        try {
            body = objectMapper.writeValueAsString(webhookContent);
        } catch (JsonProcessingException e) {
            throw new BusinessException(WEBHOOK_REQUEST_SERIALIZATION_ERROR, e);
        }

        restTemplateUtil.sendPostRequest(
                url, headers, body, new ParameterizedTypeReference<String>() {});
    }', 'WebhookChannelService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.591516', 1308, 4, '2024-11-16 14:35:41.591516', 185, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.594211', 1309, 4, '2024-11-16 14:35:41.594211', 185, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.595416', 1310, 4, '2024-11-16 14:35:41.595416', 185, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.596715', 1311, 4, '2024-11-16 14:35:41.596715', 185, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.597916', 1312, 4, '2024-11-16 14:35:41.597916', 185, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.599071', 1313, 4, '2024-11-16 14:35:41.599071', 185, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.600269', 1314, 4, '2024-11-16 14:35:41.600269', 185, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.60157', 1315, 4, '2024-11-16 14:35:41.60157', 185, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.602588', 1316, 4, '2024-11-16 14:35:41.602588', 185, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-16 14:35:41.603549', 1317, 4, '2024-11-16 14:35:41.603549', 185, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.063089', 1318, 4, '2024-11-17 15:39:58.063089', 186, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.069297', 1319, 4, '2024-11-17 15:39:58.069297', 186, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.982947', 1329, 4, '2024-11-17 15:50:47.982947', 187, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:46.97307', 1381, 4, '2024-11-17 18:10:46.97307', 201, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.070486', 1320, 4, '2024-11-17 15:39:58.070486', 186, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.072057', 1321, 4, '2024-11-17 15:39:58.072057', 186, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.073361', 1322, 4, '2024-11-17 15:39:58.073361', 186, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.074908', 1323, 4, '2024-11-17 15:39:58.074908', 186, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.076251', 1324, 4, '2024-11-17 15:39:58.076251', 186, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.077687', 1325, 4, '2024-11-17 15:39:58.077687', 186, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.078781', 1326, 4, '2024-11-17 15:39:58.078781', 186, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:39:58.080068', 1327, 4, '2024-11-17 15:39:58.080068', 186, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.981326', 1328, 4, '2024-11-17 15:50:47.981326', 187, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:23:45.098031', 1358, 4, '2024-11-17 17:23:45.098031', 190, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.984259', 1330, 4, '2024-11-17 15:50:47.984259', 187, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.985688', 1331, 4, '2024-11-17 15:50:47.985688', 187, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.986907', 1332, 4, '2024-11-17 15:50:47.986907', 187, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.988177', 1333, 4, '2024-11-17 15:50:47.988177', 187, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.989309', 1334, 4, '2024-11-17 15:50:47.989309', 187, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.990476', 1335, 4, '2024-11-17 15:50:47.990476', 187, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.992098', 1336, 4, '2024-11-17 15:50:47.992098', 187, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:50:47.99347', 1337, 4, '2024-11-17 15:50:47.99347', 187, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', '점수계산 로직');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.41468', 1338, 4, '2024-11-17 15:51:15.41468', 188, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:23:45.10033', 1359, 4, '2024-11-17 17:23:45.10033', 190, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.416212', 1339, 4, '2024-11-17 15:51:15.416212', 188, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.417646', 1340, 4, '2024-11-17 15:51:15.417646', 188, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.418734', 1341, 4, '2024-11-17 15:51:15.418734', 188, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.419773', 1342, 4, '2024-11-17 15:51:15.419773', 188, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.420879', 1343, 4, '2024-11-17 15:51:15.420879', 188, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.421929', 1344, 4, '2024-11-17 15:51:15.421929', 188, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.423156', 1345, 4, '2024-11-17 15:51:15.423156', 188, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.424215', 1346, 4, '2024-11-17 15:51:15.424215', 188, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 15:51:15.425711', 1347, 4, '2024-11-17 15:51:15.425711', 188, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.032398', 1360, 4, '2024-11-17 18:10:42.032398', 191, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.034774', 1361, 4, '2024-11-17 18:10:42.034774', 191, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.412327', 1364, 4, '2024-11-17 18:10:42.412327', 193, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.414641', 1365, 4, '2024-11-17 18:10:42.414641', 193, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.772218', 1366, 4, '2024-11-17 18:10:42.772218', 194, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.780288', 1348, 4, '2024-11-17 17:17:37.780288', 189, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.789047', 1349, 4, '2024-11-17 17:17:37.789047', 189, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.790477', 1350, 4, '2024-11-17 17:17:37.790477', 189, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.791798', 1351, 4, '2024-11-17 17:17:37.791798', 189, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.793291', 1352, 4, '2024-11-17 17:17:37.793291', 189, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.795571', 1353, 4, '2024-11-17 17:17:37.795571', 189, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.796974', 1354, 4, '2024-11-17 17:17:37.796974', 189, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.798523', 1355, 4, '2024-11-17 17:17:37.798523', 189, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.799949', 1356, 4, '2024-11-17 17:17:37.799949', 189, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.193026', 1362, 4, '2024-11-17 18:10:42.193026', 192, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 18:10:42.195568', 1363, 4, '2024-11-17 18:10:42.195568', 192, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 17:17:37.801273', 1357, 4, '2024-11-17 17:17:37.801273', 189, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.418972', 1382, 4, '2024-11-17 22:03:07.418972', 202, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.423282', 1383, 4, '2024-11-17 22:03:07.423282', 202, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.425262', 1384, 4, '2024-11-17 22:03:07.425262', 202, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.426635', 1385, 4, '2024-11-17 22:03:07.426635', 202, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.428176', 1386, 4, '2024-11-17 22:03:07.428176', 202, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.42957', 1387, 4, '2024-11-17 22:03:07.42957', 202, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.431008', 1388, 4, '2024-11-17 22:03:07.431008', 202, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.432312', 1389, 4, '2024-11-17 22:03:07.432312', 202, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:06.154222', 1415, 4, '2024-11-18 10:10:06.154222', 206, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.433492', 1390, 4, '2024-11-17 22:03:07.433492', 202, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:03:07.434791', 1391, 4, '2024-11-17 22:03:07.434791', 202, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.70774', 1392, 4, '2024-11-17 22:04:40.70774', 203, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.709355', 1393, 4, '2024-11-17 22:04:40.709355', 203, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.710581', 1394, 4, '2024-11-17 22:04:40.710581', 203, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.712131', 1395, 4, '2024-11-17 22:04:40.712131', 203, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.713573', 1396, 4, '2024-11-17 22:04:40.713573', 203, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.715024', 1397, 4, '2024-11-17 22:04:40.715024', 203, 'public List<GitlabMrDiffsContent> getMrDiffs(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createMRDiffsUrl(gitlabUrl, gitlabProjectId, iid);

        ResponseEntity<List<GitlabMrDiffsContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});
        return response.getBody();
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.716327', 1398, 4, '2024-11-17 22:04:40.716327', 203, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:06.156825', 1416, 4, '2024-11-18 10:10:06.156825', 206, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.717448', 1399, 4, '2024-11-17 22:04:40.717448', 203, 'private GitlabProjectResponse createGitlabProjectResponse(
            GitlabProjectSimpleContent content, Long gitlabAccountId) {
        return projectRepository
                .findByGitlabProjectId(GraphQlUtil.extractIdFromId(content.id()))
                .map(
                        project -> {
                            boolean isLinked = isProjectLinked(gitlabAccountId, project.getId());
                            return GitlabProjectResponse.ofLinkable(content, isLinked);
                        })
                .orElseGet(() -> GitlabProjectResponse.ofNonLinkable(content));
    }', 'GitlabApiService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.718857', 1400, 4, '2024-11-17 22:04:40.718857', 203, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-17 22:04:40.72019', 1401, 4, '2024-11-17 22:04:40.72019', 203, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.940044', 1402, 4, '2024-11-18 09:00:54.940044', 204, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.942302', 1403, 4, '2024-11-18 09:00:54.942302', 204, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.943757', 1404, 4, '2024-11-18 09:00:54.943757', 204, '@Transactional
    public void eventBestMrCount() {
        // BestMrHistory가 3회 이상인 사용자 ID 조회
        List<Long> userIds = bestMrHistoryRepository.findUsersWithAtLeastNHistory(3);

        // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
        List<Long> newBadgeUserIds =
                userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId());

        badgeCode = badgeCodeRepository.getById(LUCKY_FIND.getId());

        List<User> users = new ArrayList<>();
        List<UserBadge> newBadges =
                newBadgeUserIds.stream()
                        .map(
                                userId -> {
                                    User user = userRepository.getById(userId);
                                    users.add(user);
                                    return UserBadge.of(user, badgeCode);
                                })
                        .collect(Collectors.toList());

        userBadgeRepository.saveAll(newBadges);
        users.stream().forEach(user -> eventAllBadgeUnlocked(user));
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.945369', 1405, 4, '2024-11-18 09:00:54.945369', 204, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.946658', 1406, 4, '2024-11-18 09:00:54.946658', 204, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.94813', 1407, 4, '2024-11-18 09:00:54.94813', 204, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.32475', 1417, 4, '2024-11-18 10:10:43.32475', 207, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.949564', 1408, 4, '2024-11-18 09:00:54.949564', 204, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.950831', 1409, 4, '2024-11-18 09:00:54.950831', 204, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.952075', 1410, 4, '2024-11-18 09:00:54.952075', 204, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.953258', 1411, 4, '2024-11-18 09:00:54.953258', 204, 'private void processUserProject(UserProject userProject, BadgeCode badgeCode) {
        Project project = userProject.getProject();
        User user = userProject.getGitlabAccount().getUser();

        int week =
                projectDateUtil.calculateWeekNumber(
                        project.getCreatedDate().toLocalDate(), LocalDate.now());

        long totalScore = calculateTotalScore(userProject, week - 1);
        if (totalScore >= AI_REWARD_TARGET_SCORE
                && !userBadgeRepository.existsByUserAndBadgeCode(user, badgeCode)) {
            UserBadge userBadge = UserBadge.of(user, badgeCode);
            userBadgeRepository.save(userBadge);
            eventAllBadgeUnlocked(user);
        }
    }', 'BadgeEventService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:00:54.954797', 1412, 4, '2024-11-18 09:00:54.954797', 204, 'package com.reviewping.coflo.domain.user.repository;

import static com.reviewping.coflo.global.error.ErrorCode.USER_NOT_EXIST;

import com.reviewping.coflo.domain.badge.entity.BadgeCode;
import com.reviewping.coflo.domain.user.entity.User;
import com.reviewping.coflo.global.error.exception.BusinessException;
import java.util.List;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByOauth2Id(String oauth2Id);

    @Modifying
    @Query("UPDATE User u SET u.mainBadgeCode = :badgeCode WHERE u = :user")
    void updateBadge(@Param("user") User user, @Param("badgeCode") BadgeCode badgeCode);

    @Query("SELECT u FROM User u WHERE u.username IN (:usernames)")
    List<User> findAllByUsernames(@Param("usernames") List<String> usernames);

    default User getById(Long userId) {
        return findById(userId).orElseThrow(() -> new BusinessException(USER_NOT_EXIST));
    }
}
', 'UserRepository.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:07:52.58071', 1413, 4, '2024-11-18 09:07:52.58071', 205, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 09:07:52.584916', 1414, 4, '2024-11-18 09:07:52.584916', 205, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.326745', 1418, 4, '2024-11-18 10:10:43.326745', 207, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.328598', 1419, 4, '2024-11-18 10:10:43.328598', 207, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.330192', 1420, 4, '2024-11-18 10:10:43.330192', 207, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.331958', 1421, 4, '2024-11-18 10:10:43.331958', 207, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.333287', 1422, 4, '2024-11-18 10:10:43.333287', 207, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.334523', 1423, 4, '2024-11-18 10:10:43.334523', 207, '@GetMapping
    @Operation(summary = "리뷰 리스트 조회", description = "MR에 대한 AI 작성 리뷰 리스트 조회")
    public ApiResponse<ReviewResponse> getReviewList(
            @AuthUser User user, @RequestParam Long projectId, @RequestParam Long mergeRequestIid) {
        ReviewResponse reviewResponse =
                reviewService.getReviewList(user.getId(), projectId, mergeRequestIid);
        return ApiSuccessResponse.success(reviewResponse);
    }', 'ReviewController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.33576', 1424, 4, '2024-11-18 10:10:43.33576', 207, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.336961', 1425, 4, '2024-11-18 10:10:43.336961', 207, 'public GitlabMrQueryContent getSingleMergeRequest(
            String gitlabUrl, String token, String fullPath, Long mergeRequestIid) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(
                                            graphqlUtil.buildMergeRequestQuery(
                                                    fullPath, mergeRequestIid))
                                    .executeSync();
                    return response.field("project.mergeRequest")
                            .toEntity(GitlabMrQueryContent.class);
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.338176', 1426, 4, '2024-11-18 10:10:43.338176', 207, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.852942', 1427, 4, '2024-11-18 10:10:43.852942', 208, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.85485', 1428, 4, '2024-11-18 10:10:43.85485', 208, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.856431', 1429, 4, '2024-11-18 10:10:43.856431', 208, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.857658', 1430, 4, '2024-11-18 10:10:43.857658', 208, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.858948', 1431, 4, '2024-11-18 10:10:43.858948', 208, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.860131', 1432, 4, '2024-11-18 10:10:43.860131', 208, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.861446', 1433, 4, '2024-11-18 10:10:43.861446', 208, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.86263', 1434, 4, '2024-11-18 10:10:43.86263', 208, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.863874', 1435, 4, '2024-11-18 10:10:43.863874', 208, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:43.865774', 1436, 4, '2024-11-18 10:10:43.865774', 208, 'public GitlabMrQueryContent getSingleMergeRequest(
            String gitlabUrl, String token, String fullPath, Long mergeRequestIid) {
        return executeWithExceptionHandling(
                () -> {
                    HttpSyncGraphQlClient graphQlClient =
                            graphqlUtil.getGraphQlClient(gitlabUrl, token);
                    ClientGraphQlResponse response =
                            graphQlClient
                                    .document(
                                            graphqlUtil.buildMergeRequestQuery(
                                                    fullPath, mergeRequestIid))
                                    .executeSync();
                    return response.field("project.mergeRequest")
                            .toEntity(GitlabMrQueryContent.class);
                });
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.063075', 1437, 4, '2024-11-18 10:10:44.063075', 209, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.918387', 1515, 4, '2024-11-18 10:30:27.918387', 220, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.920738', 1516, 4, '2024-11-18 10:30:27.920738', 220, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.065386', 1438, 4, '2024-11-18 10:10:44.065386', 209, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.067249', 1439, 4, '2024-11-18 10:10:44.067249', 209, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.068709', 1440, 4, '2024-11-18 10:10:44.068709', 209, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.069996', 1441, 4, '2024-11-18 10:10:44.069996', 209, 'private List<MrInfo> getTop3MrInfos(Project project) {
        LocalDate[] startAndEndDates =
                projectDateUtil.calculateWeekStartAndEndDates(
                        LocalDate.from(project.getCreatedDate()), LocalDate.now());
        List<MrInfo> mrInfoList =
                mrInfoRepository.findTop3MrInfoList(
                        project.getId(),
                        startAndEndDates[0].atTime(0, 0, 0),
                        startAndEndDates[1].atTime(0, 0, 0));
        return mrInfoList;
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.071271', 1442, 4, '2024-11-18 10:10:44.071271', 209, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.072421', 1443, 4, '2024-11-18 10:10:44.072421', 209, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.07354', 1444, 4, '2024-11-18 10:10:44.07354', 209, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.075125', 1445, 4, '2024-11-18 10:10:44.075125', 209, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.076299', 1446, 4, '2024-11-18 10:10:44.076299', 209, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.78189', 1447, 4, '2024-11-18 10:10:44.78189', 210, 'private List<MrInfo> getTop3MrInfos(Project project) {
        LocalDate[] startAndEndDates =
                projectDateUtil.calculateWeekStartAndEndDates(
                        LocalDate.from(project.getCreatedDate()), LocalDate.now());
        List<MrInfo> mrInfoList =
                mrInfoRepository.findTop3MrInfoList(
                        project.getId(),
                        startAndEndDates[0].atTime(0, 0, 0),
                        startAndEndDates[1].atTime(0, 0, 0));
        return mrInfoList;
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.783716', 1448, 4, '2024-11-18 10:10:44.783716', 210, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.78495', 1449, 4, '2024-11-18 10:10:44.78495', 210, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.786216', 1450, 4, '2024-11-18 10:10:44.786216', 210, '@Transactional
    public void addBestMrHistory() {
        // Read
        List<String> usernames = new ArrayList<>();
        List<Project> projects = projectRepository.findAll();
        for (Project p : projects) {
            List<String> findUsernames = mergeRequestService.getUsernameBestMergeRequests(p);
            usernames.addAll(findUsernames);
        }

        // Process
        List<User> users = userRepository.findAllByUsernames(usernames);

        Map<String, User> userMap =
                users.stream().collect(Collectors.toMap(User::getUsername, Function.identity()));

        // Write
        List<BestMrHistory> histories =
                usernames.stream()
                        .filter(userMap::containsKey)
                        .map(
                                username ->
                                        new BestMrHistory(
                                                userMap.get(username).getId(), LocalDate.now()))
                        .toList();
        bestMrHistoryRepository.saveAll(histories);
    }', 'BestMrHistoryService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.787356', 1451, 4, '2024-11-18 10:10:44.787356', 210, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.78852', 1452, 4, '2024-11-18 10:10:44.78852', 210, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.789624', 1453, 4, '2024-11-18 10:10:44.789624', 210, '@Transactional
    @ServiceActivator(inputChannel = "mrEvalResponseChannel")
    public void handleEvalResponse(String mrEvalResponseMessage) {
        MrEvalResponseMessage evalResponse;
        try {
            evalResponse =
                    objectMapper.readValue(mrEvalResponseMessage, MrEvalResponseMessage.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        MrInfo mrInfo = mrInfoRepository.getById(evalResponse.mrInfoId());
        mrInfo.setConsistencyScore(evalResponse.mrEvaluationMessage().consistencyScore());
        mrInfo.setReadabilityScore(evalResponse.mrEvaluationMessage().readabilityScore());
        mrInfo.setSecurityScore(evalResponse.mrEvaluationMessage().securityScore());
        mrInfo.setReliabilityScore(evalResponse.mrEvaluationMessage().reliabilityScore());
        mrInfo.setMaintainabilityScore(evalResponse.mrEvaluationMessage().maintainabilityScore());
        mrInfo.setReusabilityScore(evalResponse.mrEvaluationMessage().reusabilityScore());
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.790882', 1454, 4, '2024-11-18 10:10:44.790882', 210, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.792191', 1455, 4, '2024-11-18 10:10:44.792191', 210, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:44.79336', 1456, 4, '2024-11-18 10:10:44.79336', 210, 'private GitlabMrResponse createGitlabMrResponse(GitlabMrDetailContent content) {
        boolean exists = mrInfoRepository.existsByGitlabMrIid(content.iid());
        return GitlabMrResponse.of(content, exists);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.62923', 1523, 4, '2024-11-18 10:30:28.62923', 224, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.630423', 1524, 4, '2024-11-18 10:30:28.630423', 224, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.781048', 1457, 4, '2024-11-18 10:10:51.781048', 211, '@GetMapping("/best")
    @Operation(summary = "프로젝트의 주간 Best MR 조회", description = "점수 가장 높은 상위 3개 항목 조회")
    public ApiResponse<List<GitlabMrQueryResponse>> getBestGitlabMergeRequests(
            @AuthUser User user, @RequestParam Long projectId) {
        List<GitlabMrQueryResponse> gitlabMrResponses =
                mergeRequestService.getBestMergeRequests(user.getId(), projectId);
        return ApiSuccessResponse.success(gitlabMrResponses);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.783424', 1458, 4, '2024-11-18 10:10:51.783424', 211, 'public List<GitlabMrQueryResponse> getBestMergeRequests(Long userId, Long projectId) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        List<MrInfo> mrInfoList = getTop3MrInfos(project);

        return gitLabClient.getTop3MrList(
                gitlabAccount.getDomain(),
                gitlabAccount.getUserToken(),
                project.getFullPath(),
                mrInfoList);
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.784886', 1459, 4, '2024-11-18 10:10:51.784886', 211, 'public GitlabMrPageResponse getGitlabMergeRequests(
            Long userId, Long projectId, GitlabMrPageRequest request) {
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        UserProject userProject =
                userProjectRepository.getByProjectAndGitlabAccount(project, gitlabAccount);

        GitlabMrPageContent gitlabMrPage =
                gitLabClient.searchGitlabMergeRequests(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        request,
                        userProject.getCreatedDate());

        List<GitlabMrResponse> gitlabMrResponses = buildGitlabMrResponses(gitlabMrPage);

        return GitlabMrPageResponse.of(gitlabMrResponses, gitlabMrPage.pageDetail());
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.786237', 1460, 4, '2024-11-18 10:10:51.786237', 211, '@GetMapping
    @Operation(summary = "프로젝트의 merge request 목록 조회", description = "키워드 검색 가능, 상태 필터, 페이지네이션 제공")
    public ApiResponse<GitlabMrPageResponse> getGitlabMergeRequests(
            @AuthUser User user,
            @RequestParam Long projectId,
            @RequestParam(defaultValue = "opened") String state,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam String keyword) {
        GitlabMrPageResponse gitlabMergeRequests =
                mergeRequestService.getGitlabMergeRequests(
                        user.getId(),
                        projectId,
                        new GitlabMrPageRequest(state, size, page, keyword));
        return ApiSuccessResponse.success(gitlabMergeRequests);
    }', 'MergeRequestController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.787663', 1461, 4, '2024-11-18 10:10:51.787663', 211, 'public List<GitlabMrQueryResponse> getTop3MrList(
            String gitlabUrl, String token, String fullPath, List<MrInfo> mrInfoList) {
        List<GitlabMrQueryResponse> top3MrList = new ArrayList<>();
        for (MrInfo mrInfo : mrInfoList) {
            GitlabMrQueryResponse singleMergeRequest =
                    GitlabMrQueryResponse.of(
                            getSingleMergeRequest(
                                    gitlabUrl, token, fullPath, mrInfo.getGitlabMrIid()),
                            false);
            top3MrList.add(singleMergeRequest);
        }
        return top3MrList;
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.789156', 1462, 4, '2024-11-18 10:10:51.789156', 211, '@Transactional
    public ReviewResponse getReviewList(Long userId, Long projectId, Long mergeRequestIid) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, mergeRequestIid);
        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(userId, projectId);
        Project project = projectRepository.getById(projectId);
        GitlabMrQueryResponse gitlabMrQueryContent =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mergeRequestIid),
                        true);
        List<ReviewDetailResponse> reviews =
                reviewRepository.findByMrInfoOrderByCreatedDateDesc(mrInfo).stream()
                        .map(ReviewDetailResponse::from)
                        .toList();
        return ReviewResponse.of(gitlabMrQueryContent, reviews);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.790604', 1463, 4, '2024-11-18 10:10:51.790604', 211, 'public List<String> getUsernameBestMergeRequests(Project project) {
        Long userId = project.getUserProjects().getFirst().getGitlabAccount().getUser().getId();
        List<GitlabMrQueryResponse> top3MrList = getBestMergeRequests(userId, project.getId());

        return top3MrList.stream().map(top -> top.assignee().username()).toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.791657', 1464, 4, '2024-11-18 10:10:51.791657', 211, 'public GitlabMrPageContent searchGitlabMergeRequests(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            GitlabMrPageRequest request,
            LocalDateTime createdAt) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url =
                GitLabApiUrlBuilder.createSearchMergeRequestUrl(
                        gitlabUrl, gitlabProjectId, request, createdAt.toString() + "09:00");
        ResponseEntity<List<GitlabMrDetailContent>> response =
                restTemplateUtil.sendGetRequest(
                        url, headers, new ParameterizedTypeReference<>() {});

        PageDetail pageDetail = createPageDetail(response.getHeaders());
        return new GitlabMrPageContent(response.getBody(), pageDetail);
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.792669', 1465, 4, '2024-11-18 10:10:51.792669', 211, 'private List<MrInfo> getTop3MrInfos(Project project) {
        LocalDate[] startAndEndDates =
                projectDateUtil.calculateWeekStartAndEndDates(
                        LocalDate.from(project.getCreatedDate()), LocalDate.now());
        List<MrInfo> mrInfoList =
                mrInfoRepository.findTop3MrInfoList(
                        project.getId(),
                        startAndEndDates[0].atTime(0, 0, 0),
                        startAndEndDates[1].atTime(0, 0, 0));
        return mrInfoList;
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:10:51.794102', 1466, 4, '2024-11-18 10:10:51.794102', 211, 'private List<GitlabMrResponse> buildGitlabMrResponses(GitlabMrPageContent gitlabMrPage) {
        return gitlabMrPage.gitlabMrDetailContents().stream()
                .map(this::createGitlabMrResponse)
                .toList();
    }', 'MergeRequestService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:47.97736', 1529, 4, '2024-11-18 11:21:47.97736', 238, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:47.979717', 1530, 4, '2024-11-18 11:21:47.979717', 238, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.227779', 1531, 4, '2024-11-18 11:21:48.227779', 239, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.22925', 1532, 4, '2024-11-18 11:21:48.22925', 239, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.017099', 1467, 4, '2024-11-18 10:18:16.017099', 212, '@PostMapping("/webhook/{projectId}")
    @Operation(summary = "Gitlab webhook 등록 시 사용")
    public ApiResponse<Void> handleGitlabEvent(
            @RequestHeader("X-Gitlab-Event") String gitlabEventType,
            @PathVariable("projectId") Long projectId,
            @RequestBody GitlabEventRequest gitlabEventRequest) {
        return switch (gitlabEventType) {
            case MERGE_REQUEST_TYPE -> {
                try {
                    gitlabEventHandler.handleMergeRequest(projectId, gitlabEventRequest);
                } catch (BusinessException e) {
                    yield ApiErrorResponse.error(e.getErrorCode());
                }
                yield ApiSuccessResponse.success();
            }
            case PUSH_REQUEST_TYPE -> {
                gitlabEventHandler.handlePush(projectId, gitlabEventRequest);
                yield ApiSuccessResponse.success();
            }
            default -> ApiErrorResponse.error(UNSUPPORTED_EVENT_TYPE);
        };
    }', 'GitlabWebhookController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.019419', 1468, 4, '2024-11-18 10:18:16.019419', 212, '@Test
    @DisplayName("올바른 Gitlab webhokk 요청")
    void givenValidMergeRequestHook_whenHandleGitlabEvent_thenReturnsSuccessResponse()
            throws JsonProcessingException {
        // given
        GitlabEventRequest gitlabEventRequest = GitlabEventRequestFixture.createOpenActionRequest();
        String requestBody = objectMapper.writeValueAsString(gitlabEventRequest);
        Long projectId = 1L;

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", projectId)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(requestBody)
                .exchange()
                // then
                .expectStatus()
                .isOk()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.SUCCESS);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.020897', 1469, 4, '2024-11-18 10:18:16.020897', 212, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.022128', 1470, 4, '2024-11-18 10:18:16.022128', 212, '@Async
    public void handleMergeRequest(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug(
                "#handle:: eventType: {}, action: {}",
                gitlabEventRequest.eventType(),
                gitlabEventRequest.objectAttributes().action());
        log.debug("gitlabEventRequest: {}", gitlabEventRequest);
        handlers.getOrDefault(
                        gitlabEventRequest.objectAttributes().action(),
                        (id, request) -> {
                            throw new BusinessException(ErrorCode.UNSUPPORTED_WEBHOOK_ACTION);
                        })
                .accept(projectId, gitlabEventRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.02332', 1471, 4, '2024-11-18 10:18:16.02332', 212, '@Test
    @DisplayName("request body가 빈 웹훅 요청")
    void givenInvalidEventType_whenHandleGitlabEvent_thenReturnsErrorResponse() {
        // given
        String requestBody = "{}"; // 잘못된 요청으로 빈 JSON을 전송

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Unsupported Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(requestBody)
                .exchange()
                // then
                .expectStatus()
                .isNotFound()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.024723', 1472, 4, '2024-11-18 10:18:16.024723', 212, 'private void handleOpen(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug("#handleOpen");
        // 1. 필요한 정보 추출
        String gitlabUrl = getGitlabUrl(gitlabEventRequest);
        Long gitlabProjectId = gitlabEventRequest.project().id();
        Long iid = gitlabEventRequest.objectAttributes().iid();
        String mrDescription = gitlabEventRequest.objectAttributes().description();
        String targetBranch = gitlabEventRequest.objectAttributes().targetBranch();
        LocalDateTime gitlabCreatedDate =
                gitlabEventRequest.objectAttributes().createdAt().toLocalDateTime();
        // 2. gitlab project token 찾기
        Project project = projectRepository.getById(projectId);
        String token = project.getBotToken();
        // 3. 리뷰 달기
        reviewCreateService.makeCodeReviewWhenCalledByWebhook(
                gitlabUrl,
                token,
                gitlabProjectId,
                iid,
                mrDescription,
                targetBranch,
                gitlabCreatedDate,
                projectId);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.025973', 1473, 4, '2024-11-18 10:18:16.025973', 212, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.424792', 1533, 4, '2024-11-18 11:21:48.424792', 240, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.426547', 1534, 4, '2024-11-18 11:21:48.426547', 240, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.027123', 1474, 4, '2024-11-18 10:18:16.027123', 212, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.028479', 1475, 4, '2024-11-18 10:18:16.028479', 212, 'public void addProjectWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            String webhookUrl,
            Map<String, Boolean> eventSettings) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createProjectWebhookUrl(gitlabUrl, gitlabProjectId);

        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("url", webhookUrl);
        requestBody.putAll(eventSettings);

        String body;
        try {
            body = objectMapper.writeValueAsString(requestBody);
        } catch (JsonProcessingException e) {
            throw new BusinessException(ErrorCode.GITLAB_REQUEST_SERIALIZATION_ERROR, e);
        }

        restTemplateUtil.sendPostRequest(url, headers, body, new ParameterizedTypeReference<>() {});
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.030194', 1476, 4, '2024-11-18 10:18:16.030194', 212, '@Test
    void handleOpenActionShouldInvokeHandleMergeRequestOpen() {
        // given
        Long projectId = 1L;
        GitlabEventRequest openActionRequest = GitlabEventRequestFixture.createOpenActionRequest();
        Project mockProject = ProjectFixture.createMockProject();
        given(projectRepository.getById(1L)).willReturn(mockProject);

        // when
        gitlabEventHandler.handleMergeRequest(projectId, openActionRequest);

        // then
        then(reviewService)
                .should()
                .makeCodeReviewWhenCalledByWebhook(
                        "gitlab.example.com",
                        mockProject.getBotToken(),
                        openActionRequest.project().id(),
                        openActionRequest.objectAttributes().iid(),
                        openActionRequest.objectAttributes().description(),
                        openActionRequest.objectAttributes().targetBranch(),
                        openActionRequest.objectAttributes().createdAt().toLocalDateTime(),
                        projectId);
    }', 'GitlabEventHandlerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.091301', 1477, 4, '2024-11-18 10:18:16.091301', 213, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.093571', 1478, 4, '2024-11-18 10:18:16.093571', 213, 'public static GitlabEventRequest createOpenActionRequest() {
        return new GitlabEventRequest(
                "merge_request",
                "merge_request",
                new Project(1L, "https://gitlab.example.com"),
                new ObjectAttributes(
                        99L,
                        1L,
                        "Sample MR",
                        "2023-10-10T10:00:00Z",
                        OffsetDateTime.parse("2023-10-10T12:00:00Z"),
                        OffsetDateTime.parse("2023-10-10T13:00:00Z"),
                        false,
                        "Description of MR",
                        "open"));
    }', 'GitlabEventRequestFixture.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.094881', 1479, 4, '2024-11-18 10:18:16.094881', 213, 'public static GitlabEventRequest createInvalidUrlRequest() {
        return new GitlabEventRequest(
                "merge_request",
                "merge_request",
                new Project(1L, "invalid-url"),
                new ObjectAttributes(
                        99L,
                        1L,
                        "Sample MR",
                        "2023-10-10T10:00:00Z",
                        OffsetDateTime.parse("2023-10-10T12:00:00Z"),
                        OffsetDateTime.parse("2023-10-10T13:00:00Z"),
                        false,
                        "Description of MR",
                        "open"));
    }', 'GitlabEventRequestFixture.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.096056', 1480, 4, '2024-11-18 10:18:16.096056', 213, '@Transactional
    public Project addProject(
            GitlabAccount gitlabAccount,
            Long gitlabProjectId,
            ProjectLinkRequest projectLinkRequest) {
        Project project = createAndSaveProject(gitlabAccount, gitlabProjectId, projectLinkRequest);
        saveBasicCustomPrompt(project);
        branchService.addBranches(projectLinkRequest, project);
        projectWebhookService.addGitlabProjectWebhooks(gitlabAccount.getDomain(), project);
        return project;
    }', 'ProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.097104', 1481, 4, '2024-11-18 10:18:16.097104', 213, 'public static GitlabEventRequest createUnsupportedActionRequest() {
        return new GitlabEventRequest(
                "merge_request",
                "merge_request",
                new Project(1L, "https://gitlab.example.com"),
                new ObjectAttributes(
                        99L,
                        1L,
                        "Sample MR",
                        "2023-10-10T10:00:00Z",
                        OffsetDateTime.parse("2023-10-10T12:00:00Z"),
                        OffsetDateTime.parse("2023-10-10T13:00:00Z"),
                        false,
                        "Description of MR",
                        "unsupported_action"));
    }', 'GitlabEventRequestFixture.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.585981', 1535, 4, '2024-11-18 11:21:48.585981', 241, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:48.587704', 1536, 4, '2024-11-18 11:21:48.587704', 241, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:55.921272', 1537, 4, '2024-11-18 11:21:55.921272', 242, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.09842', 1482, 4, '2024-11-18 10:18:16.09842', 213, '@Async
    public void handleMergeRequest(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug(
                "#handle:: eventType: {}, action: {}",
                gitlabEventRequest.eventType(),
                gitlabEventRequest.objectAttributes().action());
        log.debug("gitlabEventRequest: {}", gitlabEventRequest);
        handlers.getOrDefault(
                        gitlabEventRequest.objectAttributes().action(),
                        (id, request) -> {
                            throw new BusinessException(ErrorCode.UNSUPPORTED_WEBHOOK_ACTION);
                        })
                .accept(projectId, gitlabEventRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.099671', 1483, 4, '2024-11-18 10:18:16.099671', 213, '@Transactional
    public Long linkGitlabProject(
            User user, Long gitlabProjectId, ProjectLinkRequest projectLinkRequest) {
        GitlabAccount gitlabAccount = gitlabAccountRepository.getFirstByUserId(user.getId());
        Project project = getOrCreateProject(gitlabProjectId, projectLinkRequest, gitlabAccount);
        UserProject savedProject =
                userProjectRepository.save(
                        UserProject.builder()
                                .project(project)
                                .gitlabAccount(gitlabAccount)
                                .build());

        badgeEventService.eventProjectLinkAchievement(user);
        return savedProject.getId();
    }', 'UserProjectService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.100859', 1484, 4, '2024-11-18 10:18:16.100859', 213, 'public void addNoteToMr(
            String gitlabUrl, String token, Long gitlabProjectId, Long iid, String chatMessage) {
        HttpHeaders headers = makeGitlabHeaders(token);

        String url = GitLabApiUrlBuilder.createNoteToMRUrl(gitlabUrl, gitlabProjectId, iid);
        GitlabNoteRequest gitlabNoteRequest = new GitlabNoteRequest(chatMessage);
        String body;
        try {
            body = objectMapper.writeValueAsString(gitlabNoteRequest);
        } catch (JsonProcessingException e) {
            throw new BusinessException(ErrorCode.GITLAB_REQUEST_SERIALIZATION_ERROR, e);
        }
        restTemplateUtil.sendPostRequest(url, headers, body, new ParameterizedTypeReference<>() {});
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.101994', 1485, 4, '2024-11-18 10:18:16.101994', 213, 'private String getGitlabUrl(GitlabEventRequest gitlabEventRequest) {
        try {
            URI uri = new URI(gitlabEventRequest.project().webUrl());
            URL parsedUrl = uri.toURL();
            return parsedUrl.getHost();
        } catch (IllegalArgumentException | URISyntaxException | MalformedURLException e) {
            throw new BusinessException(ErrorCode.GITLAB_URL_PARSE_ERROR, e);
        }
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:16.103085', 1486, 4, '2024-11-18 10:18:16.103085', 213, 'private GitlabProjectResponse createGitlabProjectResponse(
            GitlabProjectSimpleContent content, Long gitlabAccountId) {
        return projectRepository
                .findByGitlabProjectId(GraphQlUtil.extractIdFromId(content.id()))
                .map(
                        project -> {
                            boolean isLinked = isProjectLinked(gitlabAccountId, project.getId());
                            return GitlabProjectResponse.ofLinkable(content, isLinked);
                        })
                .orElseGet(() -> GitlabProjectResponse.ofNonLinkable(content));
    }', 'GitlabApiService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.038746', 1497, 4, '2024-11-18 10:18:26.038746', 215, '@PostMapping("/webhook/{projectId}")
    @Operation(summary = "Gitlab webhook 등록 시 사용")
    public ApiResponse<Void> handleGitlabEvent(
            @RequestHeader("X-Gitlab-Event") String gitlabEventType,
            @PathVariable("projectId") Long projectId,
            @RequestBody GitlabEventRequest gitlabEventRequest) {
        return switch (gitlabEventType) {
            case MERGE_REQUEST_TYPE -> {
                try {
                    gitlabEventHandler.handleMergeRequest(projectId, gitlabEventRequest);
                } catch (BusinessException e) {
                    yield ApiErrorResponse.error(e.getErrorCode());
                }
                yield ApiSuccessResponse.success();
            }
            case PUSH_REQUEST_TYPE -> {
                gitlabEventHandler.handlePush(projectId, gitlabEventRequest);
                yield ApiSuccessResponse.success();
            }
            default -> ApiErrorResponse.error(UNSUPPORTED_EVENT_TYPE);
        };
    }', 'GitlabWebhookController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.040246', 1498, 4, '2024-11-18 10:18:26.040246', 215, '@Async
    public void handleMergeRequest(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug(
                "#handle:: eventType: {}, action: {}",
                gitlabEventRequest.eventType(),
                gitlabEventRequest.objectAttributes().action());
        log.debug("gitlabEventRequest: {}", gitlabEventRequest);
        handlers.getOrDefault(
                        gitlabEventRequest.objectAttributes().action(),
                        (id, request) -> {
                            throw new BusinessException(ErrorCode.UNSUPPORTED_WEBHOOK_ACTION);
                        })
                .accept(projectId, gitlabEventRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.041193', 1499, 4, '2024-11-18 10:18:26.041193', 215, '@Test
    @DisplayName("올바른 Gitlab webhokk 요청")
    void givenValidMergeRequestHook_whenHandleGitlabEvent_thenReturnsSuccessResponse()
            throws JsonProcessingException {
        // given
        GitlabEventRequest gitlabEventRequest = GitlabEventRequestFixture.createOpenActionRequest();
        String requestBody = objectMapper.writeValueAsString(gitlabEventRequest);
        Long projectId = 1L;

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", projectId)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(requestBody)
                .exchange()
                // then
                .expectStatus()
                .isOk()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.SUCCESS);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.042043', 1500, 4, '2024-11-18 10:18:26.042043', 215, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 11:21:55.922496', 1538, 4, '2024-11-18 11:21:55.922496', 242, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.743531', 1487, 4, '2024-11-18 10:18:18.743531', 214, '@Transactional
    public void handlePush(Long projectId, GitlabEventRequest gitlabEventRequest) {
        Project project = projectRepository.getById(projectId);
        String branchName = gitlabEventRequest.ref().replace("refs/heads/", "");
        Branch branch = branchRepository.getByNameAndProject(branchName, project);
        UpdateRequestMessage updateRequest =
                new UpdateRequestMessage(
                        project.getId(),
                        branch.getId(),
                        project.getGitUrl(),
                        branch.getName(),
                        project.getBotToken(),
                        "");
        redisGateway.sendUpdateRequest(updateRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.745195', 1488, 4, '2024-11-18 10:18:18.745195', 214, '@Test
    void handleOpenActionShouldInvokeHandleMergeRequestOpen() {
        // given
        Long projectId = 1L;
        GitlabEventRequest openActionRequest = GitlabEventRequestFixture.createOpenActionRequest();
        Project mockProject = ProjectFixture.createMockProject();
        given(projectRepository.getById(1L)).willReturn(mockProject);

        // when
        gitlabEventHandler.handleMergeRequest(projectId, openActionRequest);

        // then
        then(reviewService)
                .should()
                .makeCodeReviewWhenCalledByWebhook(
                        "gitlab.example.com",
                        mockProject.getBotToken(),
                        openActionRequest.project().id(),
                        openActionRequest.objectAttributes().iid(),
                        openActionRequest.objectAttributes().description(),
                        openActionRequest.objectAttributes().targetBranch(),
                        openActionRequest.objectAttributes().createdAt().toLocalDateTime(),
                        projectId);
    }', 'GitlabEventHandlerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.74632', 1489, 4, '2024-11-18 10:18:18.74632', 214, '@Async
    public void handleMergeRequest(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug(
                "#handle:: eventType: {}, action: {}",
                gitlabEventRequest.eventType(),
                gitlabEventRequest.objectAttributes().action());
        log.debug("gitlabEventRequest: {}", gitlabEventRequest);
        handlers.getOrDefault(
                        gitlabEventRequest.objectAttributes().action(),
                        (id, request) -> {
                            throw new BusinessException(ErrorCode.UNSUPPORTED_WEBHOOK_ACTION);
                        })
                .accept(projectId, gitlabEventRequest);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.747244', 1490, 4, '2024-11-18 10:18:18.747244', 214, 'private void handleOpen(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug("#handleOpen");
        // 1. 필요한 정보 추출
        String gitlabUrl = getGitlabUrl(gitlabEventRequest);
        Long gitlabProjectId = gitlabEventRequest.project().id();
        Long iid = gitlabEventRequest.objectAttributes().iid();
        String mrDescription = gitlabEventRequest.objectAttributes().description();
        String targetBranch = gitlabEventRequest.objectAttributes().targetBranch();
        LocalDateTime gitlabCreatedDate =
                gitlabEventRequest.objectAttributes().createdAt().toLocalDateTime();
        // 2. gitlab project token 찾기
        Project project = projectRepository.getById(projectId);
        String token = project.getBotToken();
        // 3. 리뷰 달기
        reviewCreateService.makeCodeReviewWhenCalledByWebhook(
                gitlabUrl,
                token,
                gitlabProjectId,
                iid,
                mrDescription,
                targetBranch,
                gitlabCreatedDate,
                projectId);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.748227', 1491, 4, '2024-11-18 10:18:18.748227', 214, '@BeforeEach
    void setUp() {
        gitlabEventHandler.initHandlers();
    }', 'GitlabEventHandlerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.749161', 1492, 4, '2024-11-18 10:18:18.749161', 214, 'public static GitlabEventRequest createOpenActionRequest() {
        return new GitlabEventRequest(
                "merge_request",
                "merge_request",
                new Project(1L, "https://gitlab.example.com"),
                new ObjectAttributes(
                        99L,
                        1L,
                        "Sample MR",
                        "2023-10-10T10:00:00Z",
                        OffsetDateTime.parse("2023-10-10T12:00:00Z"),
                        OffsetDateTime.parse("2023-10-10T13:00:00Z"),
                        false,
                        "Description of MR",
                        "open"));
    }', 'GitlabEventRequestFixture.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.750353', 1493, 4, '2024-11-18 10:18:18.750353', 214, '@PostMapping("/webhook/{projectId}")
    @Operation(summary = "Gitlab webhook 등록 시 사용")
    public ApiResponse<Void> handleGitlabEvent(
            @RequestHeader("X-Gitlab-Event") String gitlabEventType,
            @PathVariable("projectId") Long projectId,
            @RequestBody GitlabEventRequest gitlabEventRequest) {
        return switch (gitlabEventType) {
            case MERGE_REQUEST_TYPE -> {
                try {
                    gitlabEventHandler.handleMergeRequest(projectId, gitlabEventRequest);
                } catch (BusinessException e) {
                    yield ApiErrorResponse.error(e.getErrorCode());
                }
                yield ApiSuccessResponse.success();
            }
            case PUSH_REQUEST_TYPE -> {
                gitlabEventHandler.handlePush(projectId, gitlabEventRequest);
                yield ApiSuccessResponse.success();
            }
            default -> ApiErrorResponse.error(UNSUPPORTED_EVENT_TYPE);
        };
    }', 'GitlabWebhookController.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.751316', 1494, 4, '2024-11-18 10:18:18.751316', 214, '@Test
    @DisplayName("올바른 Gitlab webhokk 요청")
    void givenValidMergeRequestHook_whenHandleGitlabEvent_thenReturnsSuccessResponse()
            throws JsonProcessingException {
        // given
        GitlabEventRequest gitlabEventRequest = GitlabEventRequestFixture.createOpenActionRequest();
        String requestBody = objectMapper.writeValueAsString(gitlabEventRequest);
        Long projectId = 1L;

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", projectId)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(requestBody)
                .exchange()
                // then
                .expectStatus()
                .isOk()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.SUCCESS);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.752577', 1495, 4, '2024-11-18 10:18:18.752577', 214, '@Test
    void handleMergeRequestInvalidGitlabUrlShouldThrowBusinessException() {
        // given
        GitlabEventRequest invalidUrlRequest = GitlabEventRequestFixture.createInvalidUrlRequest();

        // when & then
        assertThrows(
                BusinessException.class,
                () -> gitlabEventHandler.handleMergeRequest(1L, invalidUrlRequest));
    }', 'GitlabEventHandlerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:18.753524', 1496, 4, '2024-11-18 10:18:18.753524', 214, '@Transactional
    public void regenerateReview(
            User user, Long projectId, Long gitlabMrIid, List<RetrievalContent> retrievals) {
        MrInfo mrInfo = mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid);
        Project project = mrInfo.getProject();

        GitlabAccount gitlabAccount =
                gitlabAccountRepository.getByUserIdAndProjectId(user.getId(), project.getId());

        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(
                        gitlabAccount.getDomain(),
                        gitlabAccount.getUserToken(),
                        project.getGitlabProjectId(),
                        mrInfo.getGitlabMrIid());

        GitlabMrQueryResponse gitlabMrResponse =
                GitlabMrQueryResponse.of(
                        gitLabClient.getSingleMergeRequest(
                                gitlabAccount.getDomain(),
                                gitlabAccount.getUserToken(),
                                project.getFullPath(),
                                mrInfo.getGitlabMrIid()),
                        true);

        CustomPrompt customPrompt = customPromptRepository.getByProjectId(project.getId());
        MrContent mrContent = new MrContent(gitlabMrResponse.description(), mrDiffs.toString());
        Branch branch =
                branchRepository.getByNameAndProject(gitlabMrResponse.targetBranch(), project);

        ReviewRegenerateRequestMessage regenerateRequest =
                new ReviewRegenerateRequestMessage(
                        project.getId(),
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabAccount.getDomain(),
                        retrievals.stream()
                                .map(
                                        retrieval ->
                                                new RetrievalMessage(
                                                        retrieval.content(),
                                                        retrieval.fileName(),
                                                        LanguageType.valueOf(retrieval.language())
                                                                .getType()))
                                .toList());

        badgeEventService.eventFirstAiReviewRegenerate(user);
        redisGateway.sendReviewRegenerateRequest(regenerateRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.112958', 1507, 4, '2024-11-18 10:30:27.112958', 216, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.114634', 1508, 4, '2024-11-18 10:30:27.114634', 216, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.432087', 1509, 4, '2024-11-18 10:30:27.432087', 217, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.433688', 1510, 4, '2024-11-18 10:30:27.433688', 217, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.806942', 1511, 4, '2024-11-18 10:30:27.806942', 218, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.808187', 1512, 4, '2024-11-18 10:30:27.808187', 218, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.126519', 1517, 4, '2024-11-18 10:30:28.126519', 221, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.128077', 1518, 4, '2024-11-18 10:30:28.128077', 221, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.409233', 1521, 4, '2024-11-18 10:30:28.409233', 223, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.410667', 1522, 4, '2024-11-18 10:30:28.410667', 223, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:30.530468', 1525, 4, '2024-11-18 10:30:30.530468', 225, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:30.531745', 1526, 4, '2024-11-18 10:30:30.531745', 225, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:36.73803', 1527, 4, '2024-11-18 10:30:36.73803', 226, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:36.739568', 1528, 4, '2024-11-18 10:30:36.739568', 226, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.042952', 1501, 4, '2024-11-18 10:18:26.042952', 215, 'private void handleOpen(Long projectId, GitlabEventRequest gitlabEventRequest) {
        log.debug("#handleOpen");
        // 1. 필요한 정보 추출
        String gitlabUrl = getGitlabUrl(gitlabEventRequest);
        Long gitlabProjectId = gitlabEventRequest.project().id();
        Long iid = gitlabEventRequest.objectAttributes().iid();
        String mrDescription = gitlabEventRequest.objectAttributes().description();
        String targetBranch = gitlabEventRequest.objectAttributes().targetBranch();
        LocalDateTime gitlabCreatedDate =
                gitlabEventRequest.objectAttributes().createdAt().toLocalDateTime();
        // 2. gitlab project token 찾기
        Project project = projectRepository.getById(projectId);
        String token = project.getBotToken();
        // 3. 리뷰 달기
        reviewCreateService.makeCodeReviewWhenCalledByWebhook(
                gitlabUrl,
                token,
                gitlabProjectId,
                iid,
                mrDescription,
                targetBranch,
                gitlabCreatedDate,
                projectId);
    }', 'GitlabEventHandler.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.043957', 1502, 4, '2024-11-18 10:18:26.043957', 215, '@Test
    @DisplayName("Gitlab Mr webhook 형신이 아닌 요청")
    void givenInvalidRequestBody_whenHandleGitlabEvent_thenReturnsSerializationError() {
        // given
        String invalidRequestBody = "{invalid json}"; // 잘못된 JSON 포맷

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Merge Request Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(invalidRequestBody)
                .exchange()
                // then
                .expectStatus()
                .is5xxServerError()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.045054', 1503, 4, '2024-11-18 10:18:26.045054', 215, '@Transactional
    public void makeCodeReviewWhenCalledByWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            Long iid,
            String mrDescription,
            String targetBranch,
            LocalDateTime gitlabCreatedDate,
            Long projectId) {
        log.debug("#makeCodeReviewWhenCalledByWebhook");
        // 1. MrInfo 저장
        Project project = projectRepository.getReferenceById(projectId);
        MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
        // 2. 변경사항가져오기
        List<GitlabMrDiffsContent> mrDiffs =
                gitLabClient.getMrDiffs(gitlabUrl, token, gitlabProjectId, iid);
        // 3. 커스텀프롬프트 가져오기
        CustomPrompt customPrompt = customPromptRepository.getByProjectId(projectId);
        // 4. projectId와 targetBranch로 브랜치 id 가져오기
        Branch branch = branchRepository.getByNameAndProject(targetBranch, project);
        // 5. 리뷰 생성 요청
        MrContent mrContent = new MrContent(mrDescription, mrDiffs.toString());
        ReviewRequestMessage reviewRequest =
                new ReviewRequestMessage(
                        projectId,
                        mrInfo.getId(),
                        branch.getId(),
                        mrContent,
                        customPrompt.getContent(),
                        gitlabUrl);
        redisGateway.sendReviewRequest(reviewRequest);
        // 6. 리뷰 평가 요청
        MrEvalRequestMessage evalRequest =
                new MrEvalRequestMessage(mrInfo.getId(), branch.getId(), mrContent);
        redisGateway.sendEvalRequest(evalRequest);
    }', 'ReviewService.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.046085', 1504, 4, '2024-11-18 10:18:26.046085', 215, '@Test
    void handleOpenActionShouldInvokeHandleMergeRequestOpen() {
        // given
        Long projectId = 1L;
        GitlabEventRequest openActionRequest = GitlabEventRequestFixture.createOpenActionRequest();
        Project mockProject = ProjectFixture.createMockProject();
        given(projectRepository.getById(1L)).willReturn(mockProject);

        // when
        gitlabEventHandler.handleMergeRequest(projectId, openActionRequest);

        // then
        then(reviewService)
                .should()
                .makeCodeReviewWhenCalledByWebhook(
                        "gitlab.example.com",
                        mockProject.getBotToken(),
                        openActionRequest.project().id(),
                        openActionRequest.objectAttributes().iid(),
                        openActionRequest.objectAttributes().description(),
                        openActionRequest.objectAttributes().targetBranch(),
                        openActionRequest.objectAttributes().createdAt().toLocalDateTime(),
                        projectId);
    }', 'GitlabEventHandlerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.047', 1505, 4, '2024-11-18 10:18:26.047', 215, '@Test
    @DisplayName("request body가 빈 웹훅 요청")
    void givenInvalidEventType_whenHandleGitlabEvent_thenReturnsErrorResponse() {
        // given
        String requestBody = "{}"; // 잘못된 요청으로 빈 JSON을 전송

        // when
        webTestClient
                .post()
                .uri("/webhook/{projectId}", 1L)
                .header("X-Gitlab-Event", "Unsupported Hook")
                .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
                .bodyValue(requestBody)
                .exchange()
                // then
                .expectStatus()
                .isNotFound()
                .expectBody(ApiResponse.class)
                .consumeWith(
                        response -> {
                            ApiResponse<?> apiResponse = response.getResponseBody();
                            assertNotNull(apiResponse);
                            assertEquals(apiResponse.getStatus(), ResponseStatus.ERROR);
                        });
    }', 'GitlabWebhookControllerTest.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:18:26.047902', 1506, 4, '2024-11-18 10:18:26.047902', 215, 'public void addProjectWebhook(
            String gitlabUrl,
            String token,
            Long gitlabProjectId,
            String webhookUrl,
            Map<String, Boolean> eventSettings) {
        HttpHeaders headers = makeGitlabHeaders(token);
        String url = GitLabApiUrlBuilder.createProjectWebhookUrl(gitlabUrl, gitlabProjectId);

        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("url", webhookUrl);
        requestBody.putAll(eventSettings);

        String body;
        try {
            body = objectMapper.writeValueAsString(requestBody);
        } catch (JsonProcessingException e) {
            throw new BusinessException(ErrorCode.GITLAB_REQUEST_SERIALIZATION_ERROR, e);
        }

        restTemplateUtil.sendPostRequest(url, headers, body, new ParameterizedTypeReference<>() {});
    }', 'GitLabClient.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.903561', 1513, 4, '2024-11-18 10:30:27.903561', 219, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:27.90514', 1514, 4, '2024-11-18 10:30:27.90514', 219, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.338947', 1519, 4, '2024-11-18 10:30:28.338947', 222, '@Test
	void contextLoads() {
	}', 'CofloApplicationTests.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 10:30:28.340331', 1520, 4, '2024-11-18 10:30:28.340331', 222, 'public static void main(String[] args) {
		SpringApplication.run(CofloApplication.class, args);
	}', 'CofloApplication.java');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.076811', 1539, 1, '2024-11-18 14:47:03.076811', 278, 'const MergeListPage = () => {
  const navigate = useNavigate();
  const itemsPerPage = 7;
  const [currentPage] = useAtom(currentPageAtom);
  const [, setTotalPages] = useAtom(totalPagesAtom);
  const [projectId] = useAtom(projectIdAtom);
  const [mergeRequests, setMergeRequests] = useState<GitlabMergeRequest[]>([]);
  const [currentStatus, setCurrentStatus] = useState(''opened'');
  const [searchKeyword, setSearchKeyword] = useState('''');
  const [, setSearchType] = useState(''All'');
  const [projectLabels, setProjectLabels] = useState<ProjectLabel[]>([]);

  const fetchMergeRequests = async () => {
    if (!projectId) return;

    // MR 리스트와 라벨 정보를 병렬로 조회
    const [mrResponse, labelsResponse] = await Promise.all([
      MergeRequest.getMrList(projectId, currentStatus, {
        keyword: searchKeyword,
        page: Number(currentPage),
        size: Number(itemsPerPage),
      }),
      ProjectRequest.getProjectLabels(projectId),
    ]);

    if (mrResponse.data) {
      setTotalPages(mrResponse.data.totalPages ?? 1);
      setMergeRequests(mrResponse.data.gitlabMrList);
    }

    if (labelsResponse.data) {
      setProjectLabels(labelsResponse.data.labels);
    }
  };

  const handleStatusChange = (status: string) => {
    setCurrentStatus(status);
  };

  const handleSearch = async (keyword: string, searchType: string) => {
    setSearchKeyword(keyword);
    setSearchType(searchType);

    if (!projectId) return;
    await fetchMergeRequests();
  };

  const handleItemClick = (iid: number) => {
    navigate(`/${projectId}/main/merge-request/reviews/${iid}`);
  };

  useEffect(() => {
    fetchMergeRequests();
  }, [projectId, currentStatus, currentPage]);

  return (
    <div className="h-full overflow-auto w-full">
      <div className="flex flex-col justify-between min-h-full p-6">
        <div className="flex flex-col gap-4">
          <MrStatusFilter onStatusChange={handleStatusChange} />
          <CustomSearchBar onSearch={handleSearch} showOption={false} />
        </div>

        <div className="flex-1 bg-white">
          <div className="pb-4 h-full">
            {mergeRequests.length === 0 ? (
              <EmptyMergeRequest />
            ) : (
              mergeRequests.map((mergeRequest) => (
                <div
                  key={mergeRequest.id}
                  onClick={() => handleItemClick(mergeRequest.iid)}
                  className="cursor-pointer"
                >
                  <MrItem mergeRequest={mergeRequest} projectLabels={projectLabels} />
                  <div className="border-1px border-gray-300" />
                </div>
              ))
            )}
          </div>
        </div>

        <Pagination />
      </div>
    </div>
  );
};', 'MergeListPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.084467', 1540, 1, '2024-11-18 14:47:03.084467', 278, 'const MergeRequestReviewPage = () => {
  const { id } = useParams<{ id: string }>();
  const [projectId] = useAtom(projectIdAtom);

  const [mergeRequest, setMergeRequest] = useState<GitlabMergeRequest | null>(null);
  const [reviews, setReviews] = useState<MergeRequestReview[''reviews'']>([]);
  const [references, setReferences] = useState<Reference[]>([]);
  const [selectedReviewId, setSelectedReviewId] = useState<string | null>(null);
  const [sendReviewId, setSendReviewId] = useState<string | null>(null);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string[]>([]);

  const fetchMergeRequest = async (projectId: string, mergeRequestIid: string) => {
    try {
      const response = await Review.getCodeReviewList(projectId, mergeRequestIid);
      const data = response.data;
      if (data) {
        setMergeRequest({ ...data.mergeRequest, gitlabMrDetailUrl: data.gitlabMrDetailUrl });
        setReviews(data.reviews);
      }
    } catch (error) {
      setIsAlertModalOpen(true);
      setAlertMessage([''리뷰가 아직 생성되지 않았습니다.'', ''잠시 후 시도해주세요.'']);
      console.error(error);
    }
  };

  useEffect(() => {
    if (!id || !projectId) return;

    fetchMergeRequest(projectId, id);
  }, [id, projectId]);

  useEffect(() => {
    if (!selectedReviewId) return;

    const fetchReferences = async (reviewId: string) => {
      const response = await Review.getReviewRetrievals(reviewId);

      const data = response.data;
      if (data) {
        setReferences(data);
      }
    };

    fetchReferences(selectedReviewId);
  }, [selectedReviewId]);

  useEffect(() => {
    if (reviews.length > 0 && !selectedReviewId) {
      setSelectedReviewId(String(Number(reviews[0].id)));
      setSendReviewId(String(Number(reviews[reviews.length - 1].id)));
    }
  }, [reviews, selectedReviewId]);

  if (!mergeRequest) return;

  const handleReviewClick = (reviewId: string) => {
    setSelectedReviewId(reviewId);
  };

  return (
    <div className="p-8 flex flex-col w-full overflow-auto items-center scroll-container">
      <div className="w-full border-b-[1px] border-background-bnavy">
        <MergeRequestHeader mergeRequest={mergeRequest} />
        <div className="flex gap-12 w-full">
          <ReviewList
            reviews={reviews}
            mergeRequest={mergeRequest}
            onReviewClick={handleReviewClick}
          />
          <ReferencesList
            references={references}
            selectedReviewId={selectedReviewId}
            sendReviewId={sendReviewId}
          />
        </div>
      </div>

      {isAlertModalOpen && (
        <AlertModal content={alertMessage} onConfirm={() => setIsAlertModalOpen(false)} />
      )}

      <ScrollNavigationButton />
    </div>
  );
};', 'MergeRequestReviewPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.086156', 1541, 1, '2024-11-18 14:47:03.086156', 278, 'const BestMergeRequestList = () => {
  const [bestMergeRequests, setBestMergeRequests] = useState<BestMergeRequest[]>([]);
  const navigate = useNavigate();
  const [projectId] = useAtom(projectIdAtom);

  useEffect(() => {
    if (!projectId) return;
    const fetchMergeRequests = async () => {
      const response = await MergeRequest.getBestMrList(projectId);
      const data = response.data;
      if (data) {
        setBestMergeRequests(data);
      }
    };

    fetchMergeRequests();
  }, [projectId]);

  const handleItemClick = (iid: number) => {
    navigate(`/${projectId}/main/merge-request/reviews/${iid}`);
  };

  return (
    <>
      <Title title="Best Merge Request" textSize="text-lg" />
      <div className="relative flex-grow bg-gray-400 border-2 border-gray-300 rounded-lg p-4">
        <div className="absolute top-3 right-7 text-right text-gray-700 font-semibold mb-4">
          {`${startOfWeek} ~ ${today}`}
        </div>
        {bestMergeRequests.length === 0 ? (
          <div className="w-full h-full flex flex-col items-center justify-center text-gray-700 text-lg">
            <p>아직 BEST MR이 없습니다.</p>
            <p>MR을 올려주세요.</p>
          </div>
        ) : (
          <div className="flex flex-col justify-around h-full overflow-y-auto p-4">
            {bestMergeRequests.map((mr) => (
              <div
                key={mr.id}
                className="flex justify-between items-center rounded-lg hover:bg-gray-200 cursor-pointer p-4"
                onClick={() => handleItemClick(mr.iid)}
              >
                <div className="flex flex-col min-w-0 flex-1 space-y-3">
                  <div className="flex items-center gap-2">
                    <div className="flex -space-x-2 flex-shrink-0">
                      {mr.assignee?.avatarUrl && (
                        <img
                          src={mr.assignee.avatarUrl}
                          alt="Assignee"
                          className="w-8 h-8 rounded-full border-2 border-white bg-white shadow-sm"
                        />
                      )}
                      {mr.reviewer?.avatarUrl && (
                        <img
                          src={mr.reviewer.avatarUrl}
                          alt="Reviewer"
                          className="w-8 h-8 rounded-full border-2 border-white bg-white shadow-sm z-10"
                        />
                      )}
                    </div>
                    <div className="flex items-center min-w-0 flex-1">
                      <PullRequestIcon className="w-5 h-5 flex-shrink-0 mr-2" />
                      <span className="font-bold text-sm mr-3">{mr.targetBranch}</span>
                      <span className="text-base font-medium text-gray-700 truncate">
                        {mr.title}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center mt-1 space-x-3">
                    <div className="flex space-x-1">
                      {mr.labels.nodes.slice(0, 2).map((label, index) => (
                        <span
                          key={index}
                          className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium text-white"
                          style={{ backgroundColor: label.color }}
                        >
                          {label.title}
                        </span>
                      ))}
                    </div>
                    {mr.assignee && (
                      <span className="text-sm text-gray-700 ml-2 flex-shrink-0">
                        created {mr.closedAt} by {mr.assignee.username}
                      </span>
                    )}
                  </div>
                </div>
                <div className="font-extrabold text-xl">→</div>
              </div>
            ))}
          </div>
        )}
      </div>
    </>
  );
};', 'BestMergeRequestList.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.087684', 1542, 1, '2024-11-18 14:47:03.087684', 278, 'const LandingPage = () => {
  const navigate = useNavigate();

  return (
    <div className="min-h-screen bg-white">
      {/* Navigation */}
      <nav className="border-b">
        <div className="container mx-auto px-6 py-4">
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <GitMerge className="w-8 h-8 text-primary-500" />
              <span className="text-xl font-bold">coFlo</span>
            </div>
          </div>
        </div>
      </nav>

      {/* Hero Section */}
      <section className="py-20">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <h1 className="text-4xl md:text-5xl font-bold mb-6">
              더 나은 코드를 위한 AI 코드 리뷰
            </h1>
            <p className="text-xl text-secondary">
              프로젝트의 맥락을 이해하고 팀의 코딩 스타일을 반영하는
            </p>
            <p className="text-xl text-secondary mb-8">
              맞춤형 코드 리뷰로 개발 생산성을 높이세요.
            </p>
            <button
              className="bg-primary-500 text-white px-8 py-4 rounded-full text-lg 
              hover:bg-primary-600 transition-colors inline-flex items-center gap-2"
              onClick={() => navigate(''/login'')}
            >
              시작하기
              <ArrowRight className="w-5 h-5" />
            </button>
          </div>
          <ReviewDemo />
        </div>
      </section>

      {/* Features Section */}
      <section className="py-20 bg-gray-50">
        <div className="container mx-auto px-6">
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-12">
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <GitBranch className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">Git 자동 연동</h3>
              <p className="text-secondary">
                웹훅 설정만으로 Merge Request가 생성될 때마다 자동으로 리뷰가 시작됩니다.
              </p>
            </div>
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <Search className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">컨텍스트 기반 분석</h3>
              <p className="text-secondary">
                이슈와 MR 히스토리를 분석하여 프로젝트의 맥락을 이해하고 더 정확한 리뷰를
                제공합니다.
              </p>
            </div>
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <Zap className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">맞춤형 리뷰</h3>
              <p className="text-secondary">
                팀의 코딩 스타일과 컨벤션을 반영한 커스텀 템플릿으로 일관된 품질의 리뷰를
                받아보세요.
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* How it Works */}
      <section className="py-20">
        <div className="container mx-auto px-6">
          <h2 className="text-3xl font-bold text-center mb-16">3단계로 시작하는 AI 코드 리뷰</h2>
          <div className="grid md:grid-cols-3 gap-8 max-w-4xl mx-auto">
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                1
              </div>
              <h3 className="font-semibold mb-2">Git 연동</h3>
              <p className="text-secondary">프로젝트에 웹훅을 설정하여 coFlo와 연결하세요</p>
            </div>
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                2
              </div>
              <h3 className="font-semibold mb-2">템플릿 설정</h3>
              <p className="text-secondary">팀의 코딩 스타일에 맞는 리뷰 템플릿을 설정하세요</p>
            </div>
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                3
              </div>
              <h3 className="font-semibold mb-2">자동 리뷰</h3>
              <p className="text-secondary">MR이 생성되면 자동으로 AI 코드 리뷰가 시작됩니다</p>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="bg-gray-50 py-20">
        <div className="container mx-auto px-6 text-center">
          <h2 className="text-3xl font-bold mb-8">지금 바로 AI 코드 리뷰를 시작하세요</h2>
          <p className="text-xl text-secondary mb-8 max-w-2xl mx-auto">
            설치 없이 GitLab 연동만으로 바로 사용할 수 있습니다.
          </p>
          <button
            className="bg-primary-500 text-white px-8 py-4 rounded-full text-lg 
            hover:bg-primary-600 transition-colors inline-flex items-center gap-2"
            onClick={() => navigate(''/login'')}
          >
            시작하기
            <ArrowRight className="w-5 h-5" />
          </button>
        </div>
      </section>
    </div>
  );
};', 'LandingPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.089636', 1543, 1, '2024-11-18 14:47:03.089636', 278, 'const SignupForm = () => {
  const navigate = useNavigate();
  const [domain, setDomain] = useState(''lab.ssafy.com'');
  const [userToken, setUserToken] = useState('''');
  const [isTokenValid, setIsTokenValid] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string[]>([]);
  const isSignupEnabled = isTokenValid && domain;

  const handleValidateToken = async () => {
    if (!userToken) return;

    setIsValidating(true);
    try {
      const response = await Gitlab.validateUserToken({
        domain,
        userToken,
      });
      const isValid = response.data;
      if (isValid) {
        setIsTokenValid(isValid);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효한 토큰입니다.'', ''회원가입을 진행해주세요.'']);
      } else {
        setIsTokenValid(false);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효하지 않은 토큰입니다.'', ''다시 한 번 입력해주세요.'']);
      }
    } catch (error) {
      setIsTokenValid(false);
    } finally {
      setIsValidating(false);
    }
  };

  const handleSignup = async () => {
    if (!isSignupEnabled) return;

    try {
      const response = await User.addGitlabAccount({
        domain,
        userToken,
      });

      if (response.status === ''SUCCESS'') {
        navigate(''/repository'');
      }
    } catch (error) {
      console.error(''회원가입 실패'', error);
      setIsAlertModalOpen(true);
      setAlertMessage([''회원가입에 실패했습니다.'', ''다시 시도해주세요.'']);
    }
  };

  return (
    <div className="relative min-w-[520px]">
      {/* 블러 효과 배경 */}
      <div className="absolute inset-0 backdrop-blur-md rounded-3xl"></div>

      {/* SignupForm 콘텐츠 */}
      <div className="bg-white/50 rounded-3xl p-10 py-20 relative z-10 font-pretendard border-2 border-primary-500">
        <div className="text-5xl font-bold mb-10 mt-20">회원 가입</div>
        <form>
          <div className="space-y-14">
            <div className="flex flex-col space-y-10">
              <div className="h-28">
                <GitUrlSelector
                  value={domain}
                  onChange={setDomain}
                  labelText="가져올 Git 서비스 URL을 선택해주세요."
                />
              </div>
              <div className="relative h-28">
                <TokenInput
                  value={userToken}
                  onChange={(value) => setUserToken(value)}
                  onValidate={handleValidateToken}
                  isValidating={isValidating}
                  isValid={isTokenValid}
                  labelText="사용자 인증 토큰을 입력해주세요."
                  placeholder="Enter your user access token"
                  warningMessage="검증하기 버튼을 눌러 토큰을 검증해주세요."
                />
                <div
                  className="flex items-center text-sm text-secondary mt-1 cursor-pointer"
                  onClick={() => setIsModalOpen(true)}
                >
                  <Info size={16} />
                  <span className="ml-1 text-xl">사용자 인증 토큰 안내</span>
                </div>
              </div>
            </div>
          </div>
        </form>

        <GuideModal
          isOpen={isModalOpen}
          width="w-[400px]"
          title="사용자 인증 토큰 안내"
          content={
            <div className="text-center text-xl font-bold text-primary-500">
              아바타 프로필 클릭 &gt; Edit Profile &gt; Access Tokens &gt; Add new token
            </div>
          }
          onClose={() => setIsModalOpen(false)}
          image={{
            src: ''/images/guide/guide_personal_access_token.png'',
            alt: ''personal_access_token'',
          }}
          links={[
            {
              url: `https://${domain}`,
              text: ''토큰 가지러 가기'',
              icon: <Link size={20} className="text-primary-500" />,
            },
            {
              url: ''https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html'',
              text: ''인증 토큰 발급 관련 도움말'',
              icon: <FileQuestion size={20} className="text-primary-500" />,
            },
          ]}
        />

        {isAlertModalOpen && (
          <AlertModal
            content={alertMessage}
            onConfirm={() => setIsAlertModalOpen(false)}
            icon={isTokenValid ? CircleCheck : TriangleAlert}
            iconClassName={isTokenValid ? ''text-state-success'' : ''text-state-warning''}
          />
        )}

        <div className="flex justify-center mt-20 cursor-pointer">
          <CommonButton
            className="w-36 h-14 text-xl text-white"
            disabled={!isSignupEnabled}
            onClick={handleSignup}
          >
            가입하기
          </CommonButton>
        </div>
      </div>
    </div>
  );
};', 'SignupForm.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.092699', 1544, 1, '2024-11-18 14:47:03.092699', 278, 'function MrItem({ mergeRequest, projectLabels }: MrItemProps) {
  const {
    title,
    // state,
    assignee,
    reviewer,
    createdAt,
    updatedAt,
    // sourceBranch,
    targetBranch,
    // description,
    labels,
  } = mergeRequest;

  const createTimeAgo = useTimeAgo(createdAt);
  const updateTimeAgo = useTimeAgo(updatedAt);

  return (
    <div className="pt-5 pb-5 p-2 w-full min-w-[1000px] border-b border-gray-300 font-pretendard">
      <div className="flex flex-row justify-between ">
        <h2 className="text-lg font-semibold">{title}</h2>
      </div>
      <div className="flex flex-row justify-between mt-1">
        <div className="flex items-center">
          <span className="text-xs mr-1">created {createTimeAgo} </span>
          {assignee ? (
            <>
              <span className="text-xs mr-3"> by {assignee.username}</span>
            </>
          ) : (
            <span className="text-xs text-gray-500 mr-3"></span>
          )}
          <PullRequestIcon className="w-3 h-3 flex-shrink-0 mr-1" />
          <span className="text-xs font-bold mr-1">{targetBranch}</span>
        </div>
        <div className="flex items-center">
          {assignee ? (
            <>
              <Tooltip text={`Assigned to ${assignee.username}`}>
                <img
                  src={assignee.avatarUrl}
                  alt={`${assignee.username}의 아바타`}
                  className="w-5 h-5 rounded-full mr-1 cursor-pointer"
                />
              </Tooltip>
            </>
          ) : (
            <span className="text-xs text-gray-500"></span>
          )}
          {reviewer ? (
            <>
              <Tooltip text={`Review requested from ${reviewer.username}`}>
                <img
                  src={reviewer.avatarUrl}
                  alt={`${reviewer.username}의 아바타`}
                  className="w-5 h-5 rounded-full mr-1 cursor-pointer"
                />
              </Tooltip>
            </>
          ) : (
            <span className="text-xs text-gray-500"></span>
          )}
        </div>
      </div>
      <div className="mt-2 text-xs text-gray-600 flex justify-between">
        <div>
          <LabelList labels={labels} projectLabels={projectLabels} />
        </div>
        <div className="text-xs mr-1">
          <span>updated {updateTimeAgo}</span>
        </div>
      </div>
    </div>
  );
}', 'MrItem.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.094526', 1545, 1, '2024-11-18 14:47:03.094526', 278, 'function RepositoryPage() {
  const [repositories, setRepositories] = useState<GitlabProject[]>([]);
  const [selectedBranches, setSelectedBranches] = useState<BranchOption[]>([]);
  const [selectedRepo, setSelectedRepo] = useState<GitlabProject | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [inputValue, setInputValue] = useState('''');
  const navigate = useNavigate();
  const [, setProjectId] = useAtom(projectIdAtom);
  const [, setProjectFullPath] = useAtom(projectFullPathAtom);
  const [pageInfo, setPageInfo] = useState<PageInfo>({
    startCursor: '''',
    endCursor: '''',
    hasNextPage: false,
    hasPreviousPage: false,
  });
  const [keyword, setKeyword] = useState('''');
  const size = 10;

  const fetchProjects = async (cursor?: { startCursor?: string; endCursor?: string }) => {
    const response = await Gitlab.getGitlabProjects(keyword, size, cursor);
    if (response && response.data) {
      setRepositories(response.data.gitlabProjectList);
      setPageInfo(response.data.pageInfo);
    }
  };

  useEffect(() => {
    fetchProjects();
  }, [keyword]);

  const handleNextPage = async () => {
    if (pageInfo.hasNextPage) {
      fetchProjects({ endCursor: pageInfo.endCursor });
    }
  };

  const handlePreviousPage = async () => {
    if (pageInfo.hasPreviousPage) {
      fetchProjects({ startCursor: pageInfo.startCursor });
    }
  };

  const handleInputChange = (value: string) => {
    setInputValue(value);
  };

  const handleToggleChange = async (index: number) => {
    const repo = repositories[index];

    if (repo.isLinkable) {
      if (repo.isLinked) {
        await UserProject.deleteRepository(repo.gitlabProjectId);
        setRepositories((prev) => {
          const updatedRepos = [...prev];
          updatedRepos[index] = { ...updatedRepos[index], isLinked: false };
          return updatedRepos;
        });
      } else {
        await UserProject.updateRepository(repo.gitlabProjectId, {});
        setRepositories((prev) => {
          const updatedRepos = [...prev];
          updatedRepos[index] = { ...updatedRepos[index], isLinked: true };
          return updatedRepos;
        });
      }
    } else {
      setSelectedRepo(repo);
      setIsModalOpen(true);
    }
  };

  const handleModalConfirm = async () => {
    if (selectedRepo) {
      const branchNames = selectedBranches.map((branch) => branch.value);

      await UserProject.updateRepository(selectedRepo.gitlabProjectId, {
        botToken: inputValue,
        branches: branchNames,
      });

      setRepositories((prev) => {
        const updatedRepos = [...prev];
        const index = repositories.findIndex(
          (repo) => repo.gitlabProjectId === selectedRepo.gitlabProjectId,
        );
        updatedRepos[index] = { ...updatedRepos[index], isLinked: true, isLinkable: true };
        return updatedRepos;
      });

      setIsModalOpen(false);
      setSelectedRepo(null);
      setInputValue('''');
      setSelectedBranches([]);
    }
  };

  const handleSearch = (searchKeyword: string) => {
    setKeyword(searchKeyword);
    setPageInfo({
      startCursor: '''',
      endCursor: '''',
      hasNextPage: false,
      hasPreviousPage: false,
    });
  };

  const handleButtonClick = async () => {
    const response = await UserProject.getLinkStatus();
    if (response?.data) {
      const { hasLinkedProject, projectId, projectFullPath } = response.data;
      setProjectId(projectId);
      setProjectFullPath(projectFullPath);
      if (hasLinkedProject) {
        navigate(`/${projectId}/main`);
      } else {
        alert(''연동되지 않았습니다. 먼저 연동을 완료해주세요.'');
      }
    }
  };

  return (
    <div className="flex flex-col ml-[80px] p-6 w-full justify-between overflow-auto">
      <div>
        <div className="flex flex-row justify-between items-center pr-3">
          <div>
            <Header
              title="Repository"
              description={[''내 프로젝트에서 리뷰할 프로젝트를 선택합니다.'']}
            />
          </div>
          <CommonButton
            className="px-4 min-w-[100px] h-[50px] text-white"
            active={false}
            bgColor="bg-primary-500"
            onClick={handleButtonClick}
          >
            시작하기
          </CommonButton>
        </div>
        <CustomSearchBar onSearch={handleSearch} showOption={false} width="pl-3 min-w-[400px]" />
      </div>

      <div className="flex flex-col flex-grow overflow-auto bg-white w-full min-w-[400px] justify-start">
        {repositories.length > 0 ? (
          repositories.map((repo, index) => (
            <div key={repo.gitlabProjectId}>
              <div className="flex items-center justify-between py-[22px] px-6">
                <RepositoryItem
                  name={repo.name}
                  integrate={repo.isLinkable ? '''' : ''프로젝트 토큰을 설정해주세요''}
                />
                <ToggleSwitch checked={repo.isLinked} onChange={() => handleToggleChange(index)} />
              </div>
              {index < repositories.length - 1 && <div className="border-t border-gray-300" />}
            </div>
          ))
        ) : (
          <div className="flex flex-col items-center justify-center h-full">
            <SearchX size={100} className="text-primary-500" />
            <div className="text-center text-primary-500 text-3xl font-bold mt-6">
              검색 결과가 없습니다.
            </div>
          </div>
        )}
      </div>

      {isModalOpen && selectedRepo && (
        <GuideModal
          isOpen={isModalOpen}
          title="프로젝트 토큰을 얻어오는 방법"
          width="w-[600px]"
          content={
            <div className="space-y-2">
              <p>1. 버튼을 클릭하여 프로젝트 검색을 시작하세요.</p>
              <p>2. 설정(Settings)으로 이동 후 Access Tokens 메뉴를 선택하세요.</p>
              <p>3. API 체크 후 Project Access Tokens를 생성하세요.</p>
            </div>
          }
          contentBottom={
            <div className="mt-4">
              <label className="block mb-2 text-2xl">참조할 브랜치</label>
              <BranchSelector
                value={selectedBranches}
                onChange={setSelectedBranches}
                gitlabProjectId={Number(selectedRepo?.gitlabProjectId)}
              />
            </div>
          }
          image={{
            src: tokenintro,
            alt: ''Project Token Instructions'',
          }}
          hasInput
          inputProps={{
            value: inputValue,
            onChange: handleInputChange,
            placeholder: ''프로젝트 토큰을 입력하세요'',
            labelText: ''프로젝트 토큰'',
          }}
          links={[
            {
              url: ''https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html'',
              text: ''프로젝트 토큰 생성 가이드 보기'',
              icon: <FileQuestion size={20} className="text-primary-500" />,
            },
          ]}
          onClose={() => {
            setIsModalOpen(false);
            setSelectedRepo(null);
            setInputValue('''');
            setSelectedBranches([]);
          }}
          onConfirm={handleModalConfirm}
          gitlabProjectId={String(selectedRepo.gitlabProjectId)}
        ></GuideModal>
      )}

      {/* <MemoizedPagination /> */}
      <CursorPagination
        hasNextPage={pageInfo.hasNextPage}
        hasPreviousPage={pageInfo.hasPreviousPage}
        onNext={handleNextPage}
        onPrevious={handlePreviousPage}
      />
    </div>
  );
}', 'RepositoryPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.096644', 1546, 1, '2024-11-18 14:47:03.096644', 278, 'const HomePage = () => {
  const navigate = useNavigate();
  const initialProjectDetail = {
    programmingLanguagesData: null,
    commitCount: 0,
    branchCount: 0,
    mergeRequestCount: 0,
    aiReviewCount: 0,
  };
  const initialRadarData: RadarData = {
    labels: [],
    datasets: [],
  };
  const [, setContainerHeight] = useState<number>(0);
  const [startDate, setStartDate] = useState<string | null>(null);
  const [endDate, setEndDate] = useState<string | null>(null);
  const [radarData, setRadarData] = useState<RadarData | null>(initialRadarData);
  const [profileIcons, setProfileIcons] = useState<Record<number, string>>({});
  const [badgeIcons, setBadgeIcons] = useState<Record<number, string>>({});
  const [selectedChart, setSelectedChart] = useState<string>(''획득 통합 스코어'');
  const [, setSelectedOption] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [lineData, setLineData] = useState({
    labels: [],
    datasets: [],
  });

  const [cubicLineData, setCubicLineData] = useState({
    labels: [],
    datasets: [],
  });

  const [maxValue, setMaxValue] = useState<number>(0);
  const [minValue, setMinValue] = useState<number>(100);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const [projectDetail, setProjectDetail] = useState<{
    programmingLanguagesData: ProgrammingLanguagesData | null;
    commitCount: number;
    branchCount: number;
    mergeRequestCount: number;
    aiReviewCount: number;
  }>(initialProjectDetail);
  const [projectId] = useAtom(projectIdAtom);

  const handleSelect = (chart: string) => {
    setSelectedChart(chart);
  };

  useEffect(() => {
    if (!projectId) {
      setIsLoading(false);
      return;
    }

    const loadProjectData = async () => {
      setIsLoading(false);
    };

    loadProjectData();
  }, [projectId]);

  useEffect(() => {
    if (!isLoading && !projectId) {
      navigate(''/repository'');
    }
  }, [isLoading, projectId, navigate]);

  useEffect(() => {
    let calculationType = ''acquisition'';
    let scoreDisplayType = ''total'';

    switch (selectedChart) {
      case ''획득 통합 스코어'':
        calculationType = ''acquisition'';
        scoreDisplayType = ''total'';
        break;
      case ''획득 개별 스코어'':
        calculationType = ''acquisition'';
        scoreDisplayType = ''individual'';
        break;
      case ''누적 통합 스코어'':
        calculationType = ''cumulative'';
        scoreDisplayType = ''total'';
        break;
      case ''누적 개별 스코어'':
        calculationType = ''cumulative'';
        scoreDisplayType = ''individual'';
        break;
      default:
        break;
    }

    const queryParams = {
      calculationType,
      scoreDisplayType,
    };

    const fetchData = async () => {
      if (!projectId) {
        return;
      }
      const {
        lineData: fetchedLineData,
        cubicLineData: fetchedCubicLineData,
        maxScore,
        minScore,
        startDate: fetchedStartDate,
        endDate: fetchedEndDate,
      } = await loadChartData(projectId, selectedChart, queryParams);

      if (fetchedLineData) {
        setLineData(fetchedLineData);
      }

      if (fetchedCubicLineData) {
        setCubicLineData(fetchedCubicLineData);
      }

      setMaxValue(maxScore);
      setMinValue(minScore);

      // Set the start and end date
      setStartDate(fetchedStartDate);
      setEndDate(fetchedEndDate);
    };

    fetchData();
  }, [selectedChart, projectId]);

  useEffect(() => {
    if (!projectId) return;
    const loadProjectData = async () => {
      const langauageData = await fetchProjectDetail(projectId);

      const teamScoreData = await fetchProjectTeamScore(projectId);

      setProjectDetail(langauageData || initialProjectDetail);
      if (teamScoreData) {
        setRadarData(teamScoreData.radarData);
        setProfileIcons(teamScoreData.profileIcons);
        setBadgeIcons(teamScoreData.badgeIcons);
      }
    };

    loadProjectData();
  }, [projectId]);

  useEffect(() => {
    if (containerRef.current) {
      setContainerHeight(containerRef.current.clientHeight);
    }
  }, []);

  return (
    <div className="flex flex-col flex-grow p-4 gap-8 min-w-[1000px] max-w-[2000px] overflow-auto">
      {/* 첫 번째 행 */}
      <div className="flex flex-row min-h-[500px] gap-4">
        {/* Team Radar Charts - 3/5 너비 */}
        <div className="flex flex-col flex-[3] min-w-[570px]">
          <Title title="Team Radar Charts" textSize="text-lg" />

          <div
            ref={containerRef}
            className="relative flex-grow bg-gray-400 border-2 border-gray-300 rounded-lg flex items-center justify-center p-4"
          >
            <div className="absolute top-3 right-7 text-right text-gray-700 font-semibold mb-4">
              {`${monday} ~ ${sunday}`}
            </div>
            <ChartBox
              chartType="radar"
              data={radarData}
              options={createRadarOptions()}
              chartId="radarChart"
              width="500px"
              height="300px"
              profileIcons={profileIcons}
              badgeIcons={badgeIcons}
            />
          </div>
        </div>
        {/* Project Total - 2/5 너비 */}
        <div className="flex flex-col flex-[2] min-w-[380px]">
          <Title title="Project Total" textSize="text-lg" />
          <div className="flex flex-col flex-grow justify-between p-4 bg-gray-400 border-2 border-gray-300 rounded-lg">
            <Title title="About" textSize="text-xl" />
            <Title title="Language" textSize="text-lg" py="py-1" />
            <div className="mx-4">
              {projectDetail.programmingLanguagesData &&
              projectDetail.programmingLanguagesData.labels ? (
                <ChartBox
                  chartType="bar"
                  data={projectDetail.programmingLanguagesData}
                  options={createHorizontalBarOptions([0, 100])}
                  chartId="horizontalBarChart"
                  width="100%"
                  height="60px"
                />
              ) : (
                <p className="text-center">No Chart</p>
              )}
            </div>
            <div className="h-5 px-2 w-full flex flex-col justify-center">
              <div className="bg-gray-600 h-[1px] w-full"></div>
            </div>
            <div className="flex flex-col space-y-5 py-5">
              <Title title="Info" textSize="text-lg" py="py-1" />
              <div className="flex flex-col space-y-5 items-center justify-center">
                <div className="flex flex-row justify-around gap-4">
                  <IconWithText
                    svg={<CommitIcon />}
                    text="commits"
                    count={projectDetail.commitCount}
                  />
                  <IconWithText
                    svg={<BranchIcon className="w-4 h-4" />}
                    text="branches"
                    count={projectDetail.branchCount}
                  />
                </div>
                <div className="flex flex-row justify-around gap-4">
                  <IconWithText
                    svg={<PullRequestIcon className="w-4 h-4" />}
                    text="MRs"
                    count={projectDetail.mergeRequestCount}
                  />
                  <IconWithText
                    svg={<AiIcon />}
                    text="Ai reviews"
                    count={projectDetail.aiReviewCount}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* 두 번째 행 */}
      <div className="flex flex-row min-h-[450px] gap-4 mb-4">
        {/* Personal Growth Graph - 3/5 너비 */}
        <div className="flex flex-col flex-[3] min-w-[570px]">
          <div className="flex flex-row justify-between items-center">
            <Title title="Personal Growth Graph" textSize="text-lg" />
            <ChartDropdown
              onSelect={(option) => {
                handleSelect(option);
                setSelectedOption(option);
              }}
            />
          </div>
          <div className="relative flex-grow bg-gray-400 border-2 border-gray-300 rounded-lg items-center justify-center pt-10">
            <div className="absolute top-3 right-7 text-right text-gray-700 font-semibold mb-4">
              {`${startDate} ~ ${endDate}`}
            </div>
            {selectedChart === ''획득 통합 스코어'' && (
              <ChartBox
                chartType="line"
                data={cubicLineData}
                options={createLineOptions([0, 70])}
                chartId="lineChart"
                height="330px"
              />
            )}
            {selectedChart === ''획득 개별 스코어'' && (
              <ChartBox
                chartType="line"
                data={lineData}
                options={createLineOptions([0, 11])}
                chartId="cubicLineChart"
                height="330px"
              />
            )}
            {selectedChart === ''누적 통합 스코어'' && (
              <ChartBox
                chartType="line"
                data={cubicLineData}
                options={createCubicLineOptions([minValue, maxValue])}
                chartId="cumulativeLineChart"
                height="330px"
              />
            )}
            {selectedChart === ''누적 개별 스코어'' && (
              <ChartBox
                chartType="line"
                data={lineData}
                options={createCubicLineOptions([minValue, maxValue])}
                chartId="cumulativeCubicLineChart"
                height="330px"
              />
            )}
          </div>
        </div>
        {/* Best Merge Request - 2/5 너비 */}
        <div className="flex flex-col flex-[2] min-w-[380px]">
          <BestMergeRequestList />
        </div>
      </div>
    </div>
  );
};', 'HomePage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.09828', 1547, 1, '2024-11-18 14:47:03.09828', 278, 'const MergeRequestHeader = ({ mergeRequest }: { mergeRequest: GitlabMergeRequest }) => {
  const getStatusIcon = (state: GitlabMergeRequest[''state'']) => {
    switch (state) {
      case ''opened'':
        return <PullRequestIcon className="w-4 h-4" />;
      case ''merged'':
        return <BranchIcon className="w-4 h-4" />;
      case ''closed'':
        return <GitPullRequestClosed className="w-4 h-4" />;
    }
  };

  return (
    <div className="flex flex-row justify-between items-center border-b-[1px] border-background-bnavy ">
      <div className="space-y-1 font-pretendard w-full min-w-[700px]">
        {/* <div className="space-y-1 border-b-2 border-background-bnavy font-pretendard pb-4"> */}
        <div className="flex items-center gap-2 mb-4">
          <h1 className="text-2xl font-bold truncate">{mergeRequest.title}</h1>
          <span className="text-2xl text-gray-600">#{mergeRequest.iid}</span>
        </div>

        <div className="flex items-center gap-1 text-sm ">
          <div className="flex items-center gap-1 bg-primary-500 text-white rounded-2xl px-2">
            <span className="">{getStatusIcon(mergeRequest.state)}</span>
            <span className="font-bold">{mergeRequest.state}</span>
          </div>
          <div>
            <span className="font-bold">{mergeRequest.assignee.name}</span>
            <span className="mx-1">requested to merge</span>
            <span className="font-SFMono text-xs bg-secondary text-white rounded-2xl px-2">
              {mergeRequest.sourceBranch}
            </span>
            <span className="mx-1">to</span>
            <span className="font-SFMono text-xs  bg-secondary text-white rounded-2xl px-2">
              {mergeRequest.targetBranch}
            </span>
          </div>
        </div>
      </div>
      <div
        className="flex items-center justify-center bg-primary-500 text-white rounded-xl px-4 whitespace-nowrap w-fit h-10 cursor-pointer"
        onClick={() => window.open(mergeRequest.gitlabMrDetailUrl, ''_blank'', ''noopener'')}
      >
        보러 가기
      </div>
    </div>
  );
};', 'MergeRequestHeader.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 14:47:03.099634', 1548, 1, '2024-11-18 14:47:03.099634', 278, 'const ReferencesList = ({ references: initialReferences }: ReferencesListProps) => {
  const navigate = useNavigate();
  const { id } = useParams<{ id: string; selectedReviewId: string }>();
  const [projectId] = useAtom(projectIdAtom);
  const [references, setReferences] = useState<Reference[]>(initialReferences || []);
  const [isAddReferenceModalOpen, setIsAddReferenceModalOpen] = useState(false);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertModalContent, setAlertModalContent] = useState<string[]>([]);
  const [deleteTargetId, setDeleteTargetId] = useState<number | null>(null);
  const [, setIsLoading] = useState(true);

  // const location = useLocation();
  // const sendReviewId = location.state?.sendReviewId;

  // const { notify } = useNotification(sendReviewId || '''', id || '''', projectId || '''', setIsLoading);

  useEffect(() => {
    setReferences(initialReferences || []);
    setIsLoading(false);
  }, [initialReferences]);

  const handleDeleteClick = (id: number) => {
    setDeleteTargetId(id);
    setAlertModalContent([''정말 삭제하시겠습니까?'']);
    setIsAlertModalOpen(true);
  };

  const handleAlertModalConfirm = () => {
    if (deleteTargetId !== null) {
      handleDelete(deleteTargetId);
      setDeleteTargetId(null);
    }
    setIsAlertModalOpen(false);
  };

  const handleAlertModalCancel = () => {
    setDeleteTargetId(null);
    setIsAlertModalOpen(false);
  };

  const handleDelete = (id: number) => {
    setReferences((prevReferences) => prevReferences.filter((reference) => reference.id !== id));
  };

  const handleRegistReference = async () => {
    if (!id) {
      setAlertModalContent([''머지 리퀘스트 ID가 없습니다.'']);
      setIsAlertModalOpen(true);
      return;
    }
    // setIsLoading(true);

    try {
      const retrievals = references.map((ref) => ({
        fileName: ref.fileName,
        content: ref.content,
        language: ref.language.toUpperCase(),
      }));

      if (!projectId) {
        setAlertModalContent([''프로젝트 ID가 없습니다.'']);
        setIsAlertModalOpen(true);
        return;
      }

      const response = await Review.regenerateReview(projectId, id, retrievals);
      console.log(''response: '', response);
      setAlertModalContent([''리뷰가 재생성되었습니다.'']);
      setIsAlertModalOpen(true);

      // notify();

      navigate(`/${projectId}/main/merge-request/reviews/${id}`);
    } catch (error) {
      console.error(''리뷰 재생성 중 오류 발생:'', error);
      setAlertModalContent([''리뷰 재생성 중 오류가 발생했습니다.'']);
      setIsAlertModalOpen(true);
    }
  };

  const handleAddReference = () => {
    setIsAddReferenceModalOpen(true);
  };

  const handleAddReferenceSubmit = (language: string, content: string, fileName: string) => {
    const newReference: Reference = {
      id: Date.now(),
      fileName: fileName,
      content,
      language: language.toLowerCase(),
    };

    setReferences((prev) => [...prev, newReference]);
    setIsAddReferenceModalOpen(false);
  };

  return (
    <div>
      {/* {isLoading ? (
        <Loading />
      ) : ( */}
      <div className="w-full my-4 min-w-[350px]">
        <div className="space-y-4">
          {references.map((reference) => {
            const referenceType =
              reference.language.toLowerCase() === ''plaintext'' ? ''TEXT'' : ''CODE'';

            return (
              <CommonReference
                key={reference.id}
                id={reference.id}
                fileName={reference.fileName}
                content={reference.content}
                language={reference.language}
                type={referenceType}
                onDelete={handleDeleteClick}
                maxLength={3000}
              />
            );
          })}
          {references.length < 15 && (
            <div
              className="flex flex-col justify-center items-center border-2 rounded-lg border-background-bnavy py-10 space-y-4 hover:cursor-pointer"
              onClick={handleAddReference}
              aria-label="Add a new reference"
            >
              <Plus className="text-primary-500 w-14 h-14" strokeWidth={4} />
              <span className="text-primary-500 text-2xl">참고자료 추가하기</span>
            </div>
          )}
        </div>

        <AddReferenceModal
          isOpen={isAddReferenceModalOpen}
          onClose={() => setIsAddReferenceModalOpen(false)}
          onSubmit={handleAddReferenceSubmit}
        />

        {isAlertModalOpen && (
          <ConfirmModal
            content={alertModalContent}
            onConfirm={handleAlertModalConfirm}
            onCancel={handleAlertModalCancel}
            className="w-72 h-44"
          />
        )}

        <div className="flex justify-center my-8">
          <CommonButton
            className="w-fit px-10 py-4 cursor-pointer text-white"
            bgColor="bg-primary-500"
            active={true}
            onClick={handleRegistReference}
          >
            리뷰 재생성
          </CommonButton>
        </div>
      </div>
      {/* )} */}
    </div>
  );
};', 'ReferencesList.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.855091', 1559, 1, '2024-11-18 15:54:15.855091', 280, 'const LandingPage = () => {
  const navigate = useNavigate();

  return (
    <div className="min-h-screen bg-white">
      {/* Navigation */}
      <nav className="border-b">
        <div className="container mx-auto px-6 py-4">
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <GitMerge className="w-8 h-8 text-primary-500" />
              <span className="text-xl font-bold">coFlo</span>
            </div>
          </div>
        </div>
      </nav>

      {/* Hero Section */}
      <section className="py-20">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <h1 className="text-4xl md:text-5xl font-bold mb-6">
              더 나은 코드를 위한 AI 코드 리뷰
            </h1>
            <p className="text-xl text-secondary">
              프로젝트의 맥락을 이해하고 팀의 코딩 스타일을 반영하는
            </p>
            <p className="text-xl text-secondary mb-8">
              맞춤형 코드 리뷰로 개발 생산성을 높이세요.
            </p>
            <button
              className="bg-primary-500 text-white px-8 py-4 rounded-full text-lg 
              hover:bg-primary-600 transition-colors inline-flex items-center gap-2"
              onClick={() => navigate(''/login'')}
            >
              시작하기
              <ArrowRight className="w-5 h-5" />
            </button>
          </div>
          <ReviewDemo />
        </div>
      </section>

      {/* Features Section */}
      <section className="py-20 bg-gray-50">
        <div className="container mx-auto px-6">
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-12">
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <GitBranch className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">Git 자동 연동</h3>
              <p className="text-secondary">
                웹훅 설정만으로 Merge Request가 생성될 때마다 자동으로 리뷰가 시작됩니다.
              </p>
            </div>
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <Search className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">컨텍스트 기반 분석</h3>
              <p className="text-secondary">
                이슈와 MR 히스토리를 분석하여 프로젝트의 맥락을 이해하고 더 정확한 리뷰를
                제공합니다.
              </p>
            </div>
            <div>
              <div
                className="w-12 h-12 rounded-full bg-primary-500/10 flex items-center 
                justify-center mb-6"
              >
                <Zap className="w-6 h-6 text-primary-500" />
              </div>
              <h3 className="text-xl font-semibold mb-4">맞춤형 리뷰</h3>
              <p className="text-secondary">
                팀의 코딩 스타일과 컨벤션을 반영한 커스텀 템플릿으로 일관된 품질의 리뷰를
                받아보세요.
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* How it Works */}
      <section className="py-20">
        <div className="container mx-auto px-6">
          <h2 className="text-3xl font-bold text-center mb-16">3단계로 시작하는 AI 코드 리뷰</h2>
          <div className="grid md:grid-cols-3 gap-8 max-w-4xl mx-auto">
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                1
              </div>
              <h3 className="font-semibold mb-2">Git 연동</h3>
              <p className="text-secondary">프로젝트에 웹훅을 설정하여 coFlo와 연결하세요</p>
            </div>
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                2
              </div>
              <h3 className="font-semibold mb-2">템플릿 설정</h3>
              <p className="text-secondary">팀의 코딩 스타일에 맞는 리뷰 템플릿을 설정하세요</p>
            </div>
            <div className="text-center">
              <div
                className="w-12 h-12 rounded-full bg-primary-500 text-white font-bold 
                flex items-center justify-center mx-auto mb-6"
              >
                3
              </div>
              <h3 className="font-semibold mb-2">자동 리뷰</h3>
              <p className="text-secondary">MR이 생성되면 자동으로 AI 코드 리뷰가 시작됩니다</p>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="bg-gray-50 py-20">
        <div className="container mx-auto px-6 text-center">
          <h2 className="text-3xl font-bold mb-8">지금 바로 AI 코드 리뷰를 시작하세요</h2>
          <p className="text-xl text-secondary mb-8 max-w-2xl mx-auto">
            설치 없이 GitLab 연동만으로 바로 사용할 수 있습니다.
          </p>
          <button
            className="bg-primary-500 text-white px-8 py-4 rounded-full text-lg 
            hover:bg-primary-600 transition-colors inline-flex items-center gap-2"
            onClick={() => navigate(''/login'')}
          >
            시작하기
            <ArrowRight className="w-5 h-5" />
          </button>
        </div>
      </section>
    </div>
  );
};', 'LandingPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.857094', 1560, 1, '2024-11-18 15:54:15.857094', 280, 'const MergeRequestReviewPage = () => {
  const { id } = useParams<{ id: string }>();
  const [projectId] = useAtom(projectIdAtom);

  const [mergeRequest, setMergeRequest] = useState<GitlabMergeRequest | null>(null);
  const [reviews, setReviews] = useState<MergeRequestReview[''reviews'']>([]);
  const [references, setReferences] = useState<Reference[]>([]);
  const [selectedReviewId, setSelectedReviewId] = useState<string | null>(null);
  const [sendReviewId, setSendReviewId] = useState<string | null>(null);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string[]>([]);

  const fetchMergeRequest = async (projectId: string, mergeRequestIid: string) => {
    try {
      const response = await Review.getCodeReviewList(projectId, mergeRequestIid);
      const data = response.data;
      if (data) {
        setMergeRequest({ ...data.mergeRequest, gitlabMrDetailUrl: data.gitlabMrDetailUrl });
        setReviews(data.reviews);
      }
    } catch (error) {
      setIsAlertModalOpen(true);
      setAlertMessage([''리뷰가 아직 생성되지 않았습니다.'', ''잠시 후 시도해주세요.'']);
      console.error(error);
    }
  };

  useEffect(() => {
    if (!id || !projectId) return;

    fetchMergeRequest(projectId, id);
  }, [id, projectId]);

  useEffect(() => {
    if (!selectedReviewId) return;

    const fetchReferences = async (reviewId: string) => {
      const response = await Review.getReviewRetrievals(reviewId);

      const data = response.data;
      if (data) {
        setReferences(data);
      }
    };

    fetchReferences(selectedReviewId);
  }, [selectedReviewId]);

  useEffect(() => {
    if (reviews.length > 0 && !selectedReviewId) {
      setSelectedReviewId(String(Number(reviews[0].id)));
      setSendReviewId(String(Number(reviews[reviews.length - 1].id)));
    }
  }, [reviews, selectedReviewId]);

  if (!mergeRequest) return;

  const handleReviewClick = (reviewId: string) => {
    setSelectedReviewId(reviewId);
  };

  return (
    <div className="p-8 flex flex-col w-full overflow-auto items-center scroll-container">
      <div className="w-full border-b-[1px] border-background-bnavy">
        <MergeRequestHeader mergeRequest={mergeRequest} />
        <div className="flex gap-12 w-full">
          <ReviewList
            reviews={reviews}
            mergeRequest={mergeRequest}
            onReviewClick={handleReviewClick}
          />
          <ReferencesList
            references={references}
            selectedReviewId={selectedReviewId}
            sendReviewId={sendReviewId}
          />
        </div>
      </div>

      {isAlertModalOpen && (
        <AlertModal content={alertMessage} onConfirm={() => setIsAlertModalOpen(false)} />
      )}

      <ScrollNavigationButton />
    </div>
  );
};', 'MergeRequestReviewPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.858494', 1561, 1, '2024-11-18 15:54:15.858494', 280, 'function RepositoryPage() {
  const [repositories, setRepositories] = useState<GitlabProject[]>([]);
  const [selectedBranches, setSelectedBranches] = useState<BranchOption[]>([]);
  const [selectedRepo, setSelectedRepo] = useState<GitlabProject | null>(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [inputValue, setInputValue] = useState('''');
  const navigate = useNavigate();
  const [, setProjectId] = useAtom(projectIdAtom);
  const [, setProjectFullPath] = useAtom(projectFullPathAtom);
  const [pageInfo, setPageInfo] = useState<PageInfo>({
    startCursor: '''',
    endCursor: '''',
    hasNextPage: false,
    hasPreviousPage: false,
  });
  const [keyword, setKeyword] = useState('''');
  const size = 10;

  const fetchProjects = async (cursor?: { startCursor?: string; endCursor?: string }) => {
    const response = await Gitlab.getGitlabProjects(keyword, size, cursor);
    if (response && response.data) {
      setRepositories(response.data.gitlabProjectList);
      setPageInfo(response.data.pageInfo);
    }
  };

  useEffect(() => {
    fetchProjects();
  }, [keyword]);

  const handleNextPage = async () => {
    if (pageInfo.hasNextPage) {
      fetchProjects({ endCursor: pageInfo.endCursor });
    }
  };

  const handlePreviousPage = async () => {
    if (pageInfo.hasPreviousPage) {
      fetchProjects({ startCursor: pageInfo.startCursor });
    }
  };

  const handleInputChange = (value: string) => {
    setInputValue(value);
  };

  const handleToggleChange = async (index: number) => {
    const repo = repositories[index];

    if (repo.isLinkable) {
      if (repo.isLinked) {
        await UserProject.deleteRepository(repo.gitlabProjectId);
        setRepositories((prev) => {
          const updatedRepos = [...prev];
          updatedRepos[index] = { ...updatedRepos[index], isLinked: false };
          return updatedRepos;
        });
      } else {
        await UserProject.updateRepository(repo.gitlabProjectId, {});
        setRepositories((prev) => {
          const updatedRepos = [...prev];
          updatedRepos[index] = { ...updatedRepos[index], isLinked: true };
          return updatedRepos;
        });
      }
    } else {
      setSelectedRepo(repo);
      setIsModalOpen(true);
    }
  };

  const handleModalConfirm = async () => {
    if (selectedRepo) {
      const branchNames = selectedBranches.map((branch) => branch.value);

      await UserProject.updateRepository(selectedRepo.gitlabProjectId, {
        botToken: inputValue,
        branches: branchNames,
      });

      setRepositories((prev) => {
        const updatedRepos = [...prev];
        const index = repositories.findIndex(
          (repo) => repo.gitlabProjectId === selectedRepo.gitlabProjectId,
        );
        updatedRepos[index] = { ...updatedRepos[index], isLinked: true, isLinkable: true };
        return updatedRepos;
      });

      setIsModalOpen(false);
      setSelectedRepo(null);
      setInputValue('''');
      setSelectedBranches([]);
    }
  };

  const handleSearch = (searchKeyword: string) => {
    setKeyword(searchKeyword);
    setPageInfo({
      startCursor: '''',
      endCursor: '''',
      hasNextPage: false,
      hasPreviousPage: false,
    });
  };

  const handleButtonClick = async () => {
    const response = await UserProject.getLinkStatus();
    if (response?.data) {
      const { hasLinkedProject, projectId, projectFullPath } = response.data;
      setProjectId(projectId);
      setProjectFullPath(projectFullPath);
      if (hasLinkedProject) {
        navigate(`/${projectId}/main`);
      } else {
        alert(''연동되지 않았습니다. 먼저 연동을 완료해주세요.'');
      }
    }
  };

  return (
    <div className="flex flex-col ml-[80px] p-6 w-full justify-between overflow-auto">
      <div>
        <div className="flex flex-row justify-between items-center pr-3">
          <div>
            <Header
              title="Repository"
              description={[''내 프로젝트에서 리뷰할 프로젝트를 선택합니다.'']}
            />
          </div>
          <CommonButton
            className="px-4 min-w-[100px] h-[50px] text-white"
            active={false}
            bgColor="bg-primary-500"
            onClick={handleButtonClick}
          >
            시작하기
          </CommonButton>
        </div>
        <CustomSearchBar onSearch={handleSearch} showOption={false} width="pl-3 min-w-[400px]" />
      </div>

      <div className="flex flex-col flex-grow overflow-auto bg-white w-full min-w-[400px] justify-start">
        {repositories.length > 0 ? (
          repositories.map((repo, index) => (
            <div key={repo.gitlabProjectId}>
              <div className="flex items-center justify-between py-[22px] px-6">
                <RepositoryItem
                  name={repo.name}
                  integrate={repo.isLinkable ? '''' : ''프로젝트 토큰을 설정해주세요''}
                />
                <ToggleSwitch checked={repo.isLinked} onChange={() => handleToggleChange(index)} />
              </div>
              {index < repositories.length - 1 && <div className="border-t border-gray-300" />}
            </div>
          ))
        ) : (
          <div className="flex flex-col items-center justify-center h-full">
            <SearchX size={100} className="text-primary-500" />
            <div className="text-center text-primary-500 text-3xl font-bold mt-6">
              검색 결과가 없습니다.
            </div>
          </div>
        )}
      </div>

      {isModalOpen && selectedRepo && (
        <GuideModal
          isOpen={isModalOpen}
          title="프로젝트 토큰을 얻어오는 방법"
          width="w-[600px]"
          content={
            <div className="space-y-2">
              <p>1. 버튼을 클릭하여 프로젝트 검색을 시작하세요.</p>
              <p>2. 설정(Settings)으로 이동 후 Access Tokens 메뉴를 선택하세요.</p>
              <p>3. API 체크 후 Project Access Tokens를 생성하세요.</p>
            </div>
          }
          contentBottom={
            <div className="mt-4">
              <label className="block mb-2 text-2xl">참조할 브랜치</label>
              <BranchSelector
                value={selectedBranches}
                onChange={setSelectedBranches}
                gitlabProjectId={Number(selectedRepo?.gitlabProjectId)}
              />
            </div>
          }
          image={{
            src: tokenintro,
            alt: ''Project Token Instructions'',
          }}
          hasInput
          inputProps={{
            value: inputValue,
            onChange: handleInputChange,
            placeholder: ''프로젝트 토큰을 입력하세요'',
            labelText: ''프로젝트 토큰'',
          }}
          links={[
            {
              url: ''https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html'',
              text: ''프로젝트 토큰 생성 가이드 보기'',
              icon: <FileQuestion size={20} className="text-primary-500" />,
            },
          ]}
          onClose={() => {
            setIsModalOpen(false);
            setSelectedRepo(null);
            setInputValue('''');
            setSelectedBranches([]);
          }}
          onConfirm={handleModalConfirm}
          gitlabProjectId={String(selectedRepo.gitlabProjectId)}
        ></GuideModal>
      )}

      {/* <MemoizedPagination /> */}
      <CursorPagination
        hasNextPage={pageInfo.hasNextPage}
        hasPreviousPage={pageInfo.hasPreviousPage}
        onNext={handleNextPage}
        onPrevious={handlePreviousPage}
      />
    </div>
  );
}', 'RepositoryPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.859889', 1562, 1, '2024-11-18 15:54:15.859889', 280, 'const SignupForm = () => {
  const navigate = useNavigate();
  const [domain, setDomain] = useState(''lab.ssafy.com'');
  const [userToken, setUserToken] = useState('''');
  const [isTokenValid, setIsTokenValid] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string[]>([]);
  const isSignupEnabled = isTokenValid && domain;

  const handleValidateToken = async () => {
    if (!userToken) return;

    setIsValidating(true);
    try {
      const response = await Gitlab.validateUserToken({
        domain,
        userToken,
      });
      const isValid = response.data;
      if (isValid) {
        setIsTokenValid(isValid);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효한 토큰입니다.'', ''회원가입을 진행해주세요.'']);
      } else {
        setIsTokenValid(false);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효하지 않은 토큰입니다.'', ''다시 한 번 입력해주세요.'']);
      }
    } catch (error) {
      setIsTokenValid(false);
    } finally {
      setIsValidating(false);
    }
  };

  const handleSignup = async () => {
    if (!isSignupEnabled) return;

    try {
      const response = await User.addGitlabAccount({
        domain,
        userToken,
      });

      if (response.status === ''SUCCESS'') {
        navigate(''/repository'');
      }
    } catch (error) {
      console.error(''회원가입 실패'', error);
      setIsAlertModalOpen(true);
      setAlertMessage([''회원가입에 실패했습니다.'', ''다시 시도해주세요.'']);
    }
  };

  return (
    <div className="relative min-w-[520px]">
      {/* 블러 효과 배경 */}
      <div className="absolute inset-0 backdrop-blur-md rounded-3xl"></div>

      {/* SignupForm 콘텐츠 */}
      <div className="bg-white/50 rounded-3xl p-10 py-20 relative z-10 font-pretendard border-2 border-primary-500">
        <div className="text-5xl font-bold mb-10 mt-20">회원 가입</div>
        <form>
          <div className="space-y-14">
            <div className="flex flex-col space-y-10">
              <div className="h-28">
                <GitUrlSelector
                  value={domain}
                  onChange={setDomain}
                  labelText="가져올 Git 서비스 URL을 선택해주세요."
                />
              </div>
              <div className="relative h-28">
                <TokenInput
                  value={userToken}
                  onChange={(value) => setUserToken(value)}
                  onValidate={handleValidateToken}
                  isValidating={isValidating}
                  isValid={isTokenValid}
                  labelText="사용자 인증 토큰을 입력해주세요."
                  placeholder="Enter your user access token"
                  warningMessage="검증하기 버튼을 눌러 토큰을 검증해주세요."
                />
                <div
                  className="flex items-center text-sm text-secondary mt-1 cursor-pointer"
                  onClick={() => setIsModalOpen(true)}
                >
                  <Info size={16} />
                  <span className="ml-1 text-xl">사용자 인증 토큰 안내</span>
                </div>
              </div>
            </div>
          </div>
        </form>

        <GuideModal
          isOpen={isModalOpen}
          width="w-[400px]"
          title="사용자 인증 토큰 안내"
          content={
            <div className="text-center text-xl font-bold text-primary-500">
              아바타 프로필 클릭 &gt; Edit Profile &gt; Access Tokens &gt; Add new token
            </div>
          }
          onClose={() => setIsModalOpen(false)}
          image={{
            src: ''/images/guide/guide_personal_access_token.png'',
            alt: ''personal_access_token'',
          }}
          links={[
            {
              url: `https://${domain}`,
              text: ''토큰 가지러 가기'',
              icon: <Link size={20} className="text-primary-500" />,
            },
            {
              url: ''https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html'',
              text: ''인증 토큰 발급 관련 도움말'',
              icon: <FileQuestion size={20} className="text-primary-500" />,
            },
          ]}
        />

        {isAlertModalOpen && (
          <AlertModal
            content={alertMessage}
            onConfirm={() => setIsAlertModalOpen(false)}
            icon={isTokenValid ? CircleCheck : TriangleAlert}
            iconClassName={isTokenValid ? ''text-state-success'' : ''text-state-warning''}
          />
        )}

        <div className="flex justify-center mt-20 cursor-pointer">
          <CommonButton
            className="w-36 h-14 text-xl text-white"
            disabled={!isSignupEnabled}
            onClick={handleSignup}
          >
            가입하기
          </CommonButton>
        </div>
      </div>
    </div>
  );
};', 'SignupForm.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.861461', 1563, 1, '2024-11-18 15:54:15.861461', 280, 'const MergeListPage = () => {
  const navigate = useNavigate();
  const itemsPerPage = 7;
  const [currentPage] = useAtom(currentPageAtom);
  const [, setTotalPages] = useAtom(totalPagesAtom);
  const [projectId] = useAtom(projectIdAtom);
  const [mergeRequests, setMergeRequests] = useState<GitlabMergeRequest[]>([]);
  const [currentStatus, setCurrentStatus] = useState(''opened'');
  const [searchKeyword, setSearchKeyword] = useState('''');
  const [, setSearchType] = useState(''All'');
  const [projectLabels, setProjectLabels] = useState<ProjectLabel[]>([]);

  const fetchMergeRequests = async () => {
    if (!projectId) return;

    // MR 리스트와 라벨 정보를 병렬로 조회
    const [mrResponse, labelsResponse] = await Promise.all([
      MergeRequest.getMrList(projectId, currentStatus, {
        keyword: searchKeyword,
        page: Number(currentPage),
        size: Number(itemsPerPage),
      }),
      ProjectRequest.getProjectLabels(projectId),
    ]);

    if (mrResponse.data) {
      setTotalPages(mrResponse.data.totalPages ?? 1);
      setMergeRequests(mrResponse.data.gitlabMrList);
    }

    if (labelsResponse.data) {
      setProjectLabels(labelsResponse.data.labels);
    }
  };

  const handleStatusChange = (status: string) => {
    setCurrentStatus(status);
  };

  const handleSearch = async (keyword: string, searchType: string) => {
    setSearchKeyword(keyword);
    setSearchType(searchType);

    if (!projectId) return;
    await fetchMergeRequests();
  };

  const handleItemClick = (iid: number) => {
    navigate(`/${projectId}/main/merge-request/reviews/${iid}`);
  };

  useEffect(() => {
    fetchMergeRequests();
  }, [projectId, currentStatus, currentPage]);

  return (
    <div className="h-full overflow-auto w-full">
      <div className="flex flex-col justify-between min-h-full p-6">
        <div className="flex flex-col gap-4">
          <MrStatusFilter onStatusChange={handleStatusChange} />
          <CustomSearchBar onSearch={handleSearch} showOption={false} />
        </div>

        <div className="flex-1 bg-white">
          <div className="pb-4 h-full">
            {mergeRequests.length === 0 ? (
              <EmptyMergeRequest />
            ) : (
              mergeRequests.map((mergeRequest) => (
                <div
                  key={mergeRequest.id}
                  onClick={() => handleItemClick(mergeRequest.iid)}
                  className="cursor-pointer"
                >
                  <MrItem mergeRequest={mergeRequest} projectLabels={projectLabels} />
                  <div className="border-1px border-gray-300" />
                </div>
              ))
            )}
          </div>
        </div>

        <Pagination />
      </div>
    </div>
  );
};', 'MergeListPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.862676', 1564, 1, '2024-11-18 15:54:15.862676', 280, 'const ReferencesList = ({ references: initialReferences }: ReferencesListProps) => {
  const navigate = useNavigate();
  const { id } = useParams<{ id: string; selectedReviewId: string }>();
  const [projectId] = useAtom(projectIdAtom);
  const [references, setReferences] = useState<Reference[]>(initialReferences || []);
  const [isAddReferenceModalOpen, setIsAddReferenceModalOpen] = useState(false);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertModalContent, setAlertModalContent] = useState<string[]>([]);
  const [deleteTargetId, setDeleteTargetId] = useState<number | null>(null);
  const [, setIsLoading] = useState(true);

  // const location = useLocation();
  // const sendReviewId = location.state?.sendReviewId;

  // const { notify } = useNotification(sendReviewId || '''', id || '''', projectId || '''', setIsLoading);

  useEffect(() => {
    setReferences(initialReferences || []);
    setIsLoading(false);
  }, [initialReferences]);

  const handleDeleteClick = (id: number) => {
    setDeleteTargetId(id);
    setAlertModalContent([''정말 삭제하시겠습니까?'']);
    setIsAlertModalOpen(true);
  };

  const handleAlertModalConfirm = () => {
    if (deleteTargetId !== null) {
      handleDelete(deleteTargetId);
      setDeleteTargetId(null);
    }
    setIsAlertModalOpen(false);
  };

  const handleAlertModalCancel = () => {
    setDeleteTargetId(null);
    setIsAlertModalOpen(false);
  };

  const handleDelete = (id: number) => {
    setReferences((prevReferences) => prevReferences.filter((reference) => reference.id !== id));
  };

  const handleRegistReference = async () => {
    if (!id) {
      setAlertModalContent([''머지 리퀘스트 ID가 없습니다.'']);
      setIsAlertModalOpen(true);
      return;
    }
    // setIsLoading(true);

    try {
      const retrievals = references.map((ref) => ({
        fileName: ref.fileName,
        content: ref.content,
        language: ref.language.toUpperCase(),
      }));

      if (!projectId) {
        setAlertModalContent([''프로젝트 ID가 없습니다.'']);
        setIsAlertModalOpen(true);
        return;
      }

      const response = await Review.regenerateReview(projectId, id, retrievals);
      console.log(''response: '', response);
      setAlertModalContent([''리뷰가 재생성되었습니다.'']);
      setIsAlertModalOpen(true);

      // notify();

      navigate(`/${projectId}/main/merge-request/reviews/${id}`);
    } catch (error) {
      console.error(''리뷰 재생성 중 오류 발생:'', error);
      setAlertModalContent([''리뷰 재생성 중 오류가 발생했습니다.'']);
      setIsAlertModalOpen(true);
    }
  };

  const handleAddReference = () => {
    setIsAddReferenceModalOpen(true);
  };

  const handleAddReferenceSubmit = (language: string, content: string, fileName: string) => {
    const newReference: Reference = {
      id: Date.now(),
      fileName: fileName,
      content,
      language: language.toLowerCase(),
    };

    setReferences((prev) => [...prev, newReference]);
    setIsAddReferenceModalOpen(false);
  };

  return (
    <div>
      {/* {isLoading ? (
        <Loading />
      ) : ( */}
      <div className="w-full my-4 min-w-[350px]">
        <div className="space-y-4">
          {references.map((reference) => {
            const referenceType =
              reference.language.toLowerCase() === ''plaintext'' ? ''TEXT'' : ''CODE'';

            return (
              <CommonReference
                key={reference.id}
                id={reference.id}
                fileName={reference.fileName}
                content={reference.content}
                language={reference.language}
                type={referenceType}
                onDelete={handleDeleteClick}
                maxLength={3000}
              />
            );
          })}
          {references.length < 15 && (
            <div
              className="flex flex-col justify-center items-center border-2 rounded-lg border-background-bnavy py-10 space-y-4 hover:cursor-pointer"
              onClick={handleAddReference}
              aria-label="Add a new reference"
            >
              <Plus className="text-primary-500 w-14 h-14" strokeWidth={4} />
              <span className="text-primary-500 text-2xl">참고자료 추가하기</span>
            </div>
          )}
        </div>

        <AddReferenceModal
          isOpen={isAddReferenceModalOpen}
          onClose={() => setIsAddReferenceModalOpen(false)}
          onSubmit={handleAddReferenceSubmit}
        />

        {isAlertModalOpen && (
          <ConfirmModal
            content={alertModalContent}
            onConfirm={handleAlertModalConfirm}
            onCancel={handleAlertModalCancel}
            className="w-72 h-44"
          />
        )}

        <div className="flex justify-center my-8">
          <CommonButton
            className="w-fit px-10 py-4 cursor-pointer text-white"
            bgColor="bg-primary-500"
            active={true}
            onClick={handleRegistReference}
          >
            리뷰 재생성
          </CommonButton>
        </div>
      </div>
      {/* )} */}
    </div>
  );
};', 'ReferencesList.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.86406', 1565, 1, '2024-11-18 15:54:15.86406', 280, 'const HomePage = () => {
  const navigate = useNavigate();
  const initialProjectDetail = {
    programmingLanguagesData: null,
    commitCount: 0,
    branchCount: 0,
    mergeRequestCount: 0,
    aiReviewCount: 0,
  };
  const initialRadarData: RadarData = {
    labels: [],
    datasets: [],
  };
  const [, setContainerHeight] = useState<number>(0);
  const [startDate, setStartDate] = useState<string | null>(null);
  const [endDate, setEndDate] = useState<string | null>(null);
  const [radarData, setRadarData] = useState<RadarData | null>(initialRadarData);
  const [profileIcons, setProfileIcons] = useState<Record<number, string>>({});
  const [badgeIcons, setBadgeIcons] = useState<Record<number, string>>({});
  const [selectedChart, setSelectedChart] = useState<string>(''획득 통합 스코어'');
  const [, setSelectedOption] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [lineData, setLineData] = useState({
    labels: [],
    datasets: [],
  });

  const [cubicLineData, setCubicLineData] = useState({
    labels: [],
    datasets: [],
  });

  const [maxValue, setMaxValue] = useState<number>(0);
  const [minValue, setMinValue] = useState<number>(100);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const [projectDetail, setProjectDetail] = useState<{
    programmingLanguagesData: ProgrammingLanguagesData | null;
    commitCount: number;
    branchCount: number;
    mergeRequestCount: number;
    aiReviewCount: number;
  }>(initialProjectDetail);
  const [projectId] = useAtom(projectIdAtom);

  const handleSelect = (chart: string) => {
    setSelectedChart(chart);
  };

  useEffect(() => {
    if (!projectId) {
      setIsLoading(false);
      return;
    }

    const loadProjectData = async () => {
      setIsLoading(false);
    };

    loadProjectData();
  }, [projectId]);

  useEffect(() => {
    if (!isLoading && !projectId) {
      navigate(''/repository'');
    }
  }, [isLoading, projectId, navigate]);

  useEffect(() => {
    let calculationType = ''acquisition'';
    let scoreDisplayType = ''total'';

    switch (selectedChart) {
      case ''획득 통합 스코어'':
        calculationType = ''acquisition'';
        scoreDisplayType = ''total'';
        break;
      case ''획득 개별 스코어'':
        calculationType = ''acquisition'';
        scoreDisplayType = ''individual'';
        break;
      case ''누적 통합 스코어'':
        calculationType = ''cumulative'';
        scoreDisplayType = ''total'';
        break;
      case ''누적 개별 스코어'':
        calculationType = ''cumulative'';
        scoreDisplayType = ''individual'';
        break;
      default:
        break;
    }

    const queryParams = {
      calculationType,
      scoreDisplayType,
    };

    const fetchData = async () => {
      if (!projectId) {
        return;
      }
      const {
        lineData: fetchedLineData,
        cubicLineData: fetchedCubicLineData,
        maxScore,
        minScore,
        startDate: fetchedStartDate,
        endDate: fetchedEndDate,
      } = await loadChartData(projectId, selectedChart, queryParams);

      if (fetchedLineData) {
        setLineData(fetchedLineData);
      }

      if (fetchedCubicLineData) {
        setCubicLineData(fetchedCubicLineData);
      }

      setMaxValue(maxScore);
      setMinValue(minScore);

      // Set the start and end date
      setStartDate(fetchedStartDate);
      setEndDate(fetchedEndDate);
    };

    fetchData();
  }, [selectedChart, projectId]);

  useEffect(() => {
    if (!projectId) return;
    const loadProjectData = async () => {
      const langauageData = await fetchProjectDetail(projectId);

      const teamScoreData = await fetchProjectTeamScore(projectId);

      setProjectDetail(langauageData || initialProjectDetail);
      if (teamScoreData) {
        setRadarData(teamScoreData.radarData);
        setProfileIcons(teamScoreData.profileIcons);
        setBadgeIcons(teamScoreData.badgeIcons);
      }
    };

    loadProjectData();
  }, [projectId]);

  useEffect(() => {
    if (containerRef.current) {
      setContainerHeight(containerRef.current.clientHeight);
    }
  }, []);

  return (
    <div className="flex flex-col flex-grow p-4 gap-8 min-w-[1000px] max-w-[2000px] overflow-auto">
      {/* 첫 번째 행 */}
      <div className="flex flex-row min-h-[500px] gap-4">
        {/* Team Radar Charts - 3/5 너비 */}
        <div className="flex flex-col flex-[3] min-w-[570px]">
          <Title title="Team Radar Charts" textSize="text-lg" />

          <div
            ref={containerRef}
            className="relative flex-grow bg-gray-400 border-2 border-gray-300 rounded-lg flex items-center justify-center p-4"
          >
            <div className="absolute top-3 right-7 text-right text-gray-700 font-semibold mb-4">
              {`${monday} ~ ${sunday}`}
            </div>
            <ChartBox
              chartType="radar"
              data={radarData}
              options={createRadarOptions()}
              chartId="radarChart"
              width="500px"
              height="300px"
              profileIcons={profileIcons}
              badgeIcons={badgeIcons}
            />
          </div>
        </div>
        {/* Project Total - 2/5 너비 */}
        <div className="flex flex-col flex-[2] min-w-[380px]">
          <Title title="Project Total" textSize="text-lg" />
          <div className="flex flex-col flex-grow justify-between p-4 bg-gray-400 border-2 border-gray-300 rounded-lg">
            <Title title="About" textSize="text-xl" />
            <Title title="Language" textSize="text-lg" py="py-1" />
            <div className="mx-4">
              {projectDetail.programmingLanguagesData &&
              projectDetail.programmingLanguagesData.labels ? (
                <ChartBox
                  chartType="bar"
                  data={projectDetail.programmingLanguagesData}
                  options={createHorizontalBarOptions([0, 100])}
                  chartId="horizontalBarChart"
                  width="100%"
                  height="60px"
                />
              ) : (
                <p className="text-center">No Chart</p>
              )}
            </div>
            <div className="h-5 px-2 w-full flex flex-col justify-center">
              <div className="bg-gray-600 h-[1px] w-full"></div>
            </div>
            <div className="flex flex-col space-y-5 py-5">
              <Title title="Info" textSize="text-lg" py="py-1" />
              <div className="flex flex-col space-y-5 items-center justify-center">
                <div className="flex flex-row justify-around gap-4">
                  <IconWithText
                    svg={<CommitIcon />}
                    text="commits"
                    count={projectDetail.commitCount}
                  />
                  <IconWithText
                    svg={<BranchIcon className="w-4 h-4" />}
                    text="branches"
                    count={projectDetail.branchCount}
                  />
                </div>
                <div className="flex flex-row justify-around gap-4">
                  <IconWithText
                    svg={<PullRequestIcon className="w-4 h-4" />}
                    text="MRs"
                    count={projectDetail.mergeRequestCount}
                  />
                  <IconWithText
                    svg={<AiIcon />}
                    text="Ai reviews"
                    count={projectDetail.aiReviewCount}
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* 두 번째 행 */}
      <div className="flex flex-row min-h-[450px] gap-4 mb-4">
        {/* Personal Growth Graph - 3/5 너비 */}
        <div className="flex flex-col flex-[3] min-w-[570px]">
          <div className="flex flex-row justify-between items-center">
            <Title title="Personal Growth Graph" textSize="text-lg" />
            <ChartDropdown
              onSelect={(option) => {
                handleSelect(option);
                setSelectedOption(option);
              }}
            />
          </div>
          <div className="relative flex-grow bg-gray-400 border-2 border-gray-300 rounded-lg items-center justify-center pt-10">
            <div className="absolute top-3 right-7 text-right text-gray-700 font-semibold mb-4">
              {`${startDate} ~ ${endDate}`}
            </div>
            {selectedChart === ''획득 통합 스코어'' && (
              <ChartBox
                chartType="line"
                data={cubicLineData}
                options={createLineOptions([0, 70])}
                chartId="lineChart"
                height="330px"
              />
            )}
            {selectedChart === ''획득 개별 스코어'' && (
              <ChartBox
                chartType="line"
                data={lineData}
                options={createLineOptions([0, 11])}
                chartId="cubicLineChart"
                height="330px"
              />
            )}
            {selectedChart === ''누적 통합 스코어'' && (
              <ChartBox
                chartType="line"
                data={cubicLineData}
                options={createCubicLineOptions([minValue, maxValue])}
                chartId="cumulativeLineChart"
                height="330px"
              />
            )}
            {selectedChart === ''누적 개별 스코어'' && (
              <ChartBox
                chartType="line"
                data={lineData}
                options={createCubicLineOptions([minValue, maxValue])}
                chartId="cumulativeCubicLineChart"
                height="330px"
              />
            )}
          </div>
        </div>
        {/* Best Merge Request - 2/5 너비 */}
        <div className="flex flex-col flex-[2] min-w-[380px]">
          <BestMergeRequestList />
        </div>
      </div>
    </div>
  );
};', 'HomePage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.865683', 1566, 1, '2024-11-18 15:54:15.865683', 280, 'const NavigationButtons = () => {
  const navigate = useNavigate();

  return (
    <div className="flex gap-4 justify-center">
      <button
        onClick={() => navigate(-1)}
        className="inline-flex items-center gap-2 px-6 py-3 rounded-full 
            border border-gray-300 text-gray-700 hover:bg-gray-100 transition-colors"
      >
        <ArrowLeft className="w-5 h-5" />
        이전 페이지
      </button>
      <button
        onClick={() => navigate(''/'')}
        className="inline-flex items-center gap-2 px-6 py-3 rounded-full 
            bg-primary-500 text-white hover:bg-primary-600 transition-colors"
      >
        <Home className="w-5 h-5" />
        홈으로 가기
      </button>
    </div>
  );
};', 'NavigationButtons.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.866926', 1567, 1, '2024-11-18 15:54:15.866926', 280, 'const ReviewDemo = () => (
  <div className="bg-white rounded-lg shadow-xl p-6 max-w-2xl mx-auto">
    <div className="flex items-center gap-2 mb-4 text-secondary border-b pb-4">
      <GitMerge className="w-5 h-5" />
      <span className="font-medium">user-auth-feature</span>
      <span className="text-gray-400">•</span>
      <span className="text-gray-400 text-sm">2 minutes ago</span>
    </div>
    <div className="space-y-6">
      <div className="flex gap-4">
        <div className="flex-shrink-0">
          <div className="w-8 h-8 rounded-full bg-primary-500/10 flex items-center justify-center">
            <CheckCircle2 className="w-5 h-5 text-primary-500" />
          </div>
        </div>
        <div>
          <div className="font-medium mb-2">Security Enhancement</div>
          <div className="text-secondary text-sm bg-gray-50 p-4 rounded-lg font-mono">
            Consider using bcrypt instead of SHA-256 for password hashing:
            <br />
            <span className="text-red-500">- const hash = SHA256(password);</span>
            <br />
            <span className="text-green-500">+ const hash = await bcrypt.hash(password, 10);</span>
          </div>
        </div>
      </div>
      <div className="flex gap-4">
        <div className="flex-shrink-0">
          <div className="w-8 h-8 rounded-full bg-blue-500/10 flex items-center justify-center">
            <Zap className="w-5 h-5 text-blue-500" />
          </div>
        </div>
        <div>
          <div className="font-medium mb-2">Performance Optimization</div>
          <div className="text-secondary text-sm bg-gray-50 p-4 rounded-lg">
            Adding an index on the `email` field will improve query performance by approximately 75%
            based on your current data volume.
          </div>
        </div>
      </div>
    </div>
  </div>
);', 'LandingPage.tsx');
INSERT INTO public.retrieval VALUES ('2024-11-18 15:54:15.868339', 1568, 1, '2024-11-18 15:54:15.868339', 280, 'function GuideModal({
  gitlabProjectId,
  isOpen,
  width = ''w-[600px]'',
  title,
  content,
  contentBottom,
  image,
  onClose,
  onConfirm,
  hasInput,
  inputProps,
  links,
}: GuideModalProps) {
  const [botToken, setBotToken] = useState<string>('''');
  const [isTokenValid, setIsTokenValid] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [isAlertModalOpen, setIsAlertModalOpen] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string[]>([]);

  useEffect(() => {
    if (isOpen && inputProps?.value) {
      setBotToken(inputProps.value);
    }
  }, [inputProps?.value, isOpen]);

  const handleValidateToken = async () => {
    console.log(botToken);
    if (!botToken) return;
    console.log(''토큰 검증 시작'');

    setIsValidating(true);

    if (!gitlabProjectId) {
      console.error(''Gitlab Project ID가 정의되지 않았습니다.'');
      setIsAlertModalOpen(true);
      setAlertMessage([''Gitlab Project ID가 정의되지 않았습니다.'', ''GitLab ID를 확인해주세요.'']);
      return;
    }

    try {
      const response = await Gitlab.validateBotToken({
        gitlabProjectId,
        botToken,
      });
      const isValid = response.data;
      if (isValid) {
        setIsTokenValid(isValid);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효한 토큰입니다.'', ''회원가입을 진행해주세요.'']);
      } else {
        setIsTokenValid(false);
        setIsAlertModalOpen(true);
        setAlertMessage([''유효하지 않은 토큰입니다.'', ''다시 한 번 입력해주세요.'']);
      }
    } catch (error) {
      setIsTokenValid(false);
    } finally {
      setIsValidating(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-black/50 flex items-center justify-center z-50"
      onClick={onClose}
    >
      <div
        className={`bg-white p-8 border-2 border-primary-500 rounded-xl ${width} max-h-[90vh] relative`}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Close Button */}
        <button
          onClick={onClose}
          className="absolute top-4 right-4 p-1 hover:bg-primary-100 rounded-full transition-colors"
          aria-label="Close modal"
        >
          <X size={24} className="text-primary-500" />
        </button>

        {/* Title */}
        <h2 className="text-2xl font-bold text-center mt-4 mb-6 text-primary-500">{title}</h2>

        {/* Content */}
        {content && <div className="mb-6 space-y-2">{content}</div>}

        {/* Image */}
        {image && (
          <div className="mb-6">
            <img src={image.src} alt={image.alt} className="w-full h-auto rounded-lg" />
          </div>
        )}

        {/* Input Field */}
        {hasInput && inputProps && (
          <div className="mb-6">
            <TokenInput
              value={inputProps.value}
              onChange={inputProps.onChange}
              onValidate={handleValidateToken}
              isValidating={isValidating}
              isValid={isTokenValid}
              labelText={inputProps.labelText || ''''}
              placeholder={inputProps.placeholder || ''''}
              warningMessage="검증하기 버튼을 눌러 토큰을 검증해주세요."
              showValidateButton={true}
            />
          </div>
        )}

        {isAlertModalOpen && (
          <AlertModal
            content={alertMessage}
            onConfirm={() => setIsAlertModalOpen(false)}
            icon={isTokenValid ? CircleCheck : TriangleAlert}
            iconClassName={isTokenValid ? ''text-state-success'' : ''text-state-warning''}
          />
        )}

        {/* Link */}
        {links && (
          <div className="flex flex-col mb-6 items-center">
            {links.map((link) => (
              <div className="flex items-center justify-start gap-2">
                {link.icon && link.icon}
                <a
                  href={link.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-primary-500"
                >
                  {link.text}
                </a>
              </div>
            ))}
          </div>
        )}

        {contentBottom && <div className="mb-6 space-y-2">{contentBottom}</div>}

        {/* Confirm Button */}
        {onConfirm && (
          <div className="flex justify-end">
            <button
              type="button"
              onClick={onConfirm}
              className="bg-primary-500 text-white px-6 py-2 rounded-lg
                       hover:bg-primary-600 transition-colors"
            >
              확인
            </button>
          </div>
        )}
      </div>
    </div>
  );
}', 'GuideModal.tsx');


--
-- TOC entry 3858 (class 0 OID 35560)
-- Dependencies: 253
-- Data for Name: review; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.review VALUES ('2024-11-11 17:17:38.081342', 1, '2024-11-11 17:17:38.081342', 2, '### 코드 리뷰

#### 변경사항 요약
- Custom Prompt의 `content` 필드에 길이 제한(최대 1000자)을 추가했습니다.

#### 코드 정확성
- 길이 제한을 추가함으로써 데이터베이스에서 저장할 수 있는 최대 문자 수를 관리할 수 있게 되었습니다. 이는 잠재적인 데이터 손실을 방지할 수 있는 유효한 변경입니다.
- `@Column(length = 1000)` 어노테이션을 통해 JPA에서 `content` 필드의 길이를 제한하도록 잘 구현되었습니다.

#### 가독성
- 변경된 코드는 가독성이 높습니다. 길이 제한을 추가하는 방식이 명확하여 다른 개발자들이 보았을 때 즉시 이해할 수 있습니다.
  
#### 효율성
- 데이터베이스에 저장되는 데이터의 크기를 제한함으로써 과도한 데이터 저장으로 인한 비용이 발생할 여지를 줄일 수 있습니다. 이는 시스템 자원을 효율적으로 사용하는 데 기여할 것입니다.
  
#### 확장성
- 현재 구조에서 `content`의 최대 길이를 1000자로 설정하는 것은 좋지만, 향후 비즈니스 로직이 변경되어 더 긴 텍스트를 지원해야 하는 경우에는 유연성이 떨어질 수 있습니다. 이러한 요구사항이 발생할 경우, 명시적으로 길이 제한을 설정하는 것보다는 별도의 데이터 검증 로직을 추가하는 방법도 고려해볼 수 있습니다.
  
#### 코딩 표준 및 스타일
- JPA 어노테이션 형식 및 위치가 적절합니다. 현재 구현은 Java의 코딩 표준을 준수하고 있습니다.
- 주석이 없어서 `content` 필드의 길이 제한의 목적 및 관련 비즈니스 로직을 설명하는 주석이 추가될 경우 가독성이 더욱 향상될 수 있습니다.

#### 잠재적 버그
- 현재 코드에서 특별한 버그는 발견되지 않았습니다. 다만, 데이터베이스 스키마 변경이나 마이그레이션 작업을 진행할 때, 기존 데이터가 길이 제한을 넘어서는 경우에 대한 예외 처리에 대해 신경을 써야 합니다.
- 기존의 데이터를 다룰 때, 데이터 길이에 대한 검증 로직을 명시적으로 구현하여 예외 상황을 사전에 대응할 수 있도록 하는 것이 좋습니다.

#### 개선 사항
- 길이 제한과 관련된 예외를 던지는 로직을 추가하여, 입력된 값이 길이를 초과할 경우 적절한 예외 메시지를 반환할 수 있도록 고려해볼 수 있습니다.
- 비즈니스 로직 변경에 대비하여, configurable한 방식으로 최대 길이를 조정할 수 있는 방법을 고민해볼 수 있습니다. 예를 들어, 설정 파일에서 값을 읽어와 동적으로 길이를 결정할 수 있게 한다면 향후 유지보수 및 확장성에 도움이 될 것입니다.

#### 결론
- 전체적으로 이번 변경 사항은 필요성과 정확성을 갖춘 유효한 변화를 이뤄냈습니다. 소프트웨어의 품질과 안정성을 높이는 데 기여할 것입니다. 특정 예외 처리와 문서화를 추가하여 가독성과 유지보수성을 더욱 향상시킬 수 있는 방향으로 개선할 것을 추천드립니다.

건강한 코드 유지보수를 위한 지속적인 노력이 필요합니다. 잘 해주셨습니다!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-11 17:58:14.650315', 2, '2024-11-11 17:58:14.650315', 3, '## 코드 리뷰

### 변경 사항 요약

주요 변경사항:
1. `RegenerateReviewRequest` DTO 구조 변경:
   - 필드에 `projectId`와 `gitlabMrIid` 추가
2. `regenerateReview` 메소드의 시그니처 변경:
   - `mrInfoId` 대신 `projectId`와 `gitlabMrIid` 사용

### 정확성
- `regenerateReview` 메소드에서 `mrInfo`를 조회하는 로직이 수정되었습니다. 이때, 기존의 `mrInfoId` 대신 `projectId`와 `gitlabMrIid`로 MR 정보를 조회하도록 변경되었는데, 이는 정보의 일관성을 높이는 좋은 접근입니다. 이 부분에서 Repository 메소드의 이름도 명확하게 되어 코드의 가독성이 향상됩니다.

### 가독성
- 코드에서 DTO의 필드 이름이 각기 다른 메소드 시그니처에서 사용되는 것이 더 명확해졌습니다. 각 매개변수의 이름이 잘 설명되어 있어, 후속 개발자가 intent를 쉽게 파악할 수 있습니다.
- `@Operation` 주석이 추가되어 API의 동작에 대한 설명이 잘 되어 있어 가독성이 좋습니다.

### 효율성
- 현재 변경 사항은 성능에 미치는 직접적인 영향은 크지 않아 보입니다. 대신, 더 많은 정보(`projectId`, `gitlabMrIid`)를 얻기 위해 조회를 다소 복잡하게 만드는 대신, 더 구조화된 데이터를 요청하는 것이므로 전체적인 효율성에는 긍정적인 영향을 미칠 것입니다.

### 확장성
- DTO를 변경하였기 때문에 추후 새로운 필드가 필요할 경우 더욱 쉽게 확장할 수 있는 구조가 되었습니다. 서로 다른 필드를 동일한 메소드에 통합하는 것은 코드 관리에서 장점을 가져옵니다.

### 코딩 표준 준수 여부
- 전체적으로 Java의 코딩 표준을 잘 준수하고 있는 것 같습니다. 메소드와 클래스의 네이밍 컨벤션이 일관되며, 적절한 접근 제어자가 지정되어 있습니다.

### 잠재적 버그 식별
- `regenerateReview` 메소드 및 `RegenerateReviewRequest` DTO를 사용할 때, 호출하는 측에서 변경된 필드에 대응하지 않는다면, 나중에 NPE(NullPointerException) 또는 잘못된 데이터를 전달할 위험이 있습니다. 이에 대한 방어적 코드를 작성하는 것이 좋습니다.
- 특히 `gitlabMrIid`와 `projectId`가 실제 존재하는 값인지 체크하는 로직이 필요합니다. 이를 통해 조회하고자 하는 MR 정보가 존재하는지를 확인하는 과정이 포함된다면, 안정성을 높일 수 있을 것입니다.

### 개선 제안
- 오류 처리를 좀 더 명확하게 처리할 수 있습니다. 예를 들어, `mrInfo`를 찾지 못할 경우에 대한 예외 처리를 추가하여, 클라이언트가 어떤 오류가 발생했는지 더 명확히 이해할 수 있도록 하면 좋습니다.
- 추가적으로, `regenerateReview` 메소드 내에서 `gitLabClient.getSingleMergeRequest`와 같은 외부 서비스 호출을 할 때, 응답 에러 상황에 대한 처리를 좀 더 명시적으로 작성하는 것이 좋습니다. 예외 발생 시 적절한 롤백과 오류 로그를 추가하는 것도 좋은 방안입니다.

### 결론
전반적으로 이 변경은 잘 구현되었으며, API의 요청 형식도 더 나은 방향으로 변화하고 있습니다. 다만, 위에서 언급한 개선사항을 반영하여 오류 처리를 강화하는 것이 필요합니다. 안정적이고 유지보수하기 쉬운 코드를 만드는 방향으로 최선을 다해주시면 좋겠습니다. 

리뷰 결과:
- [x] MR Approve
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 09:28:58.124573', 3, '2024-11-12 09:28:58.124573', 3, '## 코드 리뷰

1. **정확성**
   - `regenerateReview` 메소드에서 `mrInfo`를 조회하는 방식이 변경되었습니다. `mrInfoRepository.getById(mrInfoId)`에서 `mrInfoRepository.getByProjectIdAndGitlabMrIid(projectId, gitlabMrIid)`로 변경되어 올바르게 프로젝트 ID와 GitLab MR IID를 사용하여 `MrInfo`를 조회하도록 수정되었습니다. 이는 비즈니스 로직의 올바른 작동을 보장합니다.

2. **가독성**
   - 코드 변경사항에서 `RegenerateReviewRequest`의 필드가 `mrInfoId`에서 `projectId`와 `gitlabMrIid`로 변경되었습니다. 이는 API의 사용성을 증가시키는 것으로, 클라이언트가 더 많은 정보를 기반으로 요청할 수 있다는 장점이 있습니다.
   - 메소드의 파라미터에 대한 주석을 추가하면 더욱 가독성을 높일 수 있습니다. 예를 들어, `projectId`와 `gitlabMrIid`의 목적에 대한 설명을 추가할 수 있습니다.

3. **효율성**
   - 쿼리에서 프로젝트 ID와 GitLab MR IID를 동시에 사용하여 `MrInfo`를 조회하는 것은 불필요한 데이터 불러오기를 줄여 효율성을 높입니다. 이로 인해 데이터베이스의 부담이 줄어들 수 있습니다.

4. **확장성**
   - DTO 구조가 변경되었으므로 이 변경이 다른 부분에 영향을 미칠 수 있습니다. 예를 들어, 새로운 파라미터가 추가되므로 이와 관련된 모든 호출처를 수정해야 합니다. 이를 염두에 두어야 합니다.
   - `RegenerateReviewRequest`에서 추가된 `projectId`와 `gitlabMrIid`는 미래의 기능 확장에 도움이 되는 중요한 정보입니다.

5. **코딩 표준 준수**
   - Java의 코딩 표준은 잘 지켜지고 있으며, 코드 스타일은 일관성을 가지고 있습니다. 다만, 변수명이나 새로운 필드에 대해 더 구체적이고 의미 있는 이름 사용을 고려해 볼 수 있습니다 (예: `gitlabMrIid`는 `mergeRequestIid`로 명확히 하는 것이 좋습니다).

6. **잠재적인 버그**
   - JSON 파싱 시 발생할 수 있는 `JsonProcessingException`에서 런타임 예외(RuntimeException)를 던지도록 수정하였습니다. 이로 인해 예외의 원인 추적이 어려워질 수 있으므로, 커스텀 예외를 정의하고 적절한 메시지를 포함하는 것이 좋습니다.
   - 트랜잭션 관리를 위한 `@Transactional` 애너테이션이 사용되고 있지만, 메소드의 내용이 복잡해질 경우 롤백 조건을 명시적으로 설정하는 것이 필요할 수 있습니다.

7. **개선 제안**
   - `regenerateReview` 메소드를 더 작은 단위로 나누어 가독성을 높이고, 유지 보수성을 강화할 수 있습니다. 예를 들어, `getMrInfo, getGitlabAccount, getMrDiffs` 등의 보조 메소드를 만들어서 각 작업을 분리할 수 있습니다.
   - 클라이언트 쪽에서의 오류 처리 및 유효성 검증 로직을 강화할 필요가 있습니다. 특히, 새로 추가된 `projectId`와 `gitlabMrIid`에 대한 검증이 필요합니다.
   - 로그를 통해 더 많은 정보를 남길 수 있습니다. 예를 들어, 어떤 값으로 `ReviewRegenerateRequestMessage`를 생성했는지 상세한 로그를 남기는 것이 좋습니다.

이러한 피드백을 종합적으로 고려하여 추가적인 개선을 진행할 수 있습니다. 유지 보수성과 확장성을 더욱 높이는 방향으로 코드와 아키텍처를 발전시켜 나가기를 권장합니다.');
INSERT INTO public.review VALUES ('2024-11-12 09:49:34.049261', 4, '2024-11-12 09:49:34.049261', 3, '코드 리뷰를 진행하겠습니다. 주어진 코드는 리팩토링이 이루어진 것으로 보이며, 리뷰 요청사항이 MR 승인인 것으로 이해했습니다. 주요 변경사항 및 리뷰 면에서 몇 가지 포인트를 짚어보겠습니다.

### 변경사항에 대한 리뷰

1. **DTO 변경**: 
   - `RegenerateReviewRequest`에 `projectId`와 `gitlabMrIid`가 추가된 점은, 메소드 시그니처를 더욱 명확하게 하여 관련 정보를 그룹화하는 데 도움을 줍니다. 이는 가독성을 높이는 긍정적인 변화입니다.

2. **메소드 서명 변경**:
   - `regenerateReview` 메소드의 인자들도 이러한 변경에 맞춰 수정되었습니다. 이렇게 변경된 API는 보다 명확하게 각 인자의 역할을 드러내고 있습니다.
   - 또한 이제 `mrInfoId`를 직접 사용하지 않고 `projectId`와 `gitlabMrIid`로 MR 정보를 취득하고 있어, `MR` 정보 조회를 위해 데이터베이스를 더 안전하게 다루는 방식으로 개선되었습니다.

### 코드 가독성

- 변수 및 메소드 이름이 직관적이며, 코드의 목적이 명확하게 드러나 있는 점이 긍정적입니다.
- 로그 메시지 및 예외 처리에서 적절하게 정보를 기록하고 있어, 코드의 유지보수성을 높입니다.

### 효율성

- 현재 변경된 코드를 통해 MR 정보를 처음부터 전부 가져오는 방식으로 리팩토링 되었으며, 이는 성능에 미치는 영향이 미비할 것으로 보입니다. 하지만 `mrInfoRepository.getByProjectIdAndGitlabMrIid` 메소드가 적절한 인덱스를 활용하고 있는지 확인해야 할 필요가 있습니다.

### 확장성 및 유지보수성

- `RegenerateReviewRequest` DTO에 추가된 필드들은 향후 변경 사항에 대한 유연성을 제공할 것으로 기대됩니다. 
- 향후 프로젝트 등에서 GitLab의 특정 API 정보를 더 가져오고 싶다면 이 DTO에 쉽게 필드를 추가할 수 있어, 인터페이스가 입력을 재사용 가능하게 되어 유지보수성이 높아질 것입니다.

### 잠재적 개선 사항

- `handleReviewResponse` 메소드에서 `ObjectMapper`의 `readValue` 호출 시 JSON 파싱이 실패하는 상황에서 RuntimeException을 던지는데, 이보다는 커스텀 예외를 정의하고 명확한 에러 메시지를 제공하는 것이 좋습니다.
- 각 서비스 메소드에서 유효성 검사를 수행하는 방법을 고려해보세요. 예를 들어, `regenerateReview` 메소드에서 `retrievals` 리스트가 비어 있는지 여부를 점검하여 사전에 잘못된 요청을 방지할 수 있습니다.

### 종합 의견

변경 사항에 대해 전반적으로 긍정적인 결과를 내고 있으며, 코드의 가독성과 명확성을 높이는 방향으로 잘 구현되었습니다. 앞으로 더욱 확장 가능하고, 유지보수가 용이한 방식으로 계속해서 개선된다면 매우 좋은 결과를 가져올 것으로 기대합니다. MR 승인에 적합하다고 판단됩니다.');
INSERT INTO public.review VALUES ('2024-11-12 09:53:01.176513', 5, '2024-11-12 09:53:01.176513', 2, '### 코드 리뷰

#### 1. 정확성
- Custom Prompt의 content 길이를 1000자로 제한한 변경은 비즈니스 요구에 적합해 보입니다. 그러나 이로 인해 예외 처리나 유효성 검사에 대한 추가 고려가 필요할 수 있습니다. 예를 들어, 사용자가 1000자를 초과하는 내용을 입력할 경우 적절한 오류 메시지를 제공하고 요청을 차단하는 로직이 필요합니다. 

#### 2. 가독성
- 새로 추가된 `@Column(length = 1000)` 주석은 간결하고 이해하기 쉬우며, 이 필드의 신속한 파악을 돕습니다. 
- 한편, 코드 상의 일관성을 위해 기존의 필드 주석 스타일도 함께 정비하는 것이 좋습니다. 특정 주석 방식을 일관되게 사용하는 것은 코드를 더 쉽게 이해하도록 돕습니다.

#### 3. 효율성
- 데이터베이스에서 content 길이를 제한하는 것은 메모리 사용이나 성능 측면에서 긍정적입니다. 그러나 데이터베이스 레벨에서의 추가적인 유효성 검사를 고려해야 할 것입니다. 예를 들어, 데이터베이스에 데이터를 삽입하거나 업데이트할 시, 1000자를 초과하는 내용을 막기 위한 로직이 적용되어야 합니다.

#### 4. 확장성
- 현재의 변경사항은 Custom Prompt의 content에 대한 길이 제한을 도입하는 것이므로 향후 요구사항이 변경될 경우(예: 다양한 길이 제한 필요)가 발생할 수 있습니다. 이 경우, 이러한 제한을 코드에 하드코딩하는 것보다 설정 파일이나 환경변수에서 관리하도록 하는 것이 유연성을 증가시킬 수 있습니다.

#### 5. 코딩 표준 준수 여부
- 코드의 전반적인 스타일은 일관되며, Spring과 JPA의 표준 관례를 따르고 있습니다. 하지만 모든 도메인 클래스에서 JPA 어노테이션에 대한 주석을 작성하는 것을 고려해보면 좋습니다. 이를 통해 코드 유지보수성을 높일 수 있습니다.

#### 6. 잠재적인 버그
- Custom Prompt의 content가 1000자를 초과할 시 예외 처리가 체계적으로 이루어지지 않는 경우, 데이터베이스 오류가 발생할 수 있습니다. 이 부분에 대한 예외 처리 로직을 추가하는 것이 좋습니다.

#### 7. 개선 사항
- 유효성 검사 추가: `updateCustomPrompt` 메서드에 content 길이에 대한 유효성 검사를 추가하여 길이 초과 시 클라이언트에게 적절한 오류 메시지를 반환하도록 개선합니다.
- 테스트 케이스 추가: content 길이 제한에 대한 테스트 케이스를 작성하여, 예외가 정상적으로 발생하는지 확인합니다.
- 구성 파일 사용: 길이 제한을 하드코딩하는 대신, 애플리케이션의 설정 파일에서 관리할 수 있도록 개선합니다.

### 결론
변경된 내용이 필요한 비즈니스 로직에 적합하지만, 예외 처리 및 유효성 검사와 관련된 부분을 개선하여 시스템의 안정성과 가독성을 높일 것을 권장합니다. 이러한 수정 사항들이 코드의 유지보수성에도 긍정적인 영향을 미칠 것입니다. MR 승인 전에 이러한 개선 사항 반영을 권장합니다.');
INSERT INTO public.review VALUES ('2024-11-12 10:27:13.036959', 6, '2024-11-12 10:27:13.036959', 4, '# 코드 리뷰

## 전반적 평가

이 코드 변경사항은 리뷰 재생성 API 및 기타 기능의 개선을 포함하고 있습니다. 전체적으로 기능적 요구사항을 충족하며, 리팩토링 및 최적화가 이를 지원하는 좋은 접근이라고 생각됩니다. 그러나 여러 가지 성능과 가독성을 고려한 개선 가능성이 있습니다.

## 세부 사항

### 1. 정확성

- **메서드명 개선 필요**: `makeCodeReviewWhenCalledByWebhook`와 같은 긴 메서드명을 좀 더 명확하고 간결하게 줄일 수 있습니다. 메서드가 무엇을 하는지 잘 표현하는 이름으로 바꾸면 코드 가독성이 개선됩니다.
  
### 2. 가독성

- **주석의 일관성**: 주석이 명확하긴 하지만, 특정 코드 블록이 어떤 역할을 하는지 간단한 설명을 추가하면 가독성이 더 높아질 수 있습니다. 예를 들어 “// 1. MrInfo 저장” 같은 간단한 설명이 좋습니다.
  
- **우선순위에 따른 정렬**: 코드 내에서 프로퍼티나 변수를 선언하는 순서가 일관되게 기준이 효과적으로 정리된 것 같습니다. 그러나 비슷한 변수는 묶어서 선언하거나 사용하려는 범위 앞에 선언하는 것이 가독성에 도움이 될 것입니다.

### 3. 효율성

- **중복 코드 제거**: `getSingleMergeRequest`와 `getMrDiffs`를 호출하는 부분이 여러 다른 메서드에서 중복되고 있습니다. 이 두 메서드를 호출하는 부분을 별도의 헬퍼 메서드로 분리하면 중복을 줄여 코드가 깔끔해질 것입니다.

- **스트림 사용**: `toList()` 같은 스트림 처리를 사용할때 가용한 가독성이 좋지만, 성능을 위해서 `Collectors.toList()`를 사용해도 좋을 것 같습니다.

### 4. 확장성

- **매직 스트링과 상수화**: 사용된 문자열, URL 경로, API 키 등은 상수화하여 관리하는 것이 좋습니다. 이렇게 하면 코드가 변경될 때 한 곳에서만 수정하면 되므로 향후 유지보수에 유리합니다.

- **타입 안전성 고려**: TypeScript를 사용하기 때문에 모든 API 요청 및 응답에 대한 type을 생성하고 참조하는 것이 중요합니다. `ReferenceRequest`와 같은 타입 정의는 코드의 안정성과 가독성을 더해줄 수 있습니다.

### 5. 예외 처리 개선

- **에러 핸들링**: API 호출 때 발생할 수 있는 에러를 처리하는 방식에 대해 로그를 통해 사용자가 이해하기 쉽게 작성하면 좋습니다. 현재는 서버 에러에 대한 사용자 친화적인 메시지가 부족합니다.

### 6. 테스트 코드를 통한 신뢰성 개선

- **테스트 작성**: 변경된 코드에 대한 테스트 케이스가 포함되어 있는지 확인해야 합니다. 각 기능에 대해 잘 테스트되어야 하며, 특히 주요 로직에 대해서는 경계 케이스도 포함하여 테스트하도록 합니다.

## 결론

전반적으로 코드 변경사항은 확장성과 기능성을 갖춘 구조로 보이며, 코드의 가독성과 효율성을 높이기 위해 몇 가지 제안을 드렸습니다. 제안된 개선사항을 적용하면 코드 품질이 더욱 향상되고 유지보수성이 증가할 것입니다. 필요 시 추가적인 리뷰가 필요하면 언제든지 요청해 주시기 바랍니다!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 10:42:29.745155', 7, '2024-11-12 10:42:29.745155', 5, '코드 변경 사항에 대해 상세하게 리뷰하겠습니다. 이는 코드의 정확성, 가독성, 효율성, 확장성, 코딩 표준 준수 여부 및 잠재적 버그에 대해 평가합니다.

### 1. 정확성
- 기본 라벨 `defaultLabels`를 `labels`로 설정하는 부분에서, 모든 데이터가 기본 라벨을 따릅니다. 만약 사용자 정의 라벨이 항상 필요 없다면 이 접근법은 타당할 수 있으나, 다른 라벨을 사용해야 할 경우 이 점검이 필요합니다. 더 나은 유연성을 제공하기 위해 사용자 정의 라벨을 허용하도록 고려해볼 수 있습니다.
  
### 2. 가독성
- `defaultLabels`를 상단에 선언한 것은 가독성을 높이는 좋은 방법입니다. 그러나 해당 배열이 하드코딩되어 있는 점은 유지보수성에 영향을 줄 수 있습니다. 나중에 라벨 값이 변경될 경우 모든 코드에 영향을 줄 수 있기 때문입니다. 
- 코드에서 주석이 부족합니다. 특정 변경 사항이나 함수의 목적을 설명하는 주석을 추가하면, 향후 개발자가 코드를 이해하는 데 도움이 될 것입니다.

### 3. 효율성
- `data` 계산 부분에서 `find` 메소드를 사용하고 있습니다. 이는 O(n) 시간복잡도를 가지므로, 만약 데이터의 양이 많아지면 성능의 병목이 될 수 있습니다. 예를 들어, 사용자 점수 배열을 미리 맵으로 변환하는 방식으로 시간 복잡도를 줄일 수 있습니다.
- 특히, `map`과 `find`를 함께 사용할 경우, 데이터 양이 많을수록 성능 저하가 생길 수 있으니, 성능 측면에서 대안을 고려하는 것이 좋습니다.

### 4. 확장성
- 현재 구현은 고정된 기본 라벨을 사용하고 있습니다. 만약 나중에 라벨을 추가하거나 수정할 필요가 있다면 이를 관리하는 로직이 필요합니다. 가능한 경우, 기본 라벨을 설정할 수 있는 별도의 설정 파일이나 데이터베이스 등을 사용하는 것도 좋은 방법입니다.
- UI 및 API가 변경될 경우 시스템 전반에 미치는 영향을 고려하여 해당 시간 로직을 정리하는 것이 필요합니다.

### 5. 코딩 표준 준수
- 전체적으로 일관된 스타일을 유지하고 있습니다. 하지만, 예를 들어 CSS 클래스 명명 규칙(예: BEM 방법론)을 고려하여 일관성을 더 높일 수 있는 부분이 있습니다.
- 파일 맨 위에 필요한 패키지가 import되어 있는지 확인하고, 사용되지 않는 import는 정리하는 것이 좋습니다.

### 6. 잠재적인 버그
- `fetchProjectTeamScore` API 호출에서 에러 처리가 누락되어 있습니다. 네트워크 요청에서 오류가 발생할 경우 이를 처리하는 로직이 필요합니다. 
- 각 버튼 클릭 시 예상치 못한 동작을 방지하기 위해 이벤트 핸들러에서 `preventDefault()`를 사용하여 기본 동작을 차단하는 것이 좋습니다. 

### 결론
전반적으로 기능 변경이 관련된 코드에 대한 전반적인 재구성이 필요합니다. 데이터 처리의 유연성과 효율성을 염두에 두고 코드의 가독성과 유지보수성을 높이는 방향으로 개선할 수 있습니다. 이러한 리뷰와 피드백이 향후 개발 방향을 설정하는 데 도움이 되길 바랍니다. 

MR은 주의 깊은 검토가 필요한 지점이 많으므로, 변경을 적용하기 전에 추가적인 수정이 필요할 것 같습니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 12:12:39.712122', 84, '2024-11-13 12:12:39.712122', 19, '안녕하세요냥! 코드 리뷰를 시작할게요냥. 아래는 각각의 평가 항목에 대한 점수와 피드백이니 잘 읽어봐주세요냥.

### 1. Readability (가독성)
**점수: 8/10**

- **잘 수행된 부분**: 전체적으로 코드가 직관적이고, 변수명과 함수명이 명확하게 의미를 전달하고 있어요냥. 특히, `GitlabMrResponse`와 같은 데이터 클래스는 잘 정의되어 있어서 이해하기 쉬워요.
- **개선이 필요한 부분**: 코드에 주석이 별로 없어 보이는데, 일부 함수의 동작에 대해 간단한 설명이 추가되면 가독성이 더욱 높아질 것 같아요냥. 특히 복잡한 로직이 포함된 부분에는 주석이 아주 유용할 거예요.

### 2. Consistency (일관성)
**점수: 9/10**

- **잘 수행된 부분**: 명명 규칙이나 코드 스타일이 전체적으로 일관되게 적용되고 있어요냥. 메서드와 클래스 이름의 카멜 케이스(CamelCase) 사용도 잘 지켜지고 있네요.
- **개선이 필요한 부분**: 특정 부분에서 변수명이 약간 다르게 사용되는 경향이 있는데, 예를 들어 `gitlabMrIid`와 `iid`와 같은 동의어를 통일하여 사용하는 것이 더 좋을 것 같아요냥. 

### 3. Reusability (재사용성)
**점수: 7/10**

- **잘 수행된 부분**: 메서드가 잘 분리되어 있어 각 메서드가 독립적인 기능을 수행하고 있어요. 이것은 코드의 재사용성과 유지보수성을 높이는 데 도움이 돼요.
- **개선이 필요한 부분**: 일부 기능은 더 작은 단위로 나누어 재사용 가능성을 높이는 것이 좋을 것 같아요. 예를 들어, `getMrDiffs`와 같은 메서드는 다른 종류의 기능에서도 사용될 수 있도록 일반화할 수 있는 여지가 있어요.

### 4. Reliability (신뢰성)
**점수: 7/10**

- **잘 수행된 부분**: 데이터베이스에서 값을 조회할 때 적절한 메서드를 사용하고 있으며, 의도한 대로 데이터가 조작되는 것 같아요.
- **개선이 필요한 부분**: 예외 처리가 다소 부족한 것 같아요. 외부 API 호출이나 데이터베이스 조회 시 예외를 처리할 수 있는 코드가 추가되면 더 안전한 코드가 될 수 있어요냉. 예를 들어, `restTemplateUtil.sendGetRequest` 호출 시 오류가 발생할 경우에 대비한 처리가 필요해요.

### 5. Security (보안성)
**점수: 8/10**

- **잘 수행된 부분**: API 호출 시 토큰을 사용하여 인증을 하고 있어서 기본적인 보안이 충족되고 있어요냥.
- **개선이 필요한 부분**: 사용자 입력에 대한 검증이 부족해 보이는데, 각 메서드의 입력 매개변수에 대해 유효성 검사를 추가하면 보안성이 더 강화될 것 같아요. 예를 들어, `userId`와 같은 값은 예상 범위 내인지 확인하는 것이 좋겠어요.

### 6. Maintainability (유지보수성)
**점수: 8/10**

- **잘 수행된 부분**: 메서드 구조가 잘 분리되어 있어, 특정 기능을 변경하거나 추가하는 과정이 비교적 수월할 것으로 보이네요냥.
- **개선이 필요한 부분**: 특정 클래스가 너무 많은 책임을 지고 있는 경향이 있어 보여요. 예를 들어, `MergeRequestService`가 너무 많은 기능을 포함하고 있다면, 이것을 여러 개의 서브 클래스로 나누어 단일 책임 원칙(SRP)을 확립하는 것이 바람직해 보여요.

### 전체적인 피드백
코드 전반적으로 잘 작성된 부분이 많아서 긍정적으로 평가해요냥. 특히, 각 기능이 잘 분리되고 이름이 명확한 점은 사용자에게 큰 성취감을 줄 것 같아요. 그러나 예외 처리와 유효성 검증 같은 보안적인 부분에서 개선할 점이 있기 때문에 여기에 조금 더 집중해주면 좋을 것 같아요. 

마지막으로, 주석을 통해 코드 내용을 조금 더 설명해주면 가독성도 높일 수 있으니 앞으로의 작업에서 고려해주시면 좋을 듯 해요냥. 계속해서 멋진 코드 작성해주길 기대할게요냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:13:11.775309', 85, '2024-11-13 12:13:11.775309', 19, '안녕하세요, 냥냥 체 리뷰를 시작해 볼게요!

## 1. Readability (가독성) 
**점수: 8/10**
- **잘 수행된 부분**: 변수명과 함수명이 대부분 의미가 명확하여, 코드의 의도를 파악하기 용이해요. 예를 들어 `getBestMergeRequests`는 이 함수가 뭘 하는지 명확하게 나타내네요.
- **개선해야 할 부분**: 몇몇 메소드와 변수에 대한 주석이 부족해요. 특히 복잡한 로직을 수행하는 부분에 간단한 주석을 추가하면 이해하는 데 도움이 될 것 같아요. `makeCodeReviewWhenCalledByWebhook` 메소드는 특히 여러 단계가 나열되어 있어 독자가 추가적인 контекст를 이해하는데 도움이 필요할 것 같아요.

## 2. Consistency (일관성)
**점수: 9/10**
- **잘 수행된 부분**: 코딩 스타일과 명명 규칙이 전반적으로 잘 유지되고 있어요. Camel Case와 같은 표준 규칙을 잘 따르고 있네요.
- **개선해야 할 부분**: 파일 사이에 일관되지 않은 주석 스타일 혹은 공백이 보일 수 있어요. 예를 들어, 어떤 파일에서는 메소드 간 줄바꿈이 없고, 또 다른 파일에서는 과하게 줄바꿈이 있을 때가 있어요. 코드 리뷰어와 팀원이 함께 적절한 가이드라인을 설정하면 좋을 것 같아요.

## 3. Reusability (재사용성)
**점수: 7/10**
- **잘 수행된 부분**: 많은 기능이 독립적인 메소드로 잘 나누어져 있어 다른 곳에서 쉽게 재사용할 수 있도록 되어 있어요.
- **개선해야 할 부분**: `buildGitlabMrResponses`나 `createGitlabMrResponse` 같은 메소드에서 비슷한 로직을 반복적으로 사용하는 경향이 보여요. 이러한 부분은 헬퍼 클래스를 만들어서 중복 코드를 없애면 좋을 것 같아요.

## 4. Reliability (신뢰성)
**점수: 8/10**
- **잘 수행된 부분**: 주요 비즈니스 로직이 포함된 메소드들은 적절하게 작동할 것으로 보이며, 일반적인 경우를 잘 처리합니다.
- **개선해야 할 부분**: 예외 처리 부분이 조금 더 강화되면 좋겠어요. 예를 들어, 외부 API 호출 시 응답이 없거나 에러가 발생했을 때의 처리가 강력하게 이루어져야 하므로, 적절한 오류 메시지를 통해 사용자에게 알릴 수 있는 로직이 필요할 것 같아요.

## 5. Security (보안성)
**점수: 8/10**
- **잘 수행된 부분**: API 호출 시 토큰이나 중요한 정보를 잘 숨겨서 사용하고 있어요. 
- **개선해야 할 부분**: 입력 검증과 유효성 검사 부분이 조금 느슨한 것 같아요. 특히 외부 API에 사용자 입력을 넘길 때는, 해당 입력값을 검증하고 필터링하는 로직을 추가하는 것이 좋을 것 같아요.

## 6. Maintainability (유지보수성)
**점수: 9/10**
- **잘 수행된 부분**: 코드가 잘 모듈화 되어 있고, 팀원이나 후속 개발자가 이해하기 쉽게 설계되어 있어요. 의존성 주입을 통해 접근성을 높이고 있는 점도 긍정적이에요.
- **개선해야 할 부분**: 하나의 메소드가 너무 많은 일을 담당하고 있는 경우가 일부 보이는데요, 단일 책임 원칙을 맞추기 위해 기능을 분리하는 것이 좋을 것 같아요.

### 전체적인 피드백
전반적으로 이 코드는 잘 작성되어 있는 부분이 많아요. 특히 가독성과 유지 보수성에서 높은 점수를 받아요. 하지만, 예외 처리와 재사용성 부분에서는 개선이 필요해 보여요. 각 메소드의 책임을 더욱 명확히 하고, 필요한 곳에 적절한 주석을 추가한다면 코드의 품질이 더욱 높아질 거예요. 정말 잘 하셨고, 앞으로도 이렇게 개선해 나간다면 더욱 더 좋은 코드가 될 것 같아요! 고생하셨습니다, 냥!');
INSERT INTO public.review VALUES ('2024-11-12 11:01:09.736242', 8, '2024-11-12 11:01:09.736242', 6, '## 코드 리뷰

### 변경 내용 요약
주요 변경 사항은 MR 리스트 조회 시 `assignee`가 `null`일 때의 처리를 추가한 점으로 보입니다. 이는 예외 상황에 대해 더욱 안정적인 코드를 유지하기 위한 개선으로, 전체적으로 긍정적인 변화입니다.

### 정확성
- `gitlabMrDetailContent.assignee()`가 `null`인 경우를 체크하는 로직을 추가하여, `NullPointerException` 발생 가능성을 제거했습니다. 이는 코드의 안정성을 높이는 좋은 접근입니다.

### 가독성
- 코드의 가독성을 고려할 때, 조건부 연산자(`? :`)를 사용하여 `assignee`가 `null`인지 체크하는 부분은 명확하게 표현되어 있습니다. 하지만, 코드가 길어질 경우 가독성이 저하될 수 있으므로, 필요시 별도의 메서드로 분리하는 것도 고려해볼 수 있습니다. 예를 들어, `createAssigneeInfo(gitlabMrDetailContent.assignee())`와 같은 별도의 메서드를 만들면 가독성이 더욱 향상될 수 있습니다.

### 효율성
- 성능적으로 큰 문제는 없어 보입니다. `null` 체크를 통해 불필요한 객체 생성을 방지할 수 있으므로 효율적인 변화입니다.

### 확장성
- 현재 구조는 나중에 `assignee` 처리 로직을 확장해야 할 경우, 메서드를 분리하지 않으면 복잡해질 가능성이 있습니다. 필요시, `GitlabUserInfoContent`를 생성하는 전용 메서드를 만들거나, `assignee` 처리 로직을 비즈니스 로직으로 분리하는 것이 좋습니다.

### 코딩 표준 준수
- 코드 작성 스타일은 일관되며, 가독성이 좋습니다. 들여쓰기와 공백 관리는 잘 되어 있습니다.
- ideally, 각 변수 혹은 메서드의 설명을 주석으로 추가하면 다른 개발자들이 이해하는 데 도움이 될 수 있습니다.

### 잠재적 버그
- 현재 코드에서 잠재적인 버그는 보이지 않지만, `assignee`, `reviewers` 등의 필드에 대한 더 많은 검증이 필요할 수 있습니다. 이를 통해 API 응답 형식 변경에 따른 문제가 발생하지 않도록 방지할 수 있습니다.

### 결론
- 전반적으로 안정성을 높이는 유의미한 개선이며, 향후 확장성에 대한 고려가 더해진다면 더욱 효과적일 것입니다. 몇 가지 가독성과 유지보수성에 관련된 피드백을 반영하면 코드의 질을 더욱 높일 수 있을 것으로 보입니다.

#### 최종 의견
- [X] MR Approve

해당 코드는 긍정적으로 리뷰하며, 제안된 개선사항을 고려해보시면 좋겠습니다. 이를 통해 팀원 간의 협업과 코드 유지보수에 도움을 줄 수 있을 것입니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 11:04:24.692463', 9, '2024-11-12 11:04:24.692463', 2, '변경된 코드에 대한 리뷰를 진행하겠습니다.

## 코드 리뷰

### 1. 변경사항의 긍정적 측면
- **길이 제한 추가**: `content` 필드에 `@Column(length = 1000)` 어노테이션을 추가하여 최대 길이를 명시한 점은 데이터 무결성을 유지하고, 예기치 않은 데이터 입력으로 인한 오류를 방지하는 좋은 접근입니다. 

### 2. 코드 정확성
- `CustomPrompt` 클래스에 `content` 필드의 길이를 제한하는 변경은 전반적으로 문제를 일으키지 않을 것으로 보입니다. 그러나, 해당 속성의 길이 제한을 어길 경우 발생할 수 있는 예외 처리에 대한 고려가 필요합니다. 예를 들어, 이 필드에 대해 `@Size` 어노테이션을 추가하여 입력 Validation을 강화할 수 있습니다.

### 3. 가독성
- 코드는 명확하게 작성되었으며, 잘 구조화되어 있어 가독성이 좋습니다. `content`의 길이 제한을 지정하는 어노테이션이 추가된 점은 클래스의 다른 필드를 이해하는 데에도 도움이 됩니다.

### 4. 효율성 및 성능
- 길이 제한이 추가되며 이로 인해 데이터베이스의 저장 공간이 적절히 관리될 수 있습니다. 지나치게 긴 문자열의 입력을 방지함으로써 저장소 효율성이 향상될 것입니다.

### 5. 확장성
- 해당 필드에 대한 길이 제한은 다른 기능이나 변경사항에 크게 영향을 미치지 않을 것입니다. 그러나 서비스가 발전하면서 길이 제한이 더 필요하거나 변경되어야 할 경우에 대비해 관련 문서나 주석을 추가하는 것이 좋겠습니다.

### 6. 코딩 표준 준수 여부
- 코드는 회사의 표준과 일관성을 유지하고 있습니다. 어노테이션 사용 및 변수명 명명 규칙에 잘 따르고 있습니다.

### 7. 잠재적인 버그
- `content`의 길이 제한을 클라이언트 요청시 Validation을 추가하지 않은 경우, 서버에서 잘못된 길이의 문자열을 처리할 수 있습니다. 클라이언트에서 유효성 검사를 이루어지는 것이 필요할 수 있으며, 이를 위한 적절한 예외 처리를 구현하는 것이 좋습니다.

### 개선 사항
- `content` 필드에 대한 유효성 검사를 추가하여, 데이터베이스에 저장되기 전에 올바른 길이를 갖도록 필터링하는 것을 추천합니다.
- 관련 문서에 길이 제한의 필요성과 그 이유를 명시하여, 향후 유지보수나 다른 개발자가 이해하기 쉽게 해주는 것이 좋습니다.

위의 피드백을 바탕으로 추가적인 수정이나 개선 작업을 진행할 수 있습니다. 변경사항에 대한 승인 요청은 적절히 반영되었음을 판단하여 결론 내리면 좋겠습니다. 

좋은 작업입니다!');
INSERT INTO public.review VALUES ('2024-11-12 11:19:02.740745', 10, '2024-11-12 11:19:02.740745', 6, '코드 리뷰를 진행하겠습니다. 다음은 제공된 코드 변경사항에 대한 평가입니다.

## 변경 코드 리뷰

### 1. 정확성
- **null 검사 추가**: `assignee`가 `null`인 경우를 처리하는 로직이 추가되었습니다. 이는 코드의 안정성을 향상시킵니다. `null` 체크를 통해 `NullPointerException`을 예방할 수 있으므로, 이는 적절한 개선입니다.

### 2. 가독성
- **삼항 연산자 사용**: `assignee`의 null 여부를检查하기 위해 삼항 연산자가 사용되었습니다. 이 방식은 간결하지만, 가독성을 약간 떨어뜨릴 수 있습니다. 가능하다면, null 체크를 별도의 메소드로 추출하여 명확하게 표시하는 것이 좋습니다. 예를 들어:
  ```java
  private GitlabUserInfoContent getAssigneeContent(GitlabUserInfo assignee) {
      return assignee == null ? null : new GitlabUserInfoContent(assignee.username(), assignee.name(), assignee.avatarUrl());
  }
  ```

### 3. 효율성
- **효율성 개선**: null 체크를 추가한 것은 적절한 개선으로, 실행 시간에는 큰 변경을 주지 않으나 시스템 안정성에 긍정적인 영향을 미칩니다.

### 4. 확장성
- **확장성 유지**: 현재 코드 변경은 기존 구조를 해치지 않으며, 향후 `assignee` 관련 기능이 확장될 경우에도 큰 영향을 미치지 않을 것으로 보입니다.

### 5. 코딩 표준 준수
- **표준 준수 확인**: 제공된 코드가 통일된 형식을 따르고 있으며, 명명 규칙도 일관성을 유지하고 있습니다. 다만, `assignee` 핸들링을 좀 더 명시적인 형태로 작성하는 것을 추천합니다.

### 6. 잠재적인 버그
- **현재 잠재적 버그 없음**: null 체크를 추가한 결과로, 현재 구현에서 나타날 수 있는 잠재적 버그는 사라졌습니다. 

## 개선 사항 제안
1. **가독성 향상**: null 검사 로직을 별도의 함수로 분리하여 메서드 이름이 의도를 명확하게 알 수 있도록 하십시오.
   
2. **주석 추가**: 변경된 부분에 간단한 주석을 추가하여 다른 개발자들이 이 코드의 목적과 왜 이렇게 작성되었는지 이해할 수 있도록 돕는 것이 좋습니다.

3. **시험 추가**: `assignee`가 null인 경우를 포함한 단위 테스트를 작성하여 이 변경사항이 의도한 대로 동작하는지 검증하는 것이 좋습니다.

### 결론
전반적으로 변경 사항은 긍정적이며 코드의 안전성을 강화했습니다. 가독성을 더욱 높이는 방향으로 약간의 개선이 필요합니다. 이와 관련된 변경 사항에 대한 최종 승인인 `MR Approve`를 요청하신 부분은 명확한 승인이 가능할 것으로 보이며, 이 피드백을 바탕으로 개선하면 좋겠습니다.');
INSERT INTO public.review VALUES ('2024-11-12 13:05:18.397392', 11, '2024-11-12 13:05:18.397392', 7, '### 코드 리뷰

#### 1. 변경사항 요약
변경된 코드에서는 DTO에 대한 유효성 검사를 적용하기 위해 여러 클래스에 `@NotNull`, `@NotBlank`, `@Valid` 어노테이션을 추가했습니다. 이러한 수정은 입력 데이터의 유효성을 검증하여 잠재적인 오류를 줄이는 데 기여할 것입니다.

#### 2. 정확성
- DTO와 관련된 값들에 대해 유효성 검사를 추가했기 때문에, 데이터의 무결성을 향상시킬 것으로 보입니다. `@NotNull`과 `@NotBlank` 어노테이션은 NullPointerException과 같은 오류의 가능성을 줄여주고, 클라이언트에게 유효하지 않은 데이터를 요청할 때 명확한 피드백을 줄 수 있습니다.

#### 3. 가독성
- 전반적으로, DTO에 대한 유효성 검사가 적용된 코드는 더 명확하고 가독성이 좋습니다. 이러한 수정은 그래픽적으로도 어떤 필드가 필수인지 드러내는 데 도움을 줍니다.
- 패키지와 임포트 구문이 깔끔하게 정리되어 있어 코드의 이해가 용이합니다.

#### 4. 효율성
- 요청 DTO에 대한 유효성 검사를 활용함으로써 잘못된 데이터가 서비스 레이어에 도달하기 전에 미리 차단할 수 있습니다. 이는 불필요한 비즈니스 로직 실행을 줄여 시스템의 전반적인 효율성을 높이는 데 기여합니다.

#### 5. 확장성
- 현재의 유효성 검사는 추가적인 필드를 DTO에 추가하더라도 유효성 검사 전략이 쉽게 확장될 수 있도록 만들어 줍니다. 장기적으로도 이 구조는 유지보수가 용이합니다.
- 하지만, 각 DTO마다 유효성 검사 규칙이 중복될 경우 코드의 중복이 발생할 수 있습니다. 이 점은 추후 공통 유효성 검사를 위한 커스텀 애노테이션이나 유효성 검사 클래스를 생성하는 방식으로 해결할 수 있습니다.

#### 6. 코딩 표준 준수 여부
- 코딩 표준에 잘 맞추어 작성되었습니다. 특히 명확한 변수명과 일관된 어노테이션 사용이 긍정적입니다.

#### 7. 잠재적인 버그
- 현재 보이는 잠재적인 문제는 없습니다. 다만, DTO가 확장될 경우와 예외 처리와 관련된 부분도 고려해야 할 것입니다. 클라이언트에게 적절한 에러 메시지를 반영하는 것이 중요합니다.

#### 8. 결론 및 추천
- 본 변경사항은 충분히 긍정적이며, 코드 유지보수성이 향상될 것입니다. 따라서, 이 MR은 승인할 것을 추천합니다.
- 향후 작업에서는 각 DTO의 유효성 검사 규칙을 재사용할 수 있는 방법을 모색하는 것이 더욱 바람직할 것입니다.

위의 내용이 코드 리뷰 결정에 도움이 되기를 바랍니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 13:12:52.569092', 12, '2024-11-12 13:12:52.569092', 8, '### 코드 리뷰 피드백

#### 1. 코드 정확성
- **GitlabWebhookController**의 `handleGitlabEvent` 메서드 내에서 GitLab 이벤트를 처리하는 방식이 명확하게 변경되었습니다. `switch` 표현식을 사용하여 다양한 이벤트 타입을 처리하는 것은 코드의 명확성과 가독성을 높이며, 새로운 이벤트 타입의 추가가 용이해졌습니다.
- `GitlabEventHandler`의 메서드 이름을 보다 구체적으로 변경하여 기능 이해를 돕고 있습니다. 예를 들어, `handleMergeRequest`와 `handlePush` 메서드는 각각의 이벤트에 적합한 책임을 잘 나타냅니다.

#### 2. 가독성
- 클래식 스타일의 `if-else` 문보다 `switch` 표현식을 사용하는 것이 코드 가독성을 향상시켰습니다. 이는 다양한 조건 분기를 명확하게 보여줍니다.
- 코드에 음악적 표현, 즉 메서드명이나 상수명이 좀 더 직관적이거나 설명적인 이름으로 변경되었습니다. 예를 들어, `MERGE_REQUEST_TYPE`, `PUSH_REQUEST_TYPE` 등의 상수 사용은 타입을 명확히 하고 코드의 의미를 잘 전달합니다.

#### 3. 효율성 및 확장성
- `GitlabEventHandler`에서는 합리적으로 새로운 이벤트 타입에 대한 핸들러를 추가할 수 있도록 `handlers` 맵을 사용할 수 있도록 설계되었습니다. 이는 새로운 주요 기능이나 요구 사항이 발생했을 때 쉽게 확장할 수 있는 구조입니다.
- 다만, 핸들러 간의 종속성이 줄어들기 때문에 각 핸들러의 책임을 명확히 하는 것이 중요합니다. 현재 구조는 이를 잘 반영하고 있습니다.

#### 4. 코딩 표준 준수
- 전반적으로 Java 코딩 표준에 잘 준수하고 있습니다. 메서드의 길이가 적당하고, 각 메서드는 자신에게 주어진 역할에 충실합니다. 
- `@Service` 및 `@Transactional` 애너테이션의 적절한 사용은 스프링의 권장 사항에 따릅니다.

#### 5. 잠재적 버그
- `GitlabWebhookController`의 `handleGitlabEvent` 메서드에서 `gitlabEventRequest`를 `@RequestBody`로 수신할 때, JSON 포맷의 요청 데이터가 유효하지 않은 경우에 대한 예외 처리가 부족합니다. 이는 400 Bad Request와 같은 상태를 명시적으로 처리할 필요가 있습니다. 이를 통해 클라이언트 요청이 전형적인 잘못된 형식일 경우 더욱 명확하게 응답할 수 있습니다.

#### 6. 개선할 부분
- 예외 처리 부분을 개선하여 명확한 응답을 클라이언트에게 반환하도록 할 수 있습니다. 예를 들어, JSON 파싱 오류 또는 필수 필드가 누락된 경우 적절한 에러 응답을 설정하는 것이 좋습니다.
- `@RequestBody`의 매개변수를 `String`에서 `GitlabEventRequest`로 바꾼 것은 좋은 변경입니다. 그럼에도 불구하고 유효성 검사 및 변환 로직에 대해 더 자세한 예외 처리를 고려해볼 수 있습니다.

#### 결론
코드 변경이 전반적으로 잘 이루어졌고, 명확하고 확장성이 뛰어난 구조입니다. 위에서 언급한 잠재적 버그와 개선할 부분에 대한 점검 후, 코드 수정이 이루어지면 더욱 완벽한 통합이 될 것입니다. 이 상태에서 MR을 승인할 것을 제안합니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:47:45.585206', 114, '2024-11-13 13:47:45.585206', 24, '우선 코드 변경 사항에 대해 전반적으로 잘 작성된 부분에 대해서 긍정적인 피드백을 드립니다. 테스트 코드가 명확하게 작성되어 있으며, `TypeScriptChunkStrategy`의 동작을 검증하는 데 필요한 테스트 케이스들이 잘 구성되어 있습니다. 특히, `assertEquals`와 `assertTrue`를 사용하여 결과를 검증하는 부분이 인상적이었습니다. 이러한 접근 방식은 코드의 정확성을 높이는 데 큰 도움이 됩니다.

다음은 각 항목에 대한 리뷰입니다.

### 1. Readability (가독성)
- **잘 수행된 부분**: 함수와 변수 이름이 명확하고 행동을 잘 설명하고 있습니다. 예를 들어, `testChunkingTypeScriptFile`는 기능을 잘 설명합니다. `normalize` 함수도 그 목적을 잘 설명하고 있어 가독성이 높습니다.
- **개선이 필요한 부분**: 코드에 대한 주석이 전반적으로 부족합니다. 특히 `testChunkingTypeScriptFile` 메소드 내부에 있는 핵심 검증 로직에 대한 설명을 추가하면 다른 개발자가 이해하기 더욱 쉬워질 것입니다. 예를 들어, 각 `assertEquals`와 `assertTrue` 호출 앞에 주석을 추가하여 어떤 이유로 이 값을 확인하고 있는지 설명하면 좋겠습니다.

### 2. Consistency (일관성)
- **잘 수행된 부분**: Java 코드 작성을 위한 일반적인 명명 규칙을 잘 따르고 있습니다. 클래스와 메소드 이름 모두 CamelCase 규칙을 잘 지키고 있습니다.
- **개선이 필요한 부분**: 파일과 디렉토리 이름이 Java의 네이밍 규칙에 따라 명확히 구분되어야 합니다. `TestTypescript.ts` 파일명이 PascalCase라면 `TestTypescript` 대신 `TestTypeScript`로 수정할 것을 권장합니다.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: `normalize` 함수는 범용적으로 사용될 수 있는 문자열 정리 로직으로, 다른 테스트 케이스에서도 재사용할 수 있습니다.
- **개선이 필요한 부분**: `TypeScriptChunkStrategy`를 테스트하는 데 필요한 데이터 설정이 `setUp` 메소드에 하드코딩되어 있습니다. 이러한 구조는 특정 상황에 맞춰져 있어 재사용성이 떨어질 수 있습니다. 테스트 데이터 생성을 위한 팩토리 메소드를 추가하면 재사용성을 높일 수 있습니다.

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 각 테스트가 명확한 기준을 가지고 있으며, 예상 결과와 실제 결과를 비교하는 로직이 잘 작성되어 있어 신뢰성이 높습니다.
- **개선이 필요한 부분**: 예외 처리 로직이 전혀 없습니다. 테스트 도중 오류가 발생할 경우 명확한 원인 파악이 어려울 수 있습니다. `chunk` 메소드에서 발생할 수 있는 예외를 처리할 수 있는 적절한 예외 처리를 추가하는 것이 좋습니다. 

### 5. Security (보안성)
- **잘 수행된 부분**: 현재까지의 코드에서 보안 관련 문제가 드러나지는 않았습니다.
- **개선이 필요한 부분**: 입력 검증 부분이 부재하여, 테스트 데이터가 올바른 형식이 아닐 경우 발생할 수 있는 잠재적 리스크가 존재합니다. `chunk` 메소드에 전달되는 `tsFile`이 유효한 파일인지 확인하는 코드를 추가하여 보안성을 강화할 필요가 있습니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 메소드가 기능에 따라 잘 분리되어 있어 변경 사항에 대한 경제성을 제공합니다.
- **개선이 필요한 부분**: 반복되는 테스트 로직이 많아, 변동 사항이 발생할 경우 유지보수가 어려울 수 있습니다. 이러한 로직을 공통 메소드로 분리하여 관리하면 유지보수성이 높아질 것입니다.

### 전체적인 피드백
코드는 전반적으로 잘 작성되었으며, 테스트 케이스가 강력하고 명확하게 구성되어 있어 좋습니다. 그러나 가독성과 유지보수성을 높이기 위해 추가적인 주석과 예외 처리, 그리고 재사용성을 고려한 구조가 필요합니다. 실제 유지보수 시에 불편함을 줄이기 위해 이러한 개선점을 고려하여 코드를 작성해 주시기 바랍니다. 여러분의 노력에 감사드립니다! 지금까지의 진행이 굉장히 긍정적이며, 전체적으로 좋은 방향으로 나아가고 있습니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-18 10:10:44.76912', 210, '2024-11-18 10:10:44.76912', 55, '`BestMrInfoResponse` 클래스를 추가하여 `mrInfoList`와 `startAndEndDates`를 묶은 것은 좋은 접근입니다. 그러나 다음과 같은 점을 고려해볼 수 있습니다:

1. **불변성**: `record`는 불변성을 제공하므로 좋지만, 불변성이 필요한 경우 변수들을 final로 선언하는 것도 좋은 습관입니다.
2. **유효성 검사**: 생성 시 입력값의 유효성을 검사하는 메소드를 추가하여 데이터 무결성을 유지할 수 있습니다.
3. **설명 주석**: 클래스와 필드에 간단한 설명 주석을 추가하여 코드 가독성을 높일 수 있습니다.
4. **네이밍**: `BestMrInfoResponse`의 네이밍이 적절하지만, `BestMergeRequestInfoResponse`와 같이 더 구체적으로 명명하여 가독성을 높일 수도 있습니다.
5. **타입 안전성**: `LocalDate[]` 대신 `List<LocalDate>`를 사용하여 더 나은 타입 안전성을 제공할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-12 13:17:51.304624', 13, '2024-11-12 13:17:51.304624', 9, '이 코드 변경 사항에 대해 리뷰를 진행하겠습니다. 전반적으로 SSE(서버 전송 이벤트) 기능을 위한 로직이 잘 구성되어 있으며, 코드의 구조도 깔끔하게 지켜진 점이 인상적입니다. 그러나 몇 가지 개선할 수 있는 부분과 주의할 점을 제안드립니다.

## 코드 리뷰

### 정확성
- `EmitterRepository`에서 `get(Long id)` 메서드가 null을 반환할 수 있는 경우에 대한 처리가 필요합니다. 현재는 null 체크를 통해 일부 처리를 하고 있지만, 클라이언트가 이 상황을 처리할 수 있도록 명확한 오류 처리가 필요할 수 있습니다. 예를 들어, Emitter가 존재하지 않을 경우 적절한 예외를 발생시키는 것이 좋습니다.

### 가독성
- `SSEController` 클래스의 `sendDataTest` 메서드는 현재 하드코딩된 `"data"` 문자열을 사용하고 있습니다. 이 매직 넘버는 변경될 가능성이 높으므로, 상수로 정의하여 사용하는 것이 좋습니다. 이로 인해 코드의 명확성과 유지보수성이 향상될 수 있습니다.

### 효율성
- `SSEService`의 `notify` 메서드에서 `System.out.println`을 사용하는 부분은 개발 및 디버깅 중 유용할 수 있으나, 실제 운영 환경에서는 로깅 프레임워크(예: SLF4J)를 사용하는 것이 더욱 적절합니다. 이를 통해 로그 레벨을 조정하고 로깅 정보를 보다 효율적으로 관리할 수 있습니다.

### 확장성
- `SSEService` 클래스에서는 메시지를 전송하는 로직이 단일 메서드로 처리되고 있습니다. 향후 다양한 이벤트 유형이 추가될 경우, notify 메서드의 파라미터가 복잡해질 가능성이 큽니다. 이를 방지하기 위해, 이벤트 타입에 따른 전용 메서드를 도입하여 처리하는 것이 바람직할 수 있습니다.

### 코딩 표준 준수
- Spring 프레임워크의 어노테이션 사용은 일관성 있게 잘되고 있습니다. 그러나 Javadoc 주석의 스타일이 일관되지 않습니다. 일부 메서드는 상세하게 주석을 달았으나, 다른 부분은 상대적으로 더 간단합니다. 모든 메서드에 대해 같은 포맷을 유지하도록 통일성을 기할 필요가 있습니다.

### 잠재적 버그
- Emitter의 타임아웃 처리 및 completion 처리 부분에서 Emitter가 삭제된 후에 다른 요청이 들어왔을 경우의 처리 로직도 검토해야 합니다. 이 때 발생할 수 있는 Race Condition을 주의해야 합니다. 여러 스레드가 동시에 Emitter를 접근하게 될 경우, 예기치 못한 상황이 발생할 수 있습니다.

## 결론
전체적으로 SSE 기능을 위한 잘 구성된 코드입니다. 위에서 언급한 개선 사항을 고려하여 수정하면, 더욱 견고하고 유지보수하기 쉬운 코드를 만들 수 있을 것입니다. 해당 MR에 대해 Approve합니다. 추가적인 피드백이 필요하면 언제든지 말씀해 주세요!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 14:27:51.32071', 14, '2024-11-12 14:27:51.32071', 10, '코드 리뷰를 진행하겠습니다. 전체적인 변경 내용과 구조는 잘 구성되어 있으며, 새로운 기능을 API로 잘 노출한 것 같습니다. 다음은 검토한 내용입니다.

### 코드 정확성
- `ProjectLabelResponse` 클래스에서 `of` 메서드를 사용하여 `List<GitlabLabelColorContent>`를 변환하는 방식은 적절합니다. 그러나 입력된 `labels`가 null일 경우를 처리하는 로직이 없습니다. 해당 경우에 대한 예외 처리를 추가하면 더 안전한 코드가 될 것입니다.
- `getProjectLabels` 메서드에서 `projectRepository.getById(projectId)` 호출 후, 반환값이 null일 경우를 고려하여 예외 처리 로직이 필요합니다.

### 가독성
- `LabelInfo` 클래스는 해당 클래스의 목적을 잘 드러줍니다. 그러나 만약 코드가 커질 경우, 클래스 자체를 별도의 파일로 빼는 것이 가독성을 높일 수 있습니다.
- `GitlabLabelColorContent` 데이터 클래스는 적절하게 네이밍되어 있으며, Jackson의 `@JsonNaming` 애노테이션을 통해 JSON 직렬화 전략을 적용한 것은 좋습니다.

### 효율성
- `labels.stream().map(...).toList()` 사용은 Java 16 이상의 버전에서만 지원되므로, 코드의 호환성을 고려한다면 `collect(Collectors.toList())`와 같은 방식이 더 널리 사용될 수 있습니다.
- 네트워크 호출이나 DB 조회가 포함된 `getProjectLabels` 메서드는 비동기적으로 처리할 수 있다면 비동기 방식으로 개선하는 것을 고려해 볼 수 있습니다. 이렇게 하면 페이지의 반응 속도를 향상시킬 수 있습니다.

### 확장성
- 서비스 레이어와 컨트롤러 레이어가 잘 분리되어 있어, 다른 API를 추가하는 데 유연성을 제공합니다. 다만, `ProjectService`의 메서드들이 계속 추가될 경우, 이 클래스가 점점 커질 수 있으므로 전략적으로 서비스 클래스를 분리하는 것을 고려하세요.

### 코딩 표준 준수 여부
- 패키지 구조와 클래스 네이밍은 Java의 코딩 표준을 잘 따르고 있습니다.
- 메서드, 변수, 클래스 네이밍 약속이 일관되게 지켜지고 있습니다.

### 잠재적인 버그
- 현재 `getProjectLabels` 메서드에서 프로젝트 ID로 프로젝트를 조회하고 있는데, 해당 프로젝트가 존재하지 않을 경우에 대한 예외 처리가 필요합니다.
- `GitlabAccount` 객체가 null일 경우에 대한 예외 처리가 코드에 없습니다. 이 또한 고려해주세요.

### 개선 제안
1. **예외 처리 추가**: null 체크 및 예외 처리 로직을 추가하세요.
2. **비동기 처리 고려**: 네트워크 호출이 포함된 메서드에 대해 비동기 처리를 고려하세요.
3. **패딩 관련**: 소스 코드 포맷을 조정하여 가독성을 높이는 것도 좋은 생각입니다.

이와 같이 피드백을 드립니다. 전체적으로 좋은 구현이며, 몇 가지 개선점만 체크하신다면 더 견고한 코드가 될 것입니다. MR 승인합니다!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 15:36:39.184575', 15, '2024-11-12 15:36:39.184575', 11, '코드 리뷰에 대한 피드백을 드리겠습니다.

## 코드 리뷰 피드백

### 1. 변경 사항 요약
- **기능 개선**: 기존에 merge request를 1개씩 조회하던 방식에서, 3개를 한 번에 조회할 수 있도록 변경하였습니다. 이는 네트워크 호출을 줄여 성능을 개선합니다.

### 2. 코드 정확성
- **정확성**: 전체적으로 코드의 정확성은 유지되고 있습니다. `createMergeRequestsQuery` 메서드는 여러 merge request를 깔끔하게 쿼리하도록 작성되었습니다.
- **예외 처리**: `executeWithExceptionHandling` 메서드가 사용되어 예외 처리에 신경을 쓴 부분이 인상적입니다. 이 덕분에 안정성이 증가합니다.

### 3. 가독성
- **가독성**: 함수명이 보다 명확하게 변경되었습니다. `buildMergeRequestQuery`에서 `createSingleMergeRequestQuery`로, `getTop3MrList`의 내부 로직이 간결해져 가독성도 높아졌습니다.
- **코드 라인 정렬**: 클래스 멤버와 메서드 사이에 일정한 여백을 두면 가독성이 조금 더 향상될 수 있습니다. 특히 메서드 로직 사이에 1~2줄의 여백은 가독성을 높이는 데 도움이 됩니다.

### 4. 효율성
- **효율성**: 동시 호출이 아닌 병렬적으로 여러 merge request를 조회하는 방식은 네트워크 대역폭과 응답 시간을 절약합니다. 이 부분은 좋은 변경 사항입니다.
- `createMergeRequestsQuery` 메서드의 query 생성 부분에서 여러 IDs를 리스트로 처리하는 방식이 적절합니다. 하지만 ID를 쿼리에 포함시키는 부분에서 조금 더 효율적인 방법(예: `String.join(...)`)이 있을 수 있습니다.

### 5. 확장성
- **확장성**: 새로운 기능을 추가할 때, `createMergeRequestsQuery`와 같은 쏠쏠한 유틸리티 메서드를 통해 재사용성과 유지보수성을 높일 수 있습니다. 이 점은 앞으로의 수정 작업에 긍정적인 영향을 미칠 것입니다.
- 한 가지 고려할 사항은, merge request의 수가 매우 많아질 경우에 대비하여 페이징 처리나 제한 수를 두는 방법을 고려하는 것이 좋겠습니다.

### 6. 코딩 표준 및 스타일
- 코드 스타일과 컨벤션이 일관되며, 메서드 이름 및 변수 이름이 의미를 잘 전달하고 있습니다.
- 예외를 잡는 방식이나 API 호출 후 얻은 데이터에 대한 Null 체크를 더욱 명시적으로 하는 것이 좋을 수 있습니다.

### 7. 잠재적인 버그
- `getTop3MrList` 메서드에서 `return mergeRequestContents.isEmpty()`, 이 부분에서 `null` 대신 빈 리스트(`Collections.emptyList()`)를 반환하면 외부에서는 `null` 체크를 신경 쓰지 않아도 되는 편리함을 제공할 수 있습니다.

### 결론
전반적으로 코드 변경 사항은 성능을 향상시키고 가독성을 높였으며, 향후 확장성에도 긍정적인 영향을 미칠 것으로 보입니다. 조금 더 구체적인 예외 처리를 추가하고, 목록 반환 시 `null` 대신 빈 리스트를 반환하는 방식으로 개선할 것을 권장합니다.

MR 승인을 위해 추가 개선 사항을 고려해 주시기 바랍니다. 잘 작성된 코드에 감사드립니다!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 16:06:27.640534', 16, '2024-11-12 16:06:27.640534', 12, '코드 리뷰 결과를 아래와 같이 정리했습니다. 리뷰는 코드의 정확성, 가독성, 효율성, 확장성 및 코딩 표준 준수 여부에 중점을 둡니다.

### 변경 사항 평가

1. **기능적 변경**:
   - `SseController`와 `SseService`에서 `User` 객체 대신 `mrInfoId`를 사용하는 요구에 맞게 변경했습니다. 이는 SSE 이벤트 구독 및 알림 처리를 보다 일반화하고 사용자 ID에 대한 의존성을 줄여서 기능적 유연성을 향상시킵니다.
   - `ReviewService`에서 리뷰 생성 후 SSE 알림을 추가하여 클라이언트가 리뷰 생성 완료를 더 빠르게 인지할 수 있도록 했습니다.

2. **가독성**:
   - `@Slf4j`를 사용하여 로그를 관리하도록 개선하여 `System.out.println` 및 `System.err.println` 사용을 없앴습니다. 이는 가독성과 유지보수성을 높이며, 로그 레벨에 따라 출력 제어가 용이하므로 배포 환경에서도 유용합니다.
   - 메서드 인자 이름을 명확하게 변경하여 이해도를 더욱 높였습니다(`userId` -> `mrInfoId`).

3. **잠재적 버그**:
   - `SseEmitter`를 저장하고 관리하는 로직이 명확하여, 동일한 ID로 요청할 경우 기존 Emitter가 덮어쓰이지 않도록 하는 예외 처리 확인이 필요할 수 있습니다. 이를 통해 예기치 않은 데이터 손실을 방지하는 것이 필요합니다.

4. **효율성**:
   - 기존의 `ObjectMapper` 인스턴스를 활용한 JSON 처리로 성능을 최적화했습니다. 이는 매 호출마다 인스턴스를 생성하는 것을 피할 수 있게 하여 성능 저하를 예방합니다.
   - `ConcurrentHashMap`을 사용하여 `Emitter`를 저장하기 때문에 동시성 접근이 안전하게 처리되고 있습니다.

5. **확장성**:
   - `SseService`에서 `Long mrInfoId`를 매개변수로 받아서 다양한 맥락에서 SSE를 처리할 수 있도록 변경한 것은 향후 기능 확장에서 매우 유용합니다.

### 개선 사항 및 권장사항

- **단위 테스트 추가**: 새로운 기능에 대해 단위 테스트를 작성하여 각 기능이 올바르게 동작하는지 검증할 필요가 있습니다. 특히, ECC(Events Conditional Change)가 발생할 때 예상된 결과가 나오는지를 확인하는 테스트가 중요합니다.
- **예외 처리 강화**: `SseEmitter` 관련 코드는 이벤트를 처리하는 중 예외가 발생할 수 있기 때문에, 이를 적절히 처리하는 로직을 추가하여 시스템의 안정성을 높이는 것이 좋습니다.
- **문서화**: 변경된 메서드의 사용법과 예상되는 동작을 문서화하여 팀원들이 변경 사항을 쉽게 이해하고 추가 기능 개발 시 참고할 수 있도록 하는 것이 추천됩니다.

### 결론
이전의 구현보다 기능적, 구조적으로 개선된 점이 상당히 많습니다. SSE와 관련된 변경은 확장성 및 유용성을 높이며, 코드 품질 또한 향상되었습니다. 위의 피드백을 참고하여 필요한 수정 및 보완을 진행하시길 바랍니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 16:16:39.109699', 17, '2024-11-12 16:16:39.109699', 13, '## 코드 리뷰

### 변경 사항 요약
이번 변경사항은 메인 화면과 MergeRequest UI에 대한 업데이트로, 전반적인 코드 스타일과 가독성을 개선하는 방향으로 진행되었습니다. 불필요한 console.log 문을 주석 처리하거나 제거함으로써 클린 코드를 지향하는 모습이 돋보입니다. 또한 props에 대한 타입 정의와 ChartBox 컴포넌트의 확장성을 고려하여 프로필 배지 렌더링 기능을 추가했습니다.

### 정확성
- `fetchProjectDetail` 함수에서 `projectData.languages.forEach` 부분이 주석 처리되었습니다. 이 부분이 관련된 로직에서 사용되지 않는다면, 아예 삭제할 수 있지만, 이후 사용될 예정이라면 주석을 유지하는 것이 좋습니다.
- `ProfileBadgeProps`에서 `profileIcons`와 `badgeIcons`의 타입이 `Record<number, string>`으로 설정된 것은 적절하며, 사용된 곳에서 문제 없이 작동할 것으로 보입니다.

### 가독성
- 코드의 가독성이 전체적으로 향상되었습니다. 특히, 새로운 ChartBox 컴포넌트에서의 width와 height를 string 타입으로 변경한 점이 좋습니다. 이로 인해 CSS에서 직접적인 스타일을 조정할 수 있습니다.
- JSX의 경우, 텍스트와 컴포넌트의 관계가 명확하게 드러나 있습니다. 이를 통해 컴포넌트를 빠르게 이해할 수 있습니다.
- 적절한 줄바꿈과 여백을 통해 코드가 잘 구성되어 있고, 또 컴포넌트 사이의 역할도 명확히 구분되어 있습니다.

### 효율성
- `ResizeObserver`를 사용한 차트 리사이즈 관리 추가는 성능을 보다 안정적으로 개선하는 요소로 작용할 수 있습니다. 응답성이 좋아지고, UI에서의 사용자 경험 향상에 기여할 것으로 보입니다.
- ChartBox 컴포넌트 안의 `renderProfileBadges`는 전반적으로 효율적으로 잘 작성되었습니다. JSX 내에서 상태를 직접적으로 처리하는 방식이 효율적입니다.

### 확장성
- `ProfileBadgeProps` 인터페이스에 추가 속성을 포함시키는 것이 프로필 배지 기능을 보다 유연하게 만들어 주는데 기여하고 있습니다. 향후 다양한 아이콘 또는 사용자 정의 배지를 쉽게 추가할 수 있는 구조입니다.
- ChartBox에서 `responsive` 옵션을 추가한 것은 다양한 화면 크기에 적응할 수 있도록 해줍니다.

### 코딩 표준 준수 여부
- 코딩 표준은 잘 지켜지고 있으며, 적절한 주석과 코드 설명이 포함되어 있습니다. 사용된 변수와 함수의 명칭 또한 일관성이 있습니다.

### 개선할 수 있는 부분
1. **주석 처리한 코드**: 불필요한 주석은 제거하는 것이 좋습니다. 명확성과 유지보수성을 높이기 위해 나중에 필요할 경우 Git 이력을 통해 확인할 수 있습니다.
2. **에러 처리를 강화**: API 호출시 발생할 수 있는 잠재적 오류를 보다 상세하게 처리하거나 사용자에게 보다 명확한 피드백을 제공해야 합니다.
3. **로깅**: 에러를 잡는 console.error 외에 일반적인 로깅이 필요한 경우에 대한 처리가 충분하지 않을 수 있으므로, 로깅 구조를 고려하는 것이 좋습니다.

### 결론
전반적으로 코드는 잘 작성되었으며 가독성과 효율성이 크게 향상되었습니다. 필요한 부분에 대한 개선 사항이 있지만, 전체적인 변경 사항은 긍정적이고 앞으로의 확장성에도 기여할 것입니다. 위의 피드백을 고려한 후, 필요에 따라 수정을 진행해주시기 바랍니다. 

**MR 승인 진행하셔도 좋습니다!**
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 17:06:31.416277', 18, '2024-11-12 17:06:31.416277', 14, '코드 리뷰에 대한 피드백을 제공하겠습니다. 다음 기준에 따라 상세히 분석하였습니다.

### 1. 기능적 정확성
- 변경된 코드에서 `isSuccess` 상태 변수를 추가하여 성공과 실패에 따른 알림 아이콘을 표시하는 로직이 추가되었습니다. 이로 인해 사용자에게 명확한 피드백이 전달됩니다. 
- `navigate(0)` 호출이 성공적으로 프롬프트가 저장된 후에 발생하여 유저의 페이지를 새로 고치게 됩니다. 이는 의도한 대로 작동할 가능성이 높습니다.

### 2. 가독성 및 유지보수성
- 새로운 `isSuccess` 변수의 도입으로 성공 여부에 따라 다른 아이콘과 클래스명을 설정하는 부분이 명확해졌습니다. 이는 가독성을 향상시킵니다.
- 전반적으로 함수형 컴포넌트에 대한 구조는 이해하기 쉬운 편이나, 더 많은 주석이 추가된다면 유지보수성에 도움이 될 것입니다.

### 3. 효율성
- `setContainerHeight`에 대해 기존의 불필요한 변수 선언이 제거되었습니다. 이는 코드의 효율성을 높이는 조치입니다.
- `navigate(0)`를 통해 페이지를 새로 고치도록 하는 대신, 상태 관리 및 UI 업데이트를 통한 리렌더링을 고려한다면 성능 향상에 기여할 수 있습니다.

### 4. 확장성 및 모듈성
- 현재 구조에서는 `isSuccess`와 같은 상태 변수를 추가하는 것이 미래의 확장성에 긍정적임을 보여줍니다. 추가적인 상태가 필요할 수 있기 때문에 상태 관리를 위한 더 나은 방법을 고려하는 것이 좋습니다.
- 알림 관련 로직을 별도의 컴포넌트로 분리한다면 모듈성이 향상될 것입니다. 같은 방식으로 다양한 알림을 처리할 수 있는 기반이 생기기 때문입니다.

### 5. 버그와 취약점
- `alertMessage`가 배열로 선언되어 있는 부분에서 단일 메시지 추가 뿐만 아니라 여러 메시지를 추가할 경우를 고려하고 있는 것처럼 보입니다. 하지만 이 경우 불필요한 배열 할당이 생길 수 있으므로, 단일 메시지를 사용하는 경우 상태를 문자열로 두고, 여러 메시지를 처리할 필요가 생기면 해당 로직을 수정하는 방식이 더 적합할 수 있습니다.
- 오류 처리에 대한 명확한 접근법이 이루어졌으나, 만약 다른 종류의 응답이 오게 되었을 때의 처리에 대한 로직이 추가되면 좋을 듯 합니다. 현재 `response`에서 성공 이외의 상태에 대해서는 단순하게 실패 메시지를 표시하는 구조입니다.

### 6. 테스트 가능성
- 상태 관리로 인해 테스트 가능성이 늘어났습니다. 하지만 `AlertModal`이 제대로 작동하는지와 같은 UI 요소를 테스트하기 위한 별도의 테스트 케이스를 작성하는 것이 중요합니다.
- `setIsAlertModalOpen`, `setAlertMessage` 등 상태 관련 함수에 대한 유닛 테스트가 필요하며, 가능한 다양한 시나리오를 테스트하는 것이 좋습니다.

### 결론
전반적으로 변경 사항이 기능적으로 정확하고 가독성이 증가하며, 효율적인 부분이 보입니다. 추가적으로 컴포넌트를 모듈화하고 상태 관리 방법을 개선할 수 있는 기회가 있으며, 일부 edge case를 고려한 더 나은 오류 처리 로직이 필요합니다. 또한, 테스트 가능성에 대한 고려도 함께 해주시면 좋겠습니다.

따라서 이 변경 사항은 **MERGE 승인**을 권장합니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:49:10.420123', 115, '2024-11-13 13:49:10.420123', 22, '## 코드 리뷰 결과

이번 변경 사항을 검토한 결과, 전반적으로 코드가 매우 잘 분석되고 세분화되어 있어 깔끔하게 작성되었습니다. 하지만 몇 가지 개선해야 할 점과 긍정적인 피드백을 나누고자 합니다. 각 항목에 대한 구체적인 피드백을 아래에 제시하겠습니다.

### 1. Readability (가독성)

- **잘 수행되고 있는 부분**: 메소드와 변수의 이름이 명확하고, 기능이 무엇인지 직관적으로 이해할 수 있습니다. 로그 메시지를 통해 일어나는 사건을 명확하게 파악할 수 있습니다.
- **개선이 필요한 부분**: `log.info`와 `log.error`에 대한 메시지는 더 자세한 정보를 포함할 수 있습니다. 예를 들어, 어떤 사용자가 연결했는지 또는 어떤 데이터가 사고 싶어졌는지를 추가하면 더 유용할 것입니다. 또한, Java 8 이상의 `String.format()`을 사용하여 문자열을 더욱 읽기 쉽게 만들어 줄 수 있습니다. 예를 들어:
  
  ```java
  log.info(String.format("SSE connection completed for id: %d", id));
  ```

### 2. Consistency (일관성)

- **잘 수행되고 있는 부분**: 전체적으로 코드 스타일이 일관되고, 메소드 정의가 통일된 규격을 따릅니다. 
- **개선이 필요한 부분**: 코드 전반적으로 주석이 부족할 수 있습니다. 특히 새로 추가된 `onError` 핸들러에서 어떤 상황이 오류로 간주되는지 주석을 추가하여 다른 개발자가 이해하는 데 도움을 줄 수 있습니다.

### 3. Reusability (재사용성)

- **잘 수행되고 있는 부분**: `createEmitter` 메소드가 단일 책임 원칙을 잘 따르고 있어 이벤트를 등록하고 로그를 기록하여 유사한 기능에서 재사용될 가능성이 높습니다.
- **개선이 필요한 부분**: 에러 처리 로직을 별도의 유틸리티 메소드로 분리하여 다른 곳에서 재사용할 수 있도록 개선할 수 있습니다. 필요한 경우 공통된 에러 처리 메소드를 만들어 성격에 맞게 사용할 수 있습니다.

### 4. Reliability (신뢰성)

- **잘 수행되고 있는 부분**: 예외 처리 부분이 잘 구현되어 있어, 오류 발생 시 로그가 기록되고, 저장소에서 해당 id가 삭제됩니다. 이는 의도한 대로 작동하는 신뢰성 높은 구조입니다.
- **개선이 필요한 부분**: `onError` 핸들러에서 발생할 수 있는 리트라이 메커니즘을 고려할 수 있습니다. 연결 실패 후 몇 번 시도해보고 실패할 경우 로그 기록 등의 처리를 진행하는 것도 좋은 예외 처리 방법입니다.

### 5. Security (보안성)

- **잘 수행되고 있는 부분**: 현재 코드는 직접적인 사용자 입력을 받지 않고 있으며, 로그 정보가 제한적으로 출력되고 있습니다. 이는 보안 측면에서 양호한 부분입니다.
- **개선이 필요한 부분**: 시간이 오래 걸리는 작업 시 사용자에게 적절한 피드백을 제공해 대기 중인 사용자가 무엇을 하고 있는지 알 수 있도록 하는 것은 보안과 사용자 경험을 모두 고려한 접근이 될 것입니다.

### 6. Maintainability (유지보수성)

- **잘 수행되고 있는 부분**: 코드는 모듈화되어 있으며, 싱글 책임 원칙이 잘 지켜지고 있어 유지보수하기 수월합니다.
- **개선이 필요한 부분**: 추가적인 메소드를 만들어 주요 비즈니스 로직을 분리하고, 프레젠테이션 또는 데이터 프로세싱 로직을 분리하면서 유연성을 높일 수 있습니다. 예를 들어, 이벤트를 전송하는 로직을 다른 클래스로 이동시키면, 코드가 더욱 명확해지고 테스트하기 쉬워질 것입니다.

## 전체적인 피드백

전반적으로 코드는 효율적이고, 잘 구성되어 있으며, 로그 개선으로 사용자 경험이 더욱 향상될 수 있는 기회가 있습니다. 특히 예외 처리에 대한 견고함과 로그의 이용 가능성은 주목할 만한 사항입니다. 개선할 수 있는 몇 가지 제안도 포함되어 있음을 기억해 주시기 바랍니다. 개선 가능한 부분들을 고려하여 다음 단계로 나아갈 수 있습니다. 전반적으로 잘 작성해 주신 점에 대해서는 칭찬 드리며, 팀과 함께 더 나은 코드를 만들어가는 여정이 되시길 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:10:18.529291', 19, '2024-11-12 17:10:18.529291', 14, '## 코드 리뷰 피드백

### 1. 기능적 정확성
- **변경사항**: 안 쓰는 변수를 제거하고, 성공 및 실패 시 알림 아이콘을 표시하는 로직을 추가했습니다.
- **평가**: 변경된 코드가 기능적 요구사항을 충족하며, 성공 및 실패 상태를 명확히 구분할 수 있도록 개선되었습니다. `isSuccess` 상태를 기반으로 한 아이콘 표시가 사용자의 이해를 도울 것으로 보입니다.

### 2. 가독성 및 유지보수성
- **변경사항**: 성공 및 실패 메시지를 조건부로 처리하고 이와 관련된 상태 변수를 추가했습니다.
- **평가**: 상태 변수가 추가되어 코드의 의도가 더 명확해졌습니다. 특히, 알림상자의 내용을 결정하는 조건부 렌더링은 가독성을 높입니다. 그러나 변수명은 `isSuccess` 외에도 다른 상태에 대한 추가 설명을 포함하면 더 좋을 듯합니다. 예를 들어 `showSuccessAlert`와 같은 형태로 변경할 수 있습니다.

### 3. 효율성
- **변경사항**: 기초적으로 성능에 큰 영향을 미치는 변경은 없습니다. 
- **평가**: 업데이트된 부분에서 특별한 성능 문제는 발견되지 않았습니다. 다만, `navigate(0)` 호출이 페이지를 새로 고칠 때 발생할 수 있는 불필요한 렌더링을 발생시킬 수 있으므로, 이를 피하는 대안(예: 상태 업데이트 후 화면 전환)의 구현을 고려해볼 수 있습니다.

### 4. 확장성 및 모듈성
- **변경사항**: 알림 아이콘을 조건에 따라 동적으로 설정했습니다.
- **평가**: 향후 알림 방식이 추가로 변화할 가능성을 고려할 때, `AlertModal` 컴포넌트를 재사용할 수 있도록 `icon`과 같은 속성을 정의한 것도 좋은 접근입니다. 하지만 아이콘 로직이 더 복잡해질 경우, 해당 로직을 별도의 함수로 분리하여 가독성을 높이는 방법도 고려해야 합니다.

### 5. 버그와 취약점
- **변경사항**: 버그를 직접적으로 유발할 요소는 없지만, 항상 예외 처리에 대한 논의는 필요합니다.
- **평가**: `response.status`가 ''SUCCESS''가 아닐 경우에 대한 처리 로직은 잘 작성되었습니다. 제안하고 싶은 것은, 네트워크 요청에서의 예외처리를 추가하는 것입니다. 예를 들어, 요청 실패 시에 대한 적절한 피드백 로직이 필요할 수 있습니다.

### 6. 테스트 가능성
- **변경사항**: 새로운 상태 변수 `isSuccess`의 도입은 테스트 관점에서 유용합니다.
- **평가**: 해당 코드가 새로운 상태를 잘 반영하고 있으며, `AlertModal` 부품의 다양한 상태에 대한 테스트 케이스가 필요합니다. 특히 상태가 변경될 때 적절하게 UI가 작동하는지 검증하는 테스트가 중요합니다. 이를 위해 enzyme, react-testing-library 등을 사용할 수 있습니다.

## 종합적인 평가
전반적으로 코드 변경은 기존 코드의 구조를 개선하였고, 기능적 요구사항을 충족하고 있습니다. 향후 `isSuccess`와 같은 상태 변수를 추가하여 코드 가독성 및 유지보수성을 높이는 것이 좋은 방향이라고 평가합니다. 추가로 예외 처리와 관련된 로직을 강화하는 것을 추천합니다. 

최종적으로 승인합니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:14:30.826006', 20, '2024-11-12 17:14:30.826006', 14, '## 코드 리뷰

1. **기능적 정확성**:
   - 변경된 코드의 가장 주목할 만한 부분은 `isSuccess` 상태 변수를 추가하여 `AlertModal`의 아이콘과 클래스를 동적으로 변경하는 것입니다. 이로 인해 사용자에게 성공 및 실패 메시지를 명확하게 전달할 수 있게 되었습니다. 이러한 변경은 코드의 의도가 명확하고, 기능적 요구사항을 충족하는 것으로 보입니다.

2. **가독성 및 유지보수성**:
   - `setIsSuccess(true)`와 `setIsSuccess(false)`를 사용하여 성공 및 실패 상태를 명확하게 처리하는 구조가 잘 작성되었습니다. 변수 이름이 명확하고, 상태 관리가 용이해 보입니다. `alertMessage`와 `isSuccess`는 관련성이 높으므로 함께 유지하는 것이 좋습니다. 추가적인 설명이 필요한 부분이 있다면, 각 상태가 무엇을 의미하는지 간단한 주석을 추가하는 것이 좋습니다.

3. **효율성**:
   - `navigate(0)`을 호출하여 페이지를 새로 고침하는 방식은 간편하지만, 필요할 경우 컴포넌트 내의 상태를 명시적으로 변경하여 페이지를 새로 고치는 대신 사용할 수도 있습니다. 이를 통해 렌더링 성능을 최적화할 수 있습니다.

4. **확장성 및 모듈성**:
   - 새로운 프로퍼티인 `icon`과 `iconClassName`이 `AlertModal`에 추가된 것은 좋은 아이디어입니다. 이러한 변경은 다른 알림 유형에 대해서도 손쉽게 확장할 수 있도록 해줍니다. 다만, `AlertModal`이 앞으로 더 많은 아이콘 종류를 처리해야 한다면, 이 로직을 따로 분리하여 가독성과 유지보수성을 높이는 것도 고려해 볼 수 있습니다.

5. **버그와 취약점**:
   - 현재 변경된 코드에서는 직접적으로 버그가 발생할 가능성이 높아 보이지 않습니다. 그러나 비동기 호출 이후의 상태 변경이 의도한 바와 다르게 이루어질 수 있으니, `response.status`와 관련된 더욱 세밀한 예외 처리 로직을 추가하는 것도 좋습니다. 예를 들어, 서버의 응답이 `SUCCESS`가 아닐 경우 추가적인 로그를 남기는 것과 같은 방법입니다.

6. **테스트 가능성**:
   - 상태 변화와 관련한 부분이 잘 모델링되어 있어 각 상태별로 유닛 테스트를 작성하기 수월합니다. `isAlertModalOpen`, `alertMessage`, `isSuccess`에 대한 테스트 케이스를 작성하여 이 상태들이 올바르게 변하는지를 확인하는 것이 좋습니다. `AlertModal`이 제대로 작동하는지 검증하기 위해 다양한 상태에 대한 테스트도 필요할 것으로 보입니다.

## 개선 제안
- `navigate(0)` 대신 상태 업데이트를 통해 사용자 인터페이스를 갱신하는 방법을 고려해 보세요.
- 추가적인 예외 처리를 위해 `response` 객체에 대한 검증 로직을 강화하세요.
- 코드에 주석을 추가하여 각 상태가 어떤 역할을 하는지 문서화하면 가독성이 더욱 향상됩니다.

이와 같은 변화들이 이루어지면 코드의 전반적인 품질과 유지보수성, 그리고 확장성이 한층 높아질 것입니다. 전반적으로, 잘 작성된 변경 사항으로, 시스템의 기능 향상에 기여할 것으로 보입니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:15:31.139373', 21, '2024-11-12 17:15:31.139373', 14, '코드 변경 사항에 대한 리뷰를 다음과 같이 진행하겠습니다. 주요 변경 사항은 사용하지 않는 변수를 제거한 점과 알림 모달의 시각적 피드백을 개선한 것입니다.

### 1. 기능적 정확성
변경된 코드가 요구하는 기능을 충족하는지 잘 검토해보았습니다. `setIsSuccess`를 통해 모달의 아이콘 상태를 관리하는 부분이 추가되어, 성공 및 실패 메시지에 따라 적절한 아이콘이 표시되도록 했습니다. 이는 사용자 경험을 향상시키는 긍정적인 변화입니다. 각 조건에서 모달이 제대로 열리고, 적절한 메시지가 설정되는지 테스트를 통해 확인할 필요가 있습니다.

### 2. 가독성 및 유지보수성
코드 전반적으로 가독성은 양호하지만, 알림 메시지와 관련된 로직이 약간 복잡해 보입니다. 아래와 같은 개선을 고려할 수 있습니다:
- 동일한 메시지 설정을 반복하고 있으므로, 해당 부분을 함수로 분리하여 코드 중복을 줄이고 가독성을 높일 수 있습니다. 예를 들어, 모달 열기 함수 `showAlertModal(message: string, success: boolean)`를 만들어 호출하도록 할 수 있습니다.

### 3. 효율성
사용하지 않는 변수 (`containerHeight`)를 제거함으로써 코드의 효율성이 개선되었습니다. 그러나 새로운 상태 변수를 추가하면서 렌더링 성능에 미치는 영향을 점검해볼 필요도 있습니다. 상태가 변경될 때마다 컴포넌트가 다시 렌더링되는 부분에 대해 주의하세요.

### 4. 확장성 및 모듈성
현재 구조는 충분히 모듈화되어 있으며, 추가적인 기능이 필요할 때 쉽게 확장할 수 있을 것으로 보입니다. 그러나 추후 추가적인 알림 종류가 필요해질 경우, 모달 컴포넌트에 `type` 속성을 추가해 다양한 아이콘과 메시지를 처리하게 할 수 있습니다.

### 5. 버그와 취약점
현재 코드에서 큰 버그는 발견되지 않았습니다. 단, `navigate(0)`을 사용할 경우 전체 페이지가 새로고침되는 상황이 발생할 수 있습니다. UI/UX 관점에서 사용자의 경로를 기억할 필요가 있다면, `navigate(-1)` 또는 특정 라우트로의 네비게이션을 고려하는 것이 좋습니다.

### 6. 테스트 가능성
알림 모달의 성공 및 실패 케이스에 대해 테스트 케이스를 작성하는 것이 중요합니다. 특히 상태 변화가 UI에 미치는 영향을 살펴보는 단위 테스트가 필요합니다. `setIsSuccess`에 따라 아이콘이 변경되는 부분과, 모달이 열리고 닫히는 로직을 테스트하는 것이 좋습니다.

### 추가 제안
- 알림 메시지를 다국어 지원을 위한 구조로 리팩토링할 수 있습니다. 이는 확장성과 유지보수성을 높이는 데 도움이 됩니다.
- 상태 관리 로직을 더욱 간소화하기 위해 React Context 또는 Redux와 같은 상태 관리 라이브러리 도입을 고민해 볼 수 있습니다. 

콜러의 재사용성을 고려하여 컴포넌트를 적절히 분리하거나 합치는 방법도 고민해 보시면 좋겠습니다. 이와 같은 사항들을 검토하여 유지보수성을 한층 더 높일 수 있습니다. 

끝으로, 코드 변경 사항이 잘 반영되었다고 생각하므로 MR을 승인하겠습니다. 추가적인 테스트와 개선 사항에 대한 논의로 더 나은 품질을 가진 코드를 만들어갈 수 있길 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:17:10.003368', 22, '2024-11-12 17:17:10.003368', 14, '### 코드 리뷰

#### 1. 기능적 정확성
- 변경된 코드는 사용자의 성공 및 실패 알림에 대한 시각적 피드백을 제공하는 기능을 추가하였습니다. `isSuccess` 상태 변수를 도입하여 성공 여부에 따라 다른 아이콘을 표시하도록 했습니다. 이로 인해 사용자가 작업의 결과를 더욱 쉽게 이해할 수 있게 되었습니다. 전반적으로 요구 사항을 잘 충족하고 있습니다.

#### 2. 가독성 및 유지보수성
- 변경된 코드의 구조와 의도가 명확하여 가독성이 좋습니다. `isSuccess`와 같은 명확한 변수명을 사용했으며, `AlertModal`의 props에 아이콘과 클래스 이름을 조건부로 할당하는 방식을 통해 유지보수성이 향상되었습니다.
- 하지만 `isSuccess`와 같은 변수의 추가가 필요로 하는 경우, 주석으로 설명을 덧붙여 주는 것이 향후 유지보수에 도움이 될 것입니다.

#### 3. 효율성
- `setContainerHeight`에서 불필요한 상태를 제거하고 정의는 하였지만 사용하지 않음으로 코드의 간결함을 다졌습니다. 이러한 변경은 효율성을 높이는데 기여합니다.
- 그러나, 현재 `navigate(0)`를 통해 페이지를 새로고침하는 방식은 비효율적일 수 있습니다. 필요하다면 해당 페이지의 상태를 적절히 업데이트하는 방법을 검토해 보세요.

#### 4. 확장성 및 모듈성
- `isSuccess` 상태 변수를 사용하여 성공과 실패의 피드백을 처리하는 방식은 앞으로 확장할 때 유용한 패턴입니다. 추가적인 피드백 세부 사항 (예: 오류 메시지 다양화 등)도 쉽게 추가할 수 있는 구조입니다.
- 그러나, 추후 다른 종류의 알림을 추가할 필요가 생길 경우를 대비하여 알림을 처리하는 컴포넌트를 별도로 만들어 모듈화하는 것을 고려해보는 것이 좋습니다. 

#### 5. 버그와 취약점
- 현재 코드에서 잠재적인 버그는 발견되지 않았습니다. 하지만 `AlertModal`의 `onConfirm` 이벤트에서 `setIsAlertModalOpen(false)`를 호출하기 전에 발생할 수 있는 예외사항을 염두에 두고 상태를 잘 처리하는 것이 좋습니다.
- `navigate(0)`를 이용한 페이지 리프레시 방식은 API 호출 시 성능 상 이슈를 유발할 수 있으니, 다른 방법으로 페이지의 상태를 조작하는 방법을 고려해보는 것이 좋습니다.

#### 6. 테스트 가능성
- `isSuccess` 상태에 따라 아이콘이 바뀌는 로직은 유닛 테스트를 통해 쉽게 검증할 수 있는 구조입니다. `AlertModal`의 통합 테스트도 함께 검증하는 것이 좋습니다. 
- 향후 다양한 경우의 수에 대해 테스트 케이스를 작성할 수 있도록 코드가 잘 구조화 되어 있어, 테스트 가능성에 긍정적인 영향을 미칩니다.

### 개선 제안
1. **주석 추가**: 변수와 상태의 목적을 간단히 설명하는 주석을 추가하여 타 개발자들이 코드 이해에 도움을 줄 수 있도록 합니다.
2. **알림 모듈화**: 다양한 알림 유형을 처리할 수 있는 새로운 컴포넌트를 만들어 모듈화하여 유지보수성을 더 추가하고, 각 알림이 특정한 형식으로 반환되도록 구현하는 방향도 고려해보세요.
3. **상태 업데이트 최적화**: `navigate(0)` 대신 상태 관리를 통해 페이지의 변화가 반영되도록 리팩토링할 필요성을 검토해 보세요.

### 결론
전체적으로 코드 변경 사항은 명확하고 기능적으로도 적절하게 구성되어 있습니다. 가독성과 유지보수성 측면에서도 잘 짜여 있으며, 향후 확장성에 대한 고려도 긍정적으로 평가됩니다. 위 제안을 참고하시어 코드 품질을 한층 더 향상시킬 수 있기를 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:19:05.037454', 23, '2024-11-12 17:19:05.037454', 14, '안녕하세요. 코드 변경 사항을 검토한 결과는 다음과 같습니다.

### 1. 기능적 정확성
변경된 코드는 기능적으로 정확하게 보이며, 기존의 로직을 활용하여 성공 및 실패에 대한 알림 메시지를 표시하도록 개선되었습니다. `isSuccess` 상태를 추가하여 알림의 아이콘을 다르게 표현한 것은 사용자에게 더 나은 피드백을 제공합니다. 

### 2. 가독성 및 유지보수성
코드의 가독성이 좋은 편이며, 변수명 및 함수명이 명확하여 의도를 쉽게 이해할 수 있습니다. 하지만 가독성을 더욱 높이기 위해 `setIsAlertModalOpen`, `setAlertMessage`, `setIsSuccess`와 같은 상태 업데이트 부분을 별도의 함수로 추출하는 것도 고려해볼 수 있습니다. 예를 들어, 알림을 설정하는 함수를 만들면 중복된 상태 업데이트 로직을 줄이고, 변화가 필요할 경우 이 함수만 수정하면 된다. 

### 3. 효율성
변경된 코드에서 효율성 측면에서 특별한 문제가 있는 것 같지는 않습니다. `useState` 후크를 사용하는 것은 React의 상태 관리 원칙에 부합하며, 성능상에도 큰 영향을 미치지 않을 것입니다.

### 4. 확장성 및 모듈성
현재는 `CircleCheck`와 `TriangleAlert` 아이콘을 사용하는 것으로 보이지만, 추후 더 많은 유형의 알림 아이콘이 필요해질 경우 `icon`과 `iconClassName`을 더 일반화하여 다양한 아이콘을 수용할 수 있는 방식으로 리팩토링 하는 것도 좋습니다. 예를 들어, 아이콘을 객체로 매핑하여 보다 쉽게 관리할 수 있습니다.

### 5. 버그와 취약점
코드에서 특별한 버그나 취약점은 발견되지 않았습니다. 유일한 주의사항으로는 `navigate(0)`를 호출하여 페이지를 강제로 새로 고치는 부분입니다. 이 방식 대신 상태 변화에 따라 컴포넌트를 다시 렌더링하는 방법도 고려하는 것이 좋습니다. 이는 사용자 경험을 개선할 수 있습니다.

### 6. 테스트 가능성
테스트 가능성 측면에서 `CustomPromptContainer` 컴포넌트는 잘 구조화되어 있어서 단위 테스트를 작성하기 용이해 보입니다. 그러나 상태 업데이트를 따로 관리하는 함수로 분리한다면, 각 함수에 대한 단위 테스트를 더 잘 작성할 수 있을 것입니다. 특히 알림을 설정하는 로직을 검증할 수 있는 테스트를 추가하는 것이 유용할 것입니다.

### 결론
전반적으로 코드 변경은 올바른 방향으로 진행되었으며, 기능적으로도 문제가 없어 보입니다. 가독성과 유지보수성을 위한 개선 방안을 제안했으며, 테스트 용이성을 높일 수 있는 구조 변경도 고려해 볼 수 있습니다. 해당 변경 사항은 승인할 수 있을 것 같습니다.

### 최종 의견
코드는 상당히 충실히 잘 작성되었으며, 추가적인 리팩토링 가능성도 존재하는 만큼, 다음 단계로의 발전을 위해 제안한 방법을 검토해보시면 좋을 것 같습니다. 

MR을 승인하겠습니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:21:54.469449', 24, '2024-11-12 17:21:54.469449', 15, '코드 변경 사항에 대한 리뷰를 진행하겠습니다. 아래는 각 항목에 따른 평가와 피드백입니다.

### 1. 기능적 정확성
변경된 메서드 이름과 내용이 기존의 CRUD 기능을 적절히 수행할 것으로 보입니다. 예를 들어, `createSingleProjectQuery`를 `oneProjQueryCreateNow`로 변경하고, 쿼리 문자열을 간소화하여 가독성을 높였습니다. 그러나 쿼리의 정확성을 보장하려면, 해당 쿼리를 호출하는 컨텍스트에서 예상되는 응답 구조와 일치하는지 확인할 필요가 있습니다.

### 2. 가독성 및 유지보수성
메서드 이름이 보다 설명적으로 변경된 점은 긍정적입니다. 예를 들어, `makeGraphqlUrl`에서 `urlMakeWithGraphProtocol`로의 변경은 해당 메서드의 목적을 명확히 드러내고 있습니다. 그러나 메서드 이름이 지나치게 길어질 수 있으며, 이는 가독성을 떨어뜨릴 수 있습니다. 적당한 길이로 줄이는 것이 좋습니다. 예를 들어 `urlMakeWithGraphProtocol` 대신 `buildGraphqlUrl` 같은 이름이 더 적합할 수 있습니다.

### 3. 효율성
코드의 성능에 큰 영향을 미치는 요소는 보이지 않습니다. 그러나 메서드 내에서 반복되는 문자열 조작 (예: 쿼리 문자열 생성)을 효율적으로 관리하기 위해 상수를 사용하거나, Apache Commons Lang의 `StringUtils` 같은 유틸리티 클래스를 활용할 수 있습니다.

### 4. 확장성 및 모듈성
변경 사항은 함수형 스타일을 채택하고 있어 모듈성을 개선하는 데 기여하고 있습니다. 하지만, GraphQL 쿼리가 매우 길어서 유지보수 시 버그가 발생할 가능성을 높입니다. 쿼리 생성을 위한 별도의 빌더 클래스를 도입해 각 쿼리를 조합하는 방식으로 확장성을 높일 수 있을 것입니다.

### 5. 버그와 취약점
`reduce` 메서드에서 `Optional`을 반환하지 않고 `map` 메서드를 즉각 사용할 경우 NPE가 발생할 수 있습니다. 따라서 `Optional` 체인이 안전하게 사용되는지 확인하고, `orElse`를 적절히 사용하여 디폴트 값을 제공하는 것이 좋습니다.

### 6. 테스트 가능성
현재 작성된 메서드들이 테스트하기 쉬운 구조로 작성되어 있습니다. 그러나, 향후 확장이 가능합니다. 각 메서드에 대한 단위 테스트를 작성하여 예상되는 쿼리 결과를 검증하고, GraphQL 쿼리의 정확성을 자동화할 수 있도록 노력해야 합니다. Mocking을 활용하여 외부 의존성을 제거하는 것도 효과적입니다.

### 종합적인 피드백
- 메서드 이름은 좋으나 약간의 일관성을 유지할 필요가 있으며, 너무 길지 않도록 조절해야 합니다.
- 쿼리를 빌드하는 로직을 별도의 빌더 클래스로 분리하여 코드의 가독성을 더 높이고, 유지보수성을 개선할 필요가 있습니다.
- 성능 최적화는 필요할 때 수행하되, 현재로서는 큰 문제가 보이지 않습니다.
- 추가적인 테스트 케이스 작성으로 코드의 신뢰성을 확보해야 합니다.

### 결론
코드 변경 사항은 전반적으로 긍정적이며 코드의 유지보수성과 가독성을 개선하고 있습니다. 제안된 피드백을 반영하면 더 나은 품질의 코드를 유지할 수 있을 것입니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:49:38.58677', 116, '2024-11-13 13:49:38.58677', 22, '## 코드 리뷰 피드백

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 코드에서 사용된 `log.info`와 `log.error`는 로그 메시지를 통해 코드의 흐름을 이해하는 데 도움을 줍니다. 로그 메시지도 이해하기 쉽고, 클리어하게 작성되었습니다. `SSE connection completed for id: ...`와 같은 로그는 SSE 연결의 상태를 명확히 나타냅니다.
  
- **개선이 필요한 부분**: `emitter.onCompletion`, `emitter.onTimeout`, `emitter.onError` 블록 내의 로직이 반복되는 패턴을 보이는데, 이 부분을 소규모 함수로 추출하면 가독성이 향상될 수 있습니다. 예를 들어:
  
  ```java
  private void handleEmitterCompletion(Long id) {
      log.info("SSE connection completed for id: " + id);
      emitterRepository.deleteById(id);
  }
  ```

  이렇게 별도의 함수로 추출하여 코드의 가독성을 높일 수 있습니다.

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 로그의 작성 방식이 일관되게 사용되어 있습니다. 모든 로그가 같은 형식을 따르기 때문에, 코드를 읽는 사람은 기록된 로그의 패턴을 빠르게 인지할 수 있습니다.
  
- **개선이 필요한 부분**: 변수명인 `id`는 명확하지만, 조금 더 구체적인 이름 사용을 고려해볼 수 있습니다. 예를 들어, `sseId`와 같은 이름을 사용하면 더 명확성이 언급될 수 있습니다.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: 각 SSE 메서드는 SRP(단일 책임 원칙)에 따라 잘 정의되어 있어 재사용성과 유지보수성에 좋은 영향을 줄 수 있습니다.
  
- **개선이 필요한 부분**: `emitters.remove(id)` 같은 부분은 여러군데에서 쓰일 수 있어, 이를 별도의 메서드로 만들어 재사용할 수 있도록 하는 것이 좋습니다. 이렇게 함으로써 수정이 필요할 경우 중앙집중적으로 관리할 수 있습니다.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 오류 및 예외 처리 부분이 잘 구현되어 있습니다. 각각의 예외 상황에 대해 적절한 처리가 이루어지고 있으며, 이는 코드의 신뢰성을 높일 수 있습니다.
  
- **개선이 필요한 부분**: `emitter.complete()` 호출 후 `emitterRepository.deleteById(id)`를 호출하고 있으니 어떤 경우에 이 함수가 호출되는지를 명확히 보장할 필요가 있습니다. `emitter.complete()` 호출 후 처리 과정에서 발생할 수 있는 Race Condition 문제를 대비하는 예외 처리 로직이 필요할 수 있습니다.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 현재 코드에서는 직접적인 민감한 데이터 처리가 보이진 않지만, 로그 메시지에 `id`가 포함되는 부분은 주의가 필요합니다. 그런 정보를 로그하는 것 자체는 좋지 않으므로, 정보 유출이 발생하지 않도록 로그에 나타나는 정보를 최소화하는 것이 좋습니다.
  
- **개선이 필요한 부분**: 만약 후속 기능에 민감한 정보가 포함되거나 추가될 경우, 해당 정보에 대한 검증 및 필터링 로직을 구현하여 보안성을 한 층 강화하는 것이 필요합니다.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 모듈화가 잘 되어 있으며, 각 기능이 독립적으로 작동할 수 있도록 작성되었습니다. 이는 장기적으로 코드의 유지보수성을 높이는 데 기여합니다.
  
- **개선이 필요한 부분**: 중복된 코드가 발생하는데, 특히 로그를 남기는 부분 (예를 들어, 로그 메시지를 동일하게 사용하고 있습니다)에서 중복성을 줄여주는 방식으로 수정할 수 있습니다. 복붙을 줄여 코드의 변경 용이성을 높일 수 있습니다.

### 전체적인 피드백
코드 전반적으로 잘 작성되어 있으며, 특히 로그 처리와 예외 처리 부분에서 긍정적인 요소가 많이 보입니다. 각 기능이 명확히 역할을 나누고 있어 구조적으로는 안정적입니다. 그러나 몇 가지 중복된 패턴과 반복적 코드가 보이고, 개선 가능한 부분도 여전히 존재합니다. 

버그의 가능성을 줄이기 위해 초점을 맞추는 것이 좋으며, 가독성을 더욱 높이기 위해 특정 로직을 함수로 분리하는 것도 고려해 보세요. 이러한 개선을 통해 코드의 품질을 한 단계 더 높일 수 있을 것입니다. 당신의 노력과 헌신에 감사하며, 앞으로도 잘 이어나가기를 응원합니다!');
INSERT INTO public.review VALUES ('2024-11-13 13:52:22.048168', 117, '2024-11-13 13:52:22.048168', 22, '## 코드 리뷰

코드 변경 사항에 대한 피드백을 아래의 평가 항목을 중심으로 제공합니다. 전반적으로 개선된 점이 다수 존재하며, 몇 가지 사항에 대해서는 추가적인 고려가 필요합니다.

### 1. Readability (가독성)
**잘 수행된 부분:**
- `log.info(...)` 및 `log.error(...)`를 통해 이벤트를 기록하는 방식은 유용하며, 어떤 일이 발생했는지 쉽게 추적할 수 있도록 합니다.
- 코드 블록이 잘 구성되어 있어 각 이벤트 핸들링이 명시적으로 드러납니다.

**개선할 점:**
- 각 이벤트 처리 블록에 주석을 추가하는 것이 좋습니다. 예를 들어, `// SSE 연결 완료 시 처리`와 같은 주석을 추가하여 이 블록이 어떤 역할을 하는지 명확히 하면 코드의 가독성이 더욱 높아질 것입니다. 
- LOGGER 대신 단순한 `println` 문을 사용할 경우 로그의 수준에 따른 가시성이 낮아질 수 있습니다. 이를 `LOG.debug()`을 활용하여 로그 레벨을 조정할 수 있는 방법을 고려하세요.

### 2. Consistency (일관성)
**잘 수행된 부분:**
- 메서드와 변수 이름이 기능적으로 적합하며, 일관된 스타일로 작성되어 있습니다.

**개선할 점:**
- `emitter`와 `emitterRepository`의 명명 규칙은 일관성을 유지하고 있지만, 모든 매개변수 및 변수가 로깅 시 사용하는 포맷에 대해 일관성을 유지하려면 더 나은 정적 타이핑을 통한 강제 규칙 적용을 고려할 수 있습니다.

### 3. Reusability (재사용성)
**잘 수행된 부분:**
- SSEEmitter의 생성과 이를 처리하는 로직이 잘 모듈화되어 있어 다른 서비스에서도 사용할 수 있는 재사용 가능성이 큽니다.

**개선할 점:**
- 다양한 에러 처리를 위해 각 경우를 핸들링하는 메서드를 별도로 정의하여 재사용할 수 있도록 리팩토링할 수 있습니다. 예를 들어, 오류 메시지 수집 및 로깅을 동시에 하는 별도의 유틸리티 클래스를 만드는 것 추천합니다.

### 4. Reliability (신뢰성)
**잘 수행된 부분:**
- 예외를 적절히 처리하고, `emitterRepository.deleteById(id);`를 통해 리소스 정리를 잘 수행하고 있습니다.

**개선할 점:**
- 모든 예외를 로깅하는 것은 좋지만, 예외 처리 시 적절한 피드백을 사용자에게 제공하는 것도 중요합니다. 사용자에게 명확한 피드백을 줄 수 있는 방법(예, 사용자에게 에러 메시지를 전송 등)을 고려하세요.

### 5. Security (보안성)
**잘 수행된 부분:**
- 예외 처리 메커니즘이 잘 적용되어 있어 보안성을 어느 정도 확보하고 있습니다.

**개선할 점:**
- 사용자의 ID와 같은 민감한 데이터에 대한 로깅을 피해야 합니다. 특히 오류 로그에서 이러한 정보를 노출하지 않도록 주의하세요. 데이터 노출 방지를 위한 추가적인 방어 코드를 고려해야 합니다.

### 6. Maintainability (유지보수성)
**잘 수행된 부분:**
- 명확한 리포지토리 사용으로 인해 유지보수성이 높아 보입니다.

**개선할 점:**
- 메서드의 길이가 증가함에 따라 메서드가 스파게티 코드처럼 복잡해질 수 있습니다. 1-2 행 정도의 작은 메서드로 나누어 변화가 발생하는 부분의 수정 및 유지보수를 원활히 할 수 있도록 해야 합니다.

## 전체적인 피드백
- 변경된 코드에서는 SSE 연결의 완료, 타임아웃, 오류 발생 시 로그 출력을 추가함으로써 코드의 트레이서블성을 향상시킨 점이 매우 긍정적입니다. 이는 나중에 문제를 해결할 때 유용하게 작용할 것입니다.
- 코드의 가독성이 좋고, 의도하는 로직이 명확하게 드러나 있어 유지보수하기 쉬운 구조입니다. 하지만 추가적인 주석과 더 깨끗한 예외 처리로 더욱 명확하고 안전한 코드를 만들 수 있습니다.
- 보안과 관련해서는 민감정보 수집을 회피할 수 있는 유연성을 부여하는 것이 필요합니다. 각 함수와 로직에 대한 세부 구현에 신경 쓰면서 점진적으로 코드를 개선해 나가세요.

이러한 제안들을 통해 더욱 나은 품질의 코드를 작성할 수 있을 것이라 확신합니다. 감사합니다!');
INSERT INTO public.review VALUES ('2024-11-12 17:22:18.310446', 25, '2024-11-12 17:22:18.310446', 14, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드가 의도한 대로 동작할 가능성이 높습니다. 성공적인 메시지 저장과 실패 시 각각의 알림 메시지를 표시하는 로직이 잘 구현되어 있습니다. `isSuccess` 상태 변수를 통해 성공 여부를 관리하여 모달 표시 시 아이콘을 다르게 설정하는 부분도 잘 되어 있습니다. 그러나, 진행 완료 후 페이지를 새로 고치는 `navigate(0);` 코드가 유지보수 측면에서 문제를 일으킬 수 있으므로, 이 부분에 대한 대체 방안을 고려해 볼 필요가 있습니다.

### 2. 가독성 및 유지보수성
코드의 가독성은 양호합니다. 변수 이름이 명확하고 유추가 가능하여 이해하기 쉬운 구조입니다. 하지만 `alertMessage` 배열을 생성하는 부분에서, 메시지를 더 직관적으로 표현하기 위해 단일 문자열 배열 대신 동적 객체를 고려할 수 있습니다. 예를 들어, 메시지와 관련된 정보를 함께 유지할 수 있습니다.

### 3. 효율성
`setContainerHeight` 변수를 React의 상태에서 제거하고, 배열 비구조화 할당을 사용하여 불필요한 상태 업데이트를 피한 점은 좋습니다. 그러나 사용하지 않는 변수라면 `useState` 훅 자체를 제거하면 더 깔끔해질 것입니다. 현재 상태에서 이 변수는 불필요할 수 있으므로, 이를 적절하게 분석하여 제거하는 것이 좋습니다.

### 4. 확장성 및 모듈성
현재의 상태에서는 확장성에 문제가 없어 보입니다. `AlertModal` 컴포넌트를 사용하여 메시지를 사용자에게 알릴 수 있으며, 다양한 유형의 알림을 처리할 구조를 제공하고 있습니다. 향후 추가적인 알림 유형이 필요하다면 `alertMessage`와 같은 array 대신 구조체를 사용하는 것이 바람직해 보입니다.

### 5. 버그와 취약점
명확한 버그는 발견되지 않았으나, 페이지를 강제로 새로고침하는 `navigate(0);` 부분은 사용자가 의도치 않은 데이터 손실을 초래할 수 있으며, 사용 경험에서도 좋지 않습니다. 대신 특정 컴포넌트를 리렌더링하도록 하거나 필요한 데이터만 갱신하는 방향으로 변경하는 것이 좋습니다.

### 6. 테스트 가능성
현재 구조에서는 테스트가 가능하긴 하지만, `navigate`와 같은 사이드 이펙트를 가진 부분은 모의 처리(mocking)를 통해 더 세밀하게 테스트할 필요가 있습니다. 상태 변수와 비즈니스 로직을 분리하여, 더 높은 테스트 가능성을 제공할 수 있습니다. 예를 들어, `makeAlert`와 같은 헬퍼 함수를 만들어 이를 테스트할 수 있도록 하는 방법을 제안합니다.

### 결론
전반적으로 변경된 코드는 관련 기능을 잘 구현하고 있으며, 가독성과 유지보수성도 높은 편입니다. 그러나 몇 가지 개선점이 있으며, 특히 페이지 리렌더링과 관련된 부분의 리팩토링이 필요합니다. 각 기능을 모듈화하고, 테스트 가능성을 높이는 방향으로 발전할 수 있으므로, 이를 고려하는 것이 좋겠습니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:25:47.032071', 26, '2024-11-12 17:25:47.032071', 14, '리뷰어의 역할에 따라 코드 변경 사항에 대해 다음과 같이 평가하고 피드백을 제공합니다.

### 1. 기능적 정확성
변경된 코드에서 **AlertModal** 컴포넌트에 `icon`과 `iconClassName` 속성을 추가함으로써 성공 및 실패 상태에 대한 사용자 피드백이 명확하게 전달됩니다. 이를 통해 사용자 경험이 개선됩니다. `isSuccess` 상태 변수를 추가하여 응답 결과에 따른 처리가 잘 이루어지고 있으며, 기본적인 로직도 잘 유지되고 있습니다. 

### 2. 가독성 및 유지보수성
가독성 측면에서, `isSuccess` 변수를 이용해 성공과 실패의 상태를 관리하는 방식이 명확하여 코드 유지보수성이 높아졌습니다. 하지만, 상태 변수를 설정하는 부분에서 다음과 같은 개선이 가능합니다:
- `setAlertMessage`에 직접 문자열 배열을 할당하는 대신, 조건에 따라 메시지를 설정하는 헬퍼 함수를 만들면 재사용성과 가독성이 더욱 개선될 수 있습니다.

### 3. 효율성
변경된 코드에서의 성능은 크게 영향을 받지 않지만, 알림 메시지를 처리하는 로직이 반복되고 있습니다. 다음과 같이 중복 코드를 줄일 수 있습니다:
```javascript
const displayAlertMessage = (message, success) => {
  setIsAlertModalOpen(true);
  setAlertMessage([message]);
  setIsSuccess(success);
}

if (response.status === ''SUCCESS'') {
  displayAlertMessage(''프롬프트가 성공적으로 저장되었습니다.'', true);
  navigate(0);
} else {
  displayAlertMessage(''프롬프트 저장에 실패했습니다.'', false);
}
```
이렇게 하면 코드의 중복을 줄이고, 명확한 함수명 덕분에 가독성을 높일 수 있습니다.

### 4. 확장성 및 모듈성
현재 코드 구조는 향후 확장 가능성 면에서도 괜찮습니다. 그러나 alert 메시지와 상태 처리를 더욱 모듈화하면, 다른 부분에서도 재사용할 수 있어 확장성을 더욱 높일 수 있습니다. 예를 들어, 알림을 처리하는 별도의 커스텀 훅을 만들어서 다양한 컴포넌트에서 사용할 수 있도록 하는 방법이 있습니다.

### 5. 버그와 취약점
현재로서는 명백한 버그는 발견되지 않았습니다. 그러나 네비게이션 호출 (`navigate(0)`) 부분에서 페이지를 새로 고침하는 것은 상태 관리를 어렵게 만들 수 있습니다. 페이지를 새로 고침하는 것이 아니라, 상태를 직접 업데이트하여 필요한 데이터를 다시 가져오는 방식을 고려하는 것도 좋습니다.

### 6. 테스트 가능성
코드는 기능적으로 잘 구조화되어 있으며, 각 상태에 따라 다른 반응을 나타내기 때문에 단위 테스트와 UI 테스트에 유리합니다. 추가로, `setIsAlertModalOpen`과 `setAlertMessage`를 호출하는 부분을 갖는 테스트를 구현할 수 있습니다. 모든 조건을 잘 커버할 수 있도록 다양한 상황을 가정하여 테스트 케이스를 작성하는 것이 중요합니다.

### 결론
변경 사항 전반적으로 긍정적으로 보여지며, 사용자 경험이 개선되었습니다. 그러나 가독성을 높이고 중복 코드를 줄이는 방향으로 약간의 리팩토링을 고려할 필요가 있습니다. 이러한 개선 점을 반영한다면 코드의 유지보수성과 확장성이 더욱 강화될 것입니다. 

다음 단계로 이동하기 위해 몇 가지 지침을 따르는 것이 좋습니다. 추가적인 조정이나 수정 사항이 필요하다면 적극적으로 논의해 주시기 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:28:56.078428', 27, '2024-11-12 17:28:56.078428', 14, '## 코드 리뷰

### 1. 기능적 정확성
- 변경된 코드에서는 `isAlertModalOpen`, `alertMessage`, `isSuccess` 상태 변수를 이용해 사용자에게 성공 또는 실패 메시지를 시각적으로 전달하고 있습니다. 이는 의도한 대로 동작할 가능성이 높지만, `setIsSuccess(true/false)`를 설정하는 부분에서 `response.status`를 검증하는 로직이 명확히 드러나므로 향후 확장/유지보수를 위해 더욱 명시적인 방법으로 처리할 가능성을 고려해 보시기 바랍니다.

### 2. 가독성 및 유지보수성
- 코드는 전반적으로 가독성이 좋으며, 상태 변수를 명확하게 사용하고 있습니다. 다만, `AlertModal`에 전달되는 속성 `icon`과 `iconClassName`의 결정 과정이 조금 더 명시적이면 좋겠다는 생각이 듭니다. 예를 들어, 성공/실패 상태에 따라 스타일이 달라지므로, 이러한 변수를 별도의 함수로 추출하여 처리하는 것도 좋습니다. 이는 코드의 유지보수성을 더욱 높여줄 것입니다.

### 3. 효율성
- `alertMessage`는 배열로 구성되어 있으며, 성공/실패 메시지를 각각 담고 있습니다. 필요할 경우 다양한 메시지를 동적으로 추가할 수 있도록 되어 있지만, 특정 메시지만 보여줄 경우 단일 문자열로 관리하는 것도 성능 및 관리 측면에서 이점이 있을 수 있습니다. 현재 사용 상황에서 스테이트 업데이트가 잦기 때문에, 불필요하게 리렌더링되는 경우를 줄이는 방안도 고려해 보시기 바랍니다.

### 4. 확장성 및 모듈성
- `CustomPromptContainer`는 명확한 역할을 수행하고 있지만, 필요에 따라 AlertModal에 대한 더 많은 설정이나 다양한 피드백을 관리해야 할 경우, 메시지를 처리하는 로직을 별도의 모듈로 분리할 수 있습니다. 이는 시스템의 확장성에 도움을 줄 것입니다.

### 5. 버그와 취약점
- 현재 코드는 상태를 업데이트하는 부분이 명확히 드러나 있습니다. 그러나 버튼 핸들러나 다른 이벤트에서 적합한 조건문을 통해 잘못된 클릭이나 상태이동을 방지하기 위한 추가적인 방어 코드를 고려해 보시기 바랍니다. 오류 발생 시 사용자가 명확하게 피드백을 받을 수 있어야 하며, 애플리케이션의 안정성을 높이는 데 기여할 수 있습니다.

### 6. 테스트 가능성
- `CustomPromptContainer`의 현재 상태 관리와 ui 상태 전환 로직은 테스트하기 용이한 구조로 설계되어 있습니다. 하지만, 다양한 응답 시나리오와 상호작용에 대한 유닛 테스트를 추가하는 것이 필요합니다. 특히 AlertModal의 작동 방식을 테스트하기 위한 모의 테스트를 활용하는 것이 좋습니다.

### 종합 의견
변경된 코드에서는 불필요한 변수를 제거하고, 사용자 피드백을 강화하는 등 긍정적인 변화를 볼 수 있었습니다. 그러나 더 나은 가독성을 위해 일부 로직을 분리하고, 각 요소의 명확한 의도를 드러내기 위한 리팩토링이 필요합니다. 이러한 점을 보완하면 코드의 유지보수성과 확장성이 더욱 높아질 것으로 보입니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:33:49.76771', 28, '2024-11-12 17:33:49.76771', 14, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 추가된 `isSuccess` 상태와 알림 모달의 조건부 아이콘 변경은 사용자 경험을 향상시키고 기능적으로 적절하게 보입니다. 프롬프트 저장 결과에 따라 다르게 표시되는 피드백은 사용자가 작업의 결과를 명확하게 인지할 수 있게 합니다. 단, `navigate(0)` 호출이 필요한 이유를 주석으로 명시하는 것이 좋습니다. 이렇게 하면 코드의 의도가 명확해지고, 나중에 다른 개발자가 코드를 이해하는 데 도움이 됩니다.

### 2. 가독성 및 유지보수성
코드의 구조는 전반적으로 잘 구성되어 있으며, 상태 관리와 UI 로직을 분리하는 방식은 가독성을 높입니다. 그러나 함수 및 변수 이름이 기능을 충분히 설명하지 않는 경우가 있습니다. 예를 들어, `setIsSuccess`는 좋지만 더 명확한 이름인 `setOperationSuccessful`로 변경할 수 있습니다. 또한, 불필요한 줄바꿈을 줄여 코드의 밀도를 높이면 가독성이 더 좋아질 수 있습니다.

### 3. 효율성
`setContainerHeight`의 사용이 가비지 컬렉션 처리로 제거되어 상태 업데이트와 관련된 불필요한 작업을 줄이는 것은 성능 개선에 도움이 됩니다. 하지만 `const [, setContainerHeight]` 구문을 사용하여 상태를 유지하는 것이 실제로 필요한지 고민해볼 필요가 있습니다. 만약 이 값이 필요하지 않다면, 해당 상태를 완전히 제거하는 것이 효율적일 것입니다.

### 4. 확장성 및 모듈성
추가한 `CircleCheck`와 `TriangleAlert` 컴포넌트를 사용하는 방식은 동적인 피드백 제공에 유용합니다. 다만, 추후 새로운 알림 유형이 필요할 경우 이 구조가 충분히 유연한지 점검이 필요합니다. 특정한 화면 상태를 처리하는 것 외에, 여러 컴포넌트에서 재사용할 수 있도록 알림 모달을 별도의 컴포넌트로 분리하는 것도 좋은 리팩토링이 될 수 있습니다.

### 5. 버그와 취약점
현재 코드에서 명백한 버그는 발견되지 않았으나, `navigate(0)` 사용으로 인해 페이지가 리프레시되면서 상태가 초기화되는 점은 유의해야 합니다. 이 로직은 의도된 대로 작동하지만, 사용자 경험 측면에서 페이지 이동 없이 상태 업데이트로 해결할 수 있는 방법을 고민해볼 수 있습니다. 또한, API 호출 후 응답 상태에 대한 체크가 충분히 명확한지 점검(예: `response.status` 처리)을 고려해야 합니다.

### 6. 테스트 가능성
알림 기능과 상태 변화는 별개의 유닛 테스트로 잘 커버될 수 있습니다. 하지만 현재 상태에서의 UI 반응 및 상태 변화에 대한 테스트 케이스 작성이 필요합니다. 특히 `isSuccess`와 관련된 상태 변화는 다양한 상황을 가정하여 테스트되어야 합니다.

### 결론
전반적으로 변경 사항은 기능적 요구를 충족하며, 접근성을 개선하는 코드입니다. 가독성을 높이고, 몇 가지 리팩토링을 통해 유지보수성과 확장성을 더욱 강화할 수 있습니다. 아이콘과 상태 관리 등 UI 관련 요소는 잘 처리되고 있으나, 개선할 수 있는 부분도 존재합니다. 변화가 다른 모듈과 통합될 때의 영향을 고려한 코드 유지가 중요하므로, 추가적으로 통합 테스트를 권장합니다.

**리뷰 요청사항에 대한 코멘트:**
- 이 코드의 수정을 승인하기에 앞서 위에서 언급된 개선 사항들을 반영한다면 더욱 완벽한 코드가 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:34:25.839675', 29, '2024-11-12 17:34:25.839675', 14, '# 코드 리뷰

## 1. 기능적 정확성
변경된 코드가 기본적으로 요구사항을 충족하는 것으로 보입니다. `isSuccess` 상태를 도입하여 프롬프트 저장의 결과에 따라 알림 모달에 아이콘을 동적으로 변경하는 로직이 잘 구현되었습니다. 그러나 동작을 검증하기 위해 API의 응답 형태가 예상한 대로인지 확인할 필요가 있습니다.

## 2. 가독성 및 유지보수성
가독성 측면에서 큰 문제는 없지만, `setIsSuccess(true)`와 `setIsSuccess(false)` 호출이 각각의 다른 상태에서 발생합니다. 이러한 부분은 주석이나 더 명확한 함수 이름을 추가함으로써 가독성을 높일 수 있습니다. 예를 들어, `handleSuccess`와 `handleError`와 같은 별도의 함수를 정의하면 코드의 의도를 명확히 할 수 있습니다. 

또한, `alertMessage`의 내용을 각 상태에서 직접 설정하는 대신, 명확한 상수를 만들어 사용할 수도 있습니다. 이는 코드 유지보수성을 높이는 데 도움이 될 것입니다.

## 3. 효율성
`navigate(0)` 함수 호출은 페이지를 새로고침하는 것으로, 이 부분이 실제로 코드의 성능에 영향을 줄 가능성은 적지만, 사용자 경험 측면에서는 좋지 않을 수 있습니다. 대신 해당 상태를 로컬에서 업데이트할 수 있는 방법을 찾아보는 것이 좋습니다. 

마지막으로, `isSuccess` 상태를 `AlertModal`에서만 사용하고 있는데 추가적인 모달 UI에서 혜택을 누릴 수 있도록 다른 개선점을 고려해볼 수 있습니다.

## 4. 확장성 및 모듈성
현재 코드에서는 `AlertModal`을 사용하는 방식을 바탕으로 간단한 모델을 제공합니다. 그러나 다양한 종류의 알림을 처리해야 하는 경우, 더 나은 확장성을 위해 `AlertService`와 같은 별도의 서비스를 생성하여 요청과 응답을 처리하는 방법을 고려해볼 수 있습니다. 이를 통해 코드가 점점 복잡해질 경우에도 보다 쉽게 관리할 수 있습니다.

## 5. 버그와 취약점
현재 구현에 대한 잠재적인 버그는 커다란 위험 요소로 보이지 않습니다. 하지만 API 응답의 형태가 변경되거나 예외가 발생할 경우를 대비하여 오류 처리 로직이 필요합니다. 예를 들어, API 호출이 실패할 경우 적절한 사용자 피드백을 제공하는 것이 중요합니다.

## 6. 테스트 가능성
상태 관리 로직을 함수로 분리함으로써, 각 함수에 대한 개별적으로 테스트 가능한 단위 테스트를 구현할 수 있습니다. 상태에 따라 UI가 변경되는 부분도 별도의 테스트 케이스로 커버할 수 있습니다. 반면 현재 구현에서는 UI와 상태 관리가 밀접하게 결합되어 있어 테스트의 용이성이 떨어집니다.

---

## 개선 제안 요약:
1. `setIsSuccess` 및 `alertMessage` 설정을 더 명확한 함수와 상수 사용으로 리팩토링
2. `navigate(0)`를 사용하지 않고 상태 업데이트를 통한 사용자 경험 개선
3. `AlertService`와 같은 모듈을 도입하여 알림 처리 로직 확장 가능하게 설계
4. API의 오류 처리 로직 추가
5. 테스트 가능한 구조로 변환하여 유지보수성과 가독성 향상

이러한 피드백을 바탕으로 진행하신다면, 코드의 품질과 안정성을 더욱 높일 수 있을 것입니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:35:45.873392', 30, '2024-11-12 17:35:45.873392', 14, '안녕하세요! 코드 리뷰를 시작하겠습니다. 아래는 코드 변경 사항에 대한 평가입니다.

### 1. 기능적 정확성:
변경된 코드에서 새로운 `isSuccess` 상태 변수를 도입하고, `AlertModal`에 성공과 실패 아이콘을 부여하는 로직을 추가했습니다. 이는 사용자에게 프롬프트 저장 결과를 시각적으로 명확하게 전달하는 데 도움을 줄 것입니다. 다만, `console.log` 등 디버깅을 위한 코드는 제거하는 것이 바람직합니다. 이러한 조정이 필요할 수 있습니다.

### 2. 가독성 및 유지보수성:
변경된 부분은 가독성을 개선하는 데 긍정적인 영향을 미쳤습니다. 상태 변수를 추가하여 성공 및 실패 시 다른 아이콘을 표시하도록 한 점이 잘 구현되어 있습니다. 다만, `isSuccess`와 같은 상태 변수를 사용할 때 주석을 추가하면 다른 개발자들이 코드의 의도를 쉽게 이해할 수 있을 것입니다. 예를 들어, `// 저장 성공 여부` 같은 주석을 추가하는 것을 추천합니다.

### 3. 효율성:
‘HomePage’ 컴포넌트에서 기존의 `containerHeight` 상태가 사용되지 않게 된 점은 불필요한 리렌더링을 줄여 효율성을 높인 부분이라 할 수 있습니다. 이런 작은 최적화는 성능에 긍정적인 영향을 미칩니다. 그러나 여전히 사용되지 않는 변수는 다른 reviewer들이 확인할 수 있도록 리뷰 중 삭제하는 것이 좋습니다.

### 4. 확장성 및 모듈성:
코드는 충분히 모듈화되어 있으며, `AlertModal`을 사용하여 상황에 맞는 팝업을 처리하는 로직이 잘 구현되어 있습니다. 이 접근법은 확장성 또한 고려한 것으로, 향후 추가적인 알림 유형이나 로직이 필요한 상황에서도 간단히 수정할 수 있습니다.

### 5. 버그와 취약점:
현재 코드는 잠재적인 버그 없이 작성되었습니다. 상태 관리 및 API 응답에 따라 조건적으로 `AlertModal`을 렌더링하는 로직은 의도한 대로 작동할 것으로 보입니다. 다만, API 호출 중 오류 처리 로직이 부족한 경우 실제 환경에서 예외 상황을 처리하기 힘들 수 있습니다. 추가적인 오류 처리 로직을 도입하면 좋을 것 같습니다.

### 6. 테스트 가능성:
상태 관리 및 `AlertModal`의 렌더링 방식 덕분에 테스트를 용이하게 만들 수 있는 구조입니다. 특히 다양한 상태를 가진 조건부 렌더링은 Jest와 React Testing Library와 같은 프레임워크에서 쉽게 테스트할 수 있습니다. 다만 상태 업데이트 및 렌더링된 결과를 검증하는 테스트 케이스를 추가하는 것도 고려해야 할 것입니다.

### 7. 균형 잡힌 피드백:
전반적으로 코드는 잘 구조화되어 있으며, 사용자에게 친숙한 피드백을 제공하는 뚜렷한 방법을 추가한 점이 훌륭합니다. 그러나 불필요한 변수들이 남아 있는 경우 이는 코드의 청결성을 해칠 수 있는 요소로, 이들을 제거하는 것이 앞으로 더 나은 유지보수성을 보장할 것입니다.

### 최종 결론:
변경 사항은 전체적으로 긍정적이며, 코드의 가독성과 사용자 경험(UX)을 향상시킬 수 있는 방향으로 잘 진행되었습니다. 다만, 작은 최적화와 추가적인 오류 처리 로직으로 개선할 수 있는 여지가 있으므로, 이를 고려하여 진행하시길 추천드립니다.

감사합니다!');
INSERT INTO public.review VALUES ('2024-11-12 17:38:02.982947', 31, '2024-11-12 17:38:02.982947', 14, '## 코드 리뷰

### 1. 기능적 정확성
코드 변경 사항은 전반적으로 기능적인 요구사항을 잘 충족하고 있습니다. 특히, `AlertModal`을 통해 성공 및 실패 메시지를 조건에 따라 적절히 보여주는 부분이 향상되었습니다. `isSuccess` 상태를 추가하여 성공적인 저장과 실패를 시각적으로 구별할 수 있어 사용자 경험을 개선했습니다. 다만, `navigate(0)` 호출로 페이지를 새로 고치는 방식은 사용자가 고의로 다른 경로를 탐색하고 돌아왔을 때의 상태를 잃게 할 수 있습니다. 간단한 상태 관리 방식으로 이를 개선할 수 있을 것입니다.

### 2. 가독성 및 유지보수성
코드는 전반적으로 가독성이 높고 구조가 잘 정리되어 있습니다. `setIsAlertModalOpen`, `setAlertMessage`, `setIsSuccess`와 같은 상태 업데이트 함수가 명확하여, 각각의 역할을 쉽게 이해할 수 있습니다. 그러나, `alertMessage` 배열이 여러 메시지를 포함할 수 있도록 하였는데, 사용자에게 하나의 메시지만 표시할 경우, 배열 대신 단순한 문자열을 사용하는 것이 더 명확할 수 있습니다. 

### 3. 효율성
`setContainerHeight`를 사용할 필요가 없다는 점은 잘 안 쓰는 변수를 제거하여 코드의 효율성을 높인 좋은 변경 사항입니다. 그러나, 코드에서 초기화된 변수를 재사용하지 않고 빈 변수를 남겨두었는데, 불필요한 상태 업데이트로 이어질 수 있습니다. 최적화가 필요한 부분입니다.

### 4. 확장성 및 모듈성
현재 구조는 모듈화가 잘 되어 있어 확장 가능성이 있습니다. 컴포넌트가 잘 분리되어 있으며, 특정 기능에 따라 변경 사항을 쉽게 추가할 수 있습니다. 예를 들어, 메시지 종류가 늘어나거나, 새로운 알림 방식이 필요할 경우, 이 구조는 충분히 수용할 수 있습니다. 다만, 전체 코드베이스에서 이와 유사한 메시지 처리 코드가 있다면, 공통된 핸들러를 작성하여 중복을 줄이는 방식으로 리팩토링할 수 있습니다.

### 5. 버그와 취약점
현재 코드에서는 큰 버그나 취약점은 식별되지 않았습니다. 조건부 렌더링에서 `isAlertModalOpen`이 `true`일 때만 `AlertModal`이 표시되므로, 사용자가 상황을 이해하는 데 혼란이 없을 것입니다. 그러나 `navigate(0)`이 아닌 최소한의 상태 관리로 진행해도 충분할 것으로 보입니다. 이렇게 하면 상태가 유지되면서도 깔끔하게 처리할 수 있습니다.

### 6. 테스트 가능성
코드가 테스트를 위한 구조로 잘 작성되었습니다. 특히 각 상태 관리와 렌더링 조건이 잘 정의되어 있어 유닛 테스트 작성이 용이합니다. 그러나 상태 업데이트에 따른 연결 부분을 더욱 명확히 하고 주석을 추가하여 나중에 테스트를 위한 기준 마련이 필요할 것입니다.

### 7. 균형 잡힌 피드백
전반적으로 코드 변경 사항이 시스템의 기능성과 유지 보수성에 긍정적 영향을 미친 점은 높이 평가할 수 있습니다. 추가된 `isSuccess` 상태와 그에 따른 `AlertModal` 구성이 효율적이며 사용자 경험을 개선했습니다. 반면, 사용하지 않는 변수의 삭제는 성능과 가독성을 높이는데 기여하였으나 전체 상태 관리에서의 일관성 문제는 다시 검토할 필요가 있습니다. 이러한 세심한 변화들을 통해 코드가 더욱 견고해질 것으로 기대합니다.

## 결론
변경 사항이 전반적으로 긍정적이며 기능과 사용자 경험을 개선하고 있습니다. 그렇지만 몇 가지 작은 점에 대한 개선 여지가 있으며, 이를 통해 코드의 퀄리티를 더욱 높일 수 있을 것입니다. 이 상태로 MR을 승인하겠습니다.');
INSERT INTO public.review VALUES ('2024-11-12 17:38:36.961812', 32, '2024-11-12 17:38:36.961812', 16, '코드 리뷰를 시작하겠습니다. 코드의 변경사항을 기반으로 기능적 정확성, 가독성, 효율성, 확장성, 버그 및 취약점, 테스트 가능성 그리고 전체적인 품질에 대해 분석해 보겠습니다.

### 1. 기능적 정확성
변경된 코드에서 GraphQL 쿼리를 생성하는 메소드들이 전반적으로 유지되었습니다. 상당수의 메소드에서 쿼리 문자열이 개선되어 가독성이 높아졌습니다. 그러나 쿼리의 기본 구조가 변경되지 않으므로 기능적 정확성은 대체로 유지되고 있다고 평가됩니다. 다만, 메소드 명칭 변경 시 기존의 의미를 유지하는지 검토가 필요합니다. 예를 들어, `createSingleMergeRequestQuery`를 `doMergeRqOneByIdFullPathQuery`로 변경한 부분은 기능적으로 혼란을 줄 수 있으니 명명 규칙을 좀 더 명확히 적용하는 것이 좋겠습니다.

### 2. 가독성 및 유지보수성
가독성이 개선되었습니다. 특히, 메소드의 문자열로 이루어진 쿼리들을 줄바꿈 및 템플릿 형태로 보고, 반복되는 문자열을 줄이는 방식이 돋보입니다. 많이 분리된 쿼리 문자열이 한 줄로 붙어있던 부분이 줄바꿈을 통해 가독성이 크게 증가했습니다. 그러나 메소드 명칭이 너무 길거나 명확하지 않을 수 있는 부분이 있으니, 협업하는 팀원들이 이해하기 쉽게 명칭을 추가적으로 간소화하는 것이 좋습니다.

### 3. 효율성
리팩토링 과정에서 쿼리 문자열의 형식이 단순해진 점은 긍정적입니다. 하지만 메소드에서 long 타입의 IDs와 같은 부분의 처리 개선이 필요합니다. 예를 들어, 스트림을 사용하여 ID를 모을 때 각 ID의 타입 변환이 효율적이지 않을 수 있으니, 이를 개선할 수 있는 방법을 함께 고민하는 것이 좋습니다. 

### 4. 확장성 및 모듈성
전반적으로 코드 구조가 모듈화되어 있는 점은 긍정적입니다. 특히, 함께 묶인 쿼리들의 변경이 전체적인 쿼리 변경 없이 이루어질 수 있다는 점에서 확장성 있는 코드라고 평가할 수 있습니다. 하나의 메소드가 여러 쿼리를 처리하도록 변경할 경우, 쿼리 생성 로직의 재사용성이 증가할 것으로 보입니다.

### 5. 버그와 취약점
현재 코드에서 코드의 잠재적인 버그나 취약점은 명백히 드러나지 않지만, 메소드 내에서 ID를 항상 신뢰하는 부분이 있어 예외 처리가 필요합니다. URL 생성 로직에서 `Long.parseLong(...)` 호출에 예외 처리가 없어, 잘못된 입력이 들어올 경우 러너블 예외가 발생할 수 있습니다. 이를 방지하기 위해 검증 로직이 필요합니다.

### 6. 테스트 가능성
테스트 가능한 구조는 상대적으로 잘 갖추어져 있습니다. 각각의 GraphQL 쿼리를 생성하는 메소드가 독립적이기 때문에 단위 테스트가 용이할 것으로 예상됩니다. 그러나 각 메소드에서 쿼리 생성 시 발생할 수 있는 예외를 다루는 방법이 명확하지 않으므로, 이는 테스트 시 트리거되기 쉬움으로 사전에 예외처리를 고려하는 것이 좋습니다.

### 7. 균형 잡힌 피드백
전반적으로 코드 리팩토링에서 가독성과 유지보수성이 개선된 점은 매우 긍정적입니다. 그러나 메소드 명칭이 명확하지 않거나 긴 부분이 있어 이를 고민하고 다듬는 것이 필요합니다. 가능하다면 명명 규칙을 팀 내부에서 일관되게 정리하여 향후 유사한 리팩토링 이 진행될 때 기준을 확보하는 것도 도움이 될 것입니다. 

결론적으로, 코드에 대한 리팩토링은 전반적으로 긍정적이지만, 메소드 명명, 예외 처리 및 성능 최적화에 있어 다소 개선이 필요해 보입니다. 이 부분들을 충족시키면 더욱 우수한 품질의 코드로 발전할 것입니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:54:34.425342', 118, '2024-11-13 13:54:34.425342', 22, '### 코드 리뷰 피드백

#### 1. Readability (가독성)
- **잘 수행된 점**: 
  - 로그 메시지가 추가되어 SSE 연결의 상태를 추적할 수 있게 되었습니다. 이는 문제 발생 시 디버깅에 큰 도움이 됩니다.
  - 코드 블록이 적절하게 줄 바꿈되어 가독성이 향상되었습니다.
  
- **개선이 필요한 점**:
  - 로그 메시지에 포함된 ID는 String으로 변환하여 사용하고 있습니다. `${id}` 형태의 템플릿 문자열을 사용하는 것은 어떨까요? 이렇게 하면 문자열 결합을 피하고 가독성이 더욱 향상됩니다. 예를 들어:
    ```java
    log.info("SSE connection completed for id: {}", id);
    ```

#### 2. Consistency (일관성)
- **잘 수행된 점**:
  - 로그 메시지 형식이 일관되며, `log.info` 및 `log.error`의 사용이 적절히 이루어지고 있습니다.
  
- **개선이 필요한 점**:
  - 다른 부분에서도 로그를 사용할 경우, 모든 예외 처리 부분에서 같은 스타일을 유지하는 것이 좋습니다. 예를 들어, `emitter.complete();` 부분에서 연결이 완료된 경우에도 로그를 추가하는 것이 좋을 것입니다. 즉, 에러 처리에서 로그 레벨이 일관되게 사용되도록 합니다.

#### 3. Reusability (재사용성)
- **잘 수행된 점**:
  - `SseEmitter`와 같은 객체를 독립적인 메서드와 함께 작성하여 구조화했습니다. 이는 향후 유사한 기능을 필요로 할 때 재사용할 수 있는 가능성을 높입니다.
  
- **개선이 필요한 점**:
  - 에러 처리와 로그 출력을 별도의 메서드로 분리하면 코드의 재사용성과 가독성을 더욱 높일 수 있습니다. 예를 들어, 에러 처리와 로그 기록을 별도의 메서드로 추출할 수 있습니다.

#### 4. Reliability (신뢰성)
- **잘 수행된 점**:
  - `onError`와 같은 메서드를 추가하여 예외 처리가 향상되었습니다. 이는 더욱 신뢰성이 높은 코드를 만드는 데 기여합니다.
  
- **개선이 필요한 점**:
  - 다양한 오류 상황에 대한 처리가 전부 포함되어야 합니다. 예를 들어, `RuntimeException`이 발생했을 때, 다른 대체 행동이나 사용자에게 더 친숙한 오류 메시지를 제공할 수 있도록 개선할 수 있습니다.

#### 5. Security (보안성)
- **잘 수행된 점**:
  - SSEEmitter와 같은 비동기적으로 처리되는 객체를 관리할 때 세션 CSRF 등 보안 취약점에 주의를 기울이고 있는 것처럼 보입니다.
  
- **개선이 필요한 점**:
  - ID에 대한 입력 검증이 필요해 보입니다. 잘못된 ID가 시스템에 들어갔을 때 예상하지 못한 동작이 발생할 수 있습니다. 예를 들어, ID가 유효한 형식인지 확인하는 검증 메서드를 추가하는 것을 고려해보세요.

#### 6. Maintainability (유지보수성)
- **잘 수행된 점**:
  - 각 부분의 기능이 분리되어 있어, 필요한 경우 쉽게 변경하고 유지보수할 수 있는 구조입니다.
  
- **개선이 필요한 점**:
  - 코드가 성장할수록, 해당 클래스가 많은 책임을 지게 될 수 있습니다. 이럴 경우 단일 책임 원칙(SRP)을 더욱 강하게 적용하여 서비스 로직을 별도의 클래스로 이동시키는 것을 권장합니다.

### 전체적인 피드백
변경된 코드에서 로그를 사용하는 접근 방식은 디버깅과 운영 모니터링에 큰 도움이 될 것으로 보입니다. 로그 메시지는 사용자에게 실질적인 정보를 제공하여 가시성을 높이고 있습니다. 

하지만, 몇 가지 개선 사항을 통해 더욱 탄탄한 구조로 발전시킬 수 있습니다. 특히 에러 처리와 재사용성을 개선하는 방향으로 노력한다면, 코드의 유연성을 높이고 유지보수가 쉽게 이루어질 것입니다.

결론적으로, 잘 작성된 코드기에 강력하게 추천드리며, 제안한 개선 사항들을 고려해보시면 더 나은 방향으로 나아갈 수 있을 것입니다. 좋은 일 해주셨습니다! 🌟');
INSERT INTO public.review VALUES ('2024-11-12 17:40:33.392072', 33, '2024-11-12 17:40:33.392072', 14, '## 코드 리뷰

1. **기능적 정확성**: 
   - 변경된 코드가 기존 기능에 명확한 개선을 제공하고 있습니다. 특히, 성공 및 실패 메시지를 구분하여 사용자에게 더 나은 피드백을 제공하고, 상태 관리의 명확성이 높아졌습니다. `isSuccess` 변수를 추가함으로써 성공적인 작업과 실패한 작업을 시각적으로 구분할 수 있게 되었습니다. 하지만, 응답 상태에 대해 추가적인 처리(예: 에러 코드 처리 등)를 고려할 수 있습니다. 이는 더 나은 사용자 경험을 제공할 수 있습니다.

2. **가독성 및 유지보수성**: 
   - 코드 전반적으로 가독성이 좋습니다. 상태 변수의 명명 규칙이 명확하여 코드의 의도를 쉽게 파악할 수 있습니다. 특히 `setIsSuccess`와 같은 변수명은 읽는 이로 하여금 그 역할을 쉽게 이해하도록 돕습니다. 그러나, `useAtom`으로 가져온 `projectId`는 사용되지 않고 있어 혼란을 줄 수 있습니다. 이를 제거하거나 사용하도록 변경하는 것이 좋습니다.

3. **효율성**: 
   - 코드가 전반적으로 효율적으로 작성되었습니다. 불필요한 변수를 제거하고, `setContainerHeight`에서 배열 비구조 할당을 사용하여 더 깔끔하게 작성한 점은 긍정적인 요소입니다. 콘솔 출력을 통해 에러 메시지나 상태 변화를 확인하기 쉬운 구조로 되어 있어, 디버깅 시 유리할 것입니다.

4. **확장성 및 모듈성**: 
   - 코드는 잘 모듈화되어 있으며, `AlertModal`을 활용하여 사용자 피드백을 처리하는 방식은 향후 추가적인 피드백 유형(예: 경고, 정보 등)을 쉽게 확장할 수 있는 구조입니다. 그러나, AlertModal에서 사용되는 아이콘 부분이 고정되어 있기 때문에, 다양한 상황에 대한 커스터마이징이 필요할 수 있으므로 이에 대한 유연성을 고려해 리팩토링할 수 있을 것입니다.

5. **버그와 취약점**: 
   - 현재로서는 코드에서 직접적인 버그가 발견되지 않았습니다. 그러나, `setIsSuccess`가 설정된 상태에 따라 다음에 호출되는 메서드의 결과에 영향을 받을 수 있으므로, 이 부분에 대한 에러 상태 확인을 추가하여 취약점이 생기지 않도록 주의하는 것이 중요합니다.

6. **테스트 가능성**: 
   - 새로운 상태 관리 로직이 추가되면서, 전체적으로 테스트 범위가 증가하였습니다. 특히, `isSuccess`와 관련된 테스트 케이스를 추가하여 성공/실패 시나리오를 독립적으로 검증할 수 있도록 할 필요가 있습니다. `AlertModal`과의 통합 테스트를 통해 사용자 피드백 흐름을 검증할 수 있습니다.

7. **균형 잡힌 피드백**: 
   - 전체적으로 코드의 많은 부분이 잘 작성되어 있으며, 개선된 피드백 로직은 사용자의 경험을 크게 향상시킬 것으로 예상됩니다. 다만, 불필요한 코드(예: `projectId`를 사용하지 않는 부분)는 제거할 필요가 있고, 사용하지 않는 변수를 정리하여 코드의 가독성을 더욱 높일 수 있을 것입니다. 모범적인 부분인 코드의 가독성과 유지보수성은 긍정적으로 평가됩니다.

결론적으로, 이 코드 변경 사항은 기존 기능을 잘 개선한 부분이 많으며, 몇 가지 사소한 개선만으로 더욱 견고한 구조로 발전할 수 있을 것입니다.');
INSERT INTO public.review VALUES ('2024-11-12 18:01:51.735197', 34, '2024-11-12 18:01:51.735197', 17, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 변경한 것은 이해관계를 정리하는데 도움을 줍니다. 이는 각 메소드의 파라미터가 보다 명확하게 해당 정보를 나타내므로, 전반적으로 코드의 정확성이 향상됩니다. 다만, 이 변경이 다른 의존성에 미치는 영향을 충분히 검토했는지 확인할 필요가 있습니다.

### 2. 가독성 및 유지보수성
- `subscribe` 메소드와 `sendDataTest` 메소드에서 매개변수 이름을 `mrInfoId`에서 `reviewId`로 변경한 것은 코드의 가독성을 높입니다. 각 메소드의 역할이 명확해지고, 코드 전체가 일관성 있게 보입니다.
- 그러나, 메소드를 호출하는 다른 부분에서 이 변경이 어떻게 반영되는지 문서화되어야 합니다. 현재 변경 사항이 종속된 외부 코드(BE 또는 FE)에서의 수정 사항을 명확히 기재하는 것이 좋습니다.

### 3. 효율성
변경된 코드에서는 주목할 만한 효율성을 저해하는 요소가 발견되지 않았습니다. 오히려 파라미터의 의미를 명확히 함으로써 추후 코드의 해석 및 유지보수가 개선될 것입니다. 다만, `sendToClient` 메소드는 여러 예외를 처리하는 부분에서 로그 정보를 출력하고 있습니다. 대안으로 로그 수준을 조정하거나 예외 처리 전략을 재검토할 수 있습니다.

### 4. 확장성 및 모듈성
`SseService`와 `SseController`의 역할이 명확해지고, 각기 다른 책임에 충실해졌습니다. 그러나 만약 앞으로 코드의 구조가 확장될 경우, 이들 서비스와 컨트롤러가 어떻게 기능을 나누게 될 것인지에 대한 계획이 필요합니다. 작은 변경이지만, 향후 코드의 확장성을 고려하여 구조를 더욱 견고하게 하는 방향으로 리팩토링을 고려할 수 있습니다.

### 5. 버그와 취약점
현재 코드에서 `sendToClient` 메소드의 JSON 변환 과정에서 발생할 수 있는 `JsonProcessingException`은 런타임 예외로 감싸서 처리하고 있습니다. 이는 전반적으로 안정성을 제공하지만, 가능하다면 더 세분화된 오류 처리를 통해 사용자에게 보다 유용한 피드백을 제공하는 방향으로 개선할 수 있을 것입니다. `emitter`가 존재하지 않을 때 적절한 대응이 필요합니다.

### 6. 테스트 가능성
시스템의 특정 부분들(예: `SseService`와 다른 서비스들)은 각기 다른 기능을 가지고 있어, 유닛 테스트를 작성하기에 적합한 형태를 유지하고 있습니다. 메소드 이름이 명확하게 역할을 설명하고 있어 테스트 가능성 또한 높은 상관관계가 있다고 판단됩니다. 다만, 작성된 단위 테스트가 있는지 확인하여, 변경사항에 대한 테스트가 누락되지 않도록 합시다.

### 7. 균형 잡힌 피드백
변경된 코드에서 이루어진 파라미터 이름 변경은 명확성과 가독성을 높여 주는 긍정적인 방향이며, 클래스와 메소드 간의 역할을 잘 분리해 유지보수성을 보강했습니다. 다만 전반적인 검토가 이루어지지 않은 경우, 전체 시스템에 미치는 영향에 대해 명확히 파악하는 것이 필요하므로, API 문서 또한 업데이트할 필요가 있습니다.

### 결론 및 권장 사항
- 변경된 코드의 방향성과 내용은 긍정적입니다. 다만, 관련된 다른 부분에 대한 테스트와 문서화를 통해 미치는 부가적인 영향 차원에서도 포괄적인 검토가 필요합니다.
- 필요 시, 향후 확장성에 대비하여 구조적인 리팩토링이나 추가적인 문서화를 검토합시다. 
- 오류 처리 부분에 대해 좀 더 친숙한 사용자 경험을 고려한 개선사항을 제안해 보십시오.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-12 18:04:31.906175', 35, '2024-11-12 18:04:31.906175', 17, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 변경한 것은 비즈니스 로직의 의도를 분명히 하는 긍정적인 변화입니다. 이 변경으로 인해 보다 명확하게 어떤 기능을 수행하는지 이해할 수 있게 됩니다. 그러나 이 변경이 다른 부분에서 일관되게 적용되고 있는지 확인해야 합니다. 관련된 모든 호출 및 서비스 메서드에서 동일한 ID를 사용하는지 확인하는 것이 필요합니다.

### 2. 가독성 및 유지보수성
코드의 가독성은 다음과 같은 이유로 향상되었습니다:
- `mrInfoId` 대신 `reviewId`를 사용한 것: 코드에서 사용되는 ID가 무엇을 의미하는지 명확하게 전달됩니다.
  
그러나 `sendToClient` 메서드에서 예외 처리 시 단순히 `e.printStackTrace()`를 사용하고 있습니다. 향후 유지보수를 고려할 때, 로그를 남기거나 사용자에게 발생한 오류를 보다 쉽게 추적할 수 있도록 하는 방법을 구현하는 것이 좋습니다.

### 3. 효율성
코드 변경은 주로 가독성 및 명확성에 중점을 두었으며, 효율성에 대한 직접적인 영향은 관찰되지 않았습니다. 그러나 `emitter.send(...)` 부분에서 JSON 변환을 위해 `objectMapper.writeValueAsString(data)` 호출이 빈번하게 발생할 수 있습니다. 이 부분에서 데이터가 크거나 빈번하게 호출되면 성능 저하가 발생할 수 있으므로, 캐싱을 고려해야 할 수도 있습니다.

### 4. 확장성 및 모듈성
코드 변경이 잘 이루어졌고, 모듈화된 접근 방식이 돋보입니다. `SseService` 및 `SseController`에서의 리팩토링이 잘되어 있어 확장이 용이할 것으로 판단됩니다. 그러나 향후 새로운 기능 추가의 경우, 다른 로그 메시지 형식이 필요해질 수 있으므로, 로깅 관련 유틸리티 클래스를 도입해 재사용할 수 있는 패턴을 고려해보는 것이 좋습니다.

### 5. 버그와 취약점 
현재 코드에서 발견된 잠재적 버그는 `sendToClient` 메서드를 호출했을 때 `emitter`가 `null`일 경우의 처리입니다. 오류를 콘솔에 기록할 뿐만 아니라, 클라이언트 연결을 끊는 등의 사용자 피드백 처리가 중요합니다. 예를 들어, `sendError` 메서드를 통해 클라이언트에 에러 상태를 반환하도록 조치를 고려해야 합니다.

### 6. 테스트 가능성
현재 코드 구조는 종합적으로 테스트 가능성을 고려하여 잘 작성되었습니다. 외부 종속성을 주입하고, 비즈니스 로직을 서비스 레이어에 분리시켜 컴포넌트 별로 단위 테스트를 진행할 수 있을 것으로 보입니다. 특히 `SseEmitter`와 같은 비동기 처리를 사용하는 부분은 테스트 작성이 복잡해질 수 있으므로, Mock 객체를 통한 테스트 전략을 수립하는 것이 좋습니다.

### 7. 균형 잡힌 피드백
변경 사항은 명확성과 가독성을 높이는 방향으로 잘 이루어졌습니다. `mrInfoId`와 같은 용어 대신 `reviewId`를 사용한 것은 의도와 기능을 더 잘 설명하는 좋은 접근입니다. 그러나 모든 변경 사항이 관련된 모든 메서드와 서비스에서 일관성을 가지도록 충분히 테스트하고 검증할 필요가 있습니다. 또한 예외 처리와 관련한 부분에서 코드를 보완할 필요가 있으며, 로깅 및 오류 처리 방식을 개선하면 더 안정적인 코드가 될 것입니다. 

종합적으로 긍정적인 방향으로의 변경이라고 평가합니다. 계속해서 개선할 부분들을 명심하고 개발을 이어가시기를 추천드립니다.');
INSERT INTO public.review VALUES ('2024-11-12 18:04:48.949672', 36, '2024-11-12 18:04:48.949672', 17, '코드 리뷰 결과를 아래와 같이 제시합니다.

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`가 `reviewId`로 수정된 부분은 명확한 요구사항 반영으로 보입니다. 이러한 수정은 단지 변수의 이름을 바꾸는 것이지만, 명칭을 보다 적절하게 바꾸는 것은 프로그램의 의미를 더 잘 전달할 수 있어 긍정적입니다. 단, 여전히 코드의 함수를 호출하는 부분에 대한 문서화가 필요해 보이며, `SseEmitter`의 구독 기능이 요구사항을 충족하는지에 대해 충분한 테스트가 뒷받침되어야 합니다.

### 2. 가독성 및 유지보수성
변수 이름이 `mrInfoId`에서 `reviewId`로 변경된 것은 가독성을 높이는 긍정적인 변화입니다. 코드를 이해하는 데에 있어 변수명이 더 직관적으로 된 것은 유지보수성을 향상시킵니다. 그러나, 전체 코드에서 `mrInfoId`라는 용어가 여러 군데 나타나는 경우, 이러한 변화가 일관되게 되어야 합니다. 더불어, 축약어 대신 적절한 주석을 추가하여 이해를 돕는 것이 바람직합니다.

### 3. 효율성
현재 코드에서는 효율성에 심각한 문제가 없으며, `SseEmitter`를 생성하고 전송하는 방식은 적절하게 잘 구현되어 있습니다. 주목할 점은, JSON 직렬화 시마다 `ObjectMapper`를 사용하여 변환하는 점입니다. 이와 같은 로직은 빈번히 발생하지 않지만, 성능이 중요한 경우에는 `ObjectMapper`를 애플리케이션 수준에서 관리하도록 해 캐싱하는 방안을 고려할 수 있습니다.

### 4. 확장성 및 모듈성
현재 변경사항은 특정 관점을 바꾸는 것뿐 아니라, 함수들이 명확하게 역할을 나누어 수행하고 있어 모듈성이 잘 갖추어져 있습니다. 그러나 `SseService`와 `SseController`간의 의존성 관리 및 통신 방식을 더 명확하게 하기 위해 인터페이스를 도입하는 것이 좋을 수 있습니다. 향후 비즈니스 로직이 복잡해질 경우, 그러한 패턴이 도움이 될 것입니다.

### 5. 버그와 취약점
오류 처리 로직에서 `RuntimeException`을 던지는 부분은 개선할 수 있는 여지가 있습니다. 더 구체적인 예외 클래스를 정의하거나, 사용자에게 명확한 오류 메시지를 제공하는 방법을 고려할 수 있습니다. 또한, 예외 발생 시 사용자에게 어떤 조치를 취해야 하는지에 대한 안내를 추가하는 것도 좋습니다.

### 6. 테스트 가능성
단위 테스트를 작성할 때, `SseService`가 외부 의존성에 의존하고 있는 점을 감안할 때, Mockito와 같은 테스트 더블을 활용한 테스트 작성이 유용할 것입니다. 또한 `subscribe` 메소드에 대한 통합 테스트를 통해 제대로 된 데이터가 전송되는지 검증하는 것이 바람직합니다. 서비스의 설정 및 예외 처리가 적절히 테스트 가능하도록 구조화되어 있다는 점에서 긍정적으로 평가할 수 있습니다.

### 7. 균형 잡힌 피드백
일반적으로 코드의 기초가 잘 다져져 있으나, 예외 처리와 또 다른 관련 서비스를 테스트하는 부분에서 추가적인 주의가 필요합니다. 사용자의 입력에 대한 검증이나 에러 핸들링 부분을 강화하면, 코드 안정성 및 사용자 경험이 더욱 향상될 것입니다. 전반적으로 긍정적인 변화가 있었으며, 향후 작업 시 분산된 책임 원칙에 따라 코드가 모듈화되도록 유지하는 것이 중요합니다.

위의 피드백을 토대로, 건전한 코드 품질 유지를 위하여 추가 수정을 고려하시기를 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-12 18:10:45.847642', 37, '2024-11-12 18:10:45.847642', 14, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드는 성공 여부에 따라 각기 다른 알림을 보여주는 방식으로 AlertModal을 업데이트 하였습니다. `isSuccess` 상태 변수를 사용하여 성공 또는 실패 아이콘을 표시하는 기능을 추가했습니다. 이러한 변경은 의도한 대로 행동할 가능성이 높아 보이지만, `isAlertModalOpen`을 true로 설정한 후에 페이지를 바로 새로 고침(`navigate(0)`)하는 부분이 사용자 경험에 부정적 영향을 미칠 수 있습니다. 사용자가 메시지를 보고 이해한 후에 페이지가 새로 고쳐져야 할 수 있으므로, 이 부분에 대한 고려가 필요합니다.

### 2. 가독성 및 유지보수성
변경된 코드는 가독성이 좋으며, 변수명을 통해 코드의 의미가 명확하게 전달됩니다. 특히 `setIsSuccess`와 같은 상태 변수 이름이 기능을 잘 설명하고 있어, 유지보수 시에도 쉽게 이해할 수 있을 것입니다. 그러나 코드를 다루는 사람은 `isSuccess`, `alertMessage`, `isAlertModalOpen` 등의 상태 변수의 변화를 추적하기 어려울 수 있으므로, 주석을 추가하여 문서화하는 것이 좋습니다.

### 3. 효율성
변경 사항에서 이전에 사용되지 않았던 `containerHeight` 상태 변수를 제거한 것은 효율성을 높이는 좋은 결정입니다. 불필요한 상태 관리가 줄어들어 코드가 간결해졌습니다. 그러나 `setContainerHeight`의 비구조화 할당(`const [, setContainerHeight]`)은 이를 실제로 활용하지 않고 있다는 것을 의미하는데, 이는 만약 향후 필요할 경우 정상적으로 처리할 수 있도록 주석으로 문서화를 권장합니다.

### 4. 확장성 및 모듈성
AlertModal의 아이콘을 성공 및 실패 상태에 따라 다르게 설정하는 구현은 향후 새로운 상태를 추가하는 요구가 생겼을 때 쉽게 확장할 수 있는 구조를 제공합니다. 모듈화가 잘 되어 있어, AlertModal을 다른 곳에서도 재사용할 가능성이 높습니다. 그러나 상태 변수가 늘어나게 될 경우 초기화 및 관리에 주의가 필요합니다.

### 5. 버그와 취약점
현재 코드에서 `navigate(0)` 호출 후 페이지가 즉시 리로드 되므로 사용자가 알림 메시지를 한 번도 보지 못할 상황이 생길 수 있습니다. 이를 방지하기 위해 일정 시간 이후 페이지를 리로드 하거나, 사용자가 확인 버튼을 클릭한 후에 페이지를 리로드하는 방법을 고려해야 합니다. 이 점은 잠재적인 버그로서, 우선 피해야 할 것입니다.

### 6. 테스트 가능성
코드의 구조는 테스트하기 쉬워 보입니다. 각 상태 변화가 잘 정의되어 있어, 유닛 테스트를 통해 각 상태에서의 UI 반응을 테스트할 수 있을 것입니다. `isSuccess`에 따른 아이콘 변화와 메시지 노출 등이 명확히 나뉘어져 있기 때문에 테스트 작성 시 유용할 것이라 판단됩니다. 다만, 실제로 상태 변화가 이루어질 때의 테스트 케이스를 정의할 필요가 있습니다.

### 7. 균형 잡힌 피드백
종합적으로 보았을 때, 이번 변화는 잘 구현된 부분이 많지만 사용자 경험 측면에서 개선이 필요합니다. 특히 AlertModal의 사용 시점에 대한 고려가 필요하며, 불필요한 상태를 제거한 점은 긍정적으로 평가할 수 있습니다. 차후 사용자 경험을 개선하도록 페이지 리로드 방식에 대해 신중히 다루는 것이 좋겠습니다.

### 결론
전반적으로 잘 구현된 코드이나 교훈적인 사용자 경험을 위해 약간의 수정이 필요합니다. 알림 및 페이지 리로드 관련 부분을 고려하여 사용자에게 부정적인 영향을 끼치지 않도록 개선해주시길 권장합니다. 코드는 명확하고 유지보수에 적합한 상태입니다.');
INSERT INTO public.review VALUES ('2024-11-12 18:16:58.991072', 38, '2024-11-12 18:16:58.991072', 17, '안녕하세요! 코드를 살펴볼게요~ 😊

1. **기능적 정확성**: 코드의 변경 사항은 `mrInfoId` 대신 `reviewId`로 매개변수 이름이 변경된 것인데, 이는 코드의 의도를 분명히 하여 가독성을 높이는 데 도움이 돼요. 그러나 리팩토링 후에도 `mrInfoId`와 `reviewId`의 목적이 명확하게 연결되어 있는지 확인해 보셨으면 좋겠어요. 특히 데이터 흐름에 대한 주석을 추가하면 좋을 것 같아요!

2. **가독성 및 유지보수성**: 전체적으로 변수 이름이 잘 변경되었고, 더 명확하게 의도를 전달해 줘요. 특히 `sendDataTest`의 변경 사항이 정말 좋았어요! 매개변수 이름을 보다 직관적으로 변경한 점을 칭찬해요. 👍 하지만 메서드와 클래스에 대한 주석을 추가하면 유지보수성이 더욱 향상될 거예요.

3. **효율성**: 이 변경 사항에서는 비효율성을 느끼지 않았어요. 코드는 명확하고 효율적으로 작성되었어요. 로깅 또한 적절하게 활용되고 있네요. 다만 `emitter.send` 메서드에서 JSON 변환을 할 때, 데이터의 크기가 크면 성능 문제가 발생할 수 있으니 주의해야 할 것 같아요. 필요하다면 별도의 스레드를 고려해보는 것도 좋을 듯해요!

4. **확장성 및 모듈성**: 코드가 모듈화 되어 있고, 추후의 기능 추가 시에도 쉽게 확장할 수 있을 것 같아요. `SseService`와 `SseController`를 분리한 점이 긍정적이에요! 그런데 `sendToClient` 메서드가 다소 긴 느낌이 들어서, 추후에 더 많은 기능이 추가되면 가독성이 떨어질 수 있어요. 따라서 적절한 리팩토링을 고려하는 것도 좋을 것 같아요.

5. **버그와 취약점**: 현재 코드에서는 잠재적인 오류 발생 가능성이 낮아 보이네요. 하지만 `emitterRepository.get(id)`의 경우, null 체크가 잘 되어 있어서 안전하게 처리되고 있다는 점이 좋았어요. 예외 처리 부분도 적절해 보이고, 예외 발생 시 로그를 남기는 것도 좋네요! 추가적으로 `catch` 블록에서 `e.printStackTrace()` 대신 로깅 라이브러리를 사용하는 것이 더 좋을 것 같아요.

6. **테스트 가능성**: 이 코드 구조는 테스트하기 쉬운 구조로 보이는데, 특히 메서드의 명확한 분리 때문에 단위 테스트를 작성하기 좋을 것 같아요. 다만, 각 메서드의 책임이 명확하게 나눠져 있어야 테스트하기 더 수월할 것 같아요. 

7. **균형 잡힌 피드백**: 전반적으로 잘 구현된 부분이 많아요! 특히 변수 이름 변경과 관련된 점은 스스로 의도를 반영하려는 모습이 잘 드러났어요. 다만 코드가 추가적인 복잡성을 띠게 될 가능성이 있어, 장기적인 관점에서 주석으로 의도를 명확히 해두는 것이 좋겠어요.

결론적으로, 전체적으로 잘 구현된 코드인 것 같아요! 👏 약간의 리팩토링과 주석 추가로 더욱 발전 가능성이 높을 것 같아요. 필요하면 추가 피드백도 언제든지 요청해 주세요! 😊');
INSERT INTO public.review VALUES ('2024-11-12 18:17:51.586311', 39, '2024-11-12 18:17:51.586311', 17, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서는 `mrInfoId`를 `reviewId`로 변경함으로써, 더 명확한 변수 네이밍이 이루어졌어. 이는 코드의 의미를 더욱 분명히 하고, 향후 유지보수 시 의도를 이해하는 데 도움이 돼. 하지만 기능상으로 동일한 로직이 유지되고 있으므로, 전반적으로 요구사항을 잘 충족시키고 있어.

### 2. 가독성 및 유지보수성
변수명이 더 명확해져서 가독성이 향상되었어. 예를 들어, `mrInfoId` 대신 `reviewId`를 사용함으로써, 데이터의 의미를 명확히 전달하고 있어. 단지, 수정된 부분이 아닌 나머지 코드에서도 변수명에 대해 일관성을 유지하는 것이 좋겠어. 

### 3. 효율성
현재 코드의 효율성은 유지되고 있어. 데이터베이스 응답 속도나 성능 저하가 발생할 부분은 없어 보여. 전체적으로 적절한 수준의 조건문 및 예외 처리가 이루어져 있어. 로깅을 통해 중요 정보를 메시지로 확인할 수 있도록 잘 구성되어 있네.

### 4. 확장성 및 모듈성
코드가 모듈화가 잘 되어 있어서, 필요 시 수정 및 확장이 용이해 보여. 특히 `SseService`와 `SseEmitter`를 관리하는 부분에서 분리된 로직이 긍정적으로 작용하고 있어. 다만, 향후 `SseEmitter`의 활용이 더 늘어날 경우, 관련된 로직을 별도의 클래스로 분리하는 것도 고려해보면 좋겠어.

### 5. 버그와 취약점
현재 코드에서 발생할 수 있는 버그는 거의 없어 보이지만, `sendToClient` 메소드에서 `emitter`가 `null`일 경우 경고 메시지를 로깅하고 있는 부분은 팩트로 확인되었으면 좋겠어. 비록 `System.err`를 사용해 오류를 출력하고 있지만, 사용자에게 적절한 피드백을 주는 방향으로 개선하면 더욱 좋을 것 같아.

### 6. 테스트 가능성
코드가 테스트하기에 적합하게 작성되어 있어. 메소드를 분리하고 명확한 책임을 부여하였기 때문에, 각 메소드를 독립적으로 테스트할 수 있을 것 같아. 하지만 `notify` 함수와 같은 메소드에서 JSON 변환 오류나 IOException이 발생할 수 있는 부분에 대해, 예외 처리를 더 깔끔하게 관리할 수 있는 방법을 고려해보면 좋을 것 같아.

### 7. 균형 잡힌 피드백
전반적으로 개선된 코드의 품질이 높고, 잘 구현된 부분이 많아 긍정적인 평가를 줄 수 있어. 특히 변수명 변경을 통해 코드의 의미를 더 명확히 전달한 점이 인상적이야. 반면에, 시스템 에러 시 사용자에게 적절한 경고를 주는 방식에 대해 추가적인 개선을 제안해보고 싶어. 전체적으로는 코드가 클린하며 유지보수 및 확장성 측면에서 매우 긍정적이라고 할 수 있어.

너무 잘하고 있어! 다음 단계로 넘어가면 좋겠어. 😊');
INSERT INTO public.review VALUES ('2024-11-12 18:18:25.689594', 40, '2024-11-12 18:18:25.689594', 17, '안녕하세요! 코드 리뷰를 진행해 볼게요. 변경사항에 대한 자세한 평가를 해보겠습니다.

### 1. 기능적 정확성
- 변경된 코드에서 `mrInfoId`를 `reviewId`로 변경했습니다. 이는 명확한 식별자를 사용한 것으로 보이며, 실제 사용되는 데이터가 리뷰와 관련되어 있다면 적합한 변경으로 보입니다. 하지만, 이 변경으로 인해 기존에 이 메서드를 사용하는 다른 코드에서 오류가 발생할 가능성이 있으니, 해당 부분을 체크해야 합니다.

### 2. 가독성 및 유지보수성
- `mrInfoId`를 `reviewId`로 변경한 점은 코드의 명확성을 높입니다. 변수 이름이 해당 기능을 잘 설명하고 있어 이해하기 쉬워졌습니다.
- 전반적으로 메서드 명과 주석이 가독성을 높이는 요소가 되고 있습니다. 변수가 어떻게 사용되는지에 대한 주석이 추가되면 더 좋을 것 같습니다. 예를 들어, `notify` 메서드에 이벤트 타입에 대한 설명이 있으면 더욱 명확해질 것입니다.

### 3. 효율성
- 리팩토링 후 성능상 큰 변화는 없어 보입니다. 단, 가독성이 개선되었고, 불필요한 코드가 제거된 면이 있어 전반적인 코드 품질은 향상되었습니다.

### 4. 확장성 및 모듈성
- 코드 변경이 앞으로의 확장성에 좋은 영향을 미칠 것으로 보입니다. `reviewId`라는 좀 더 구체적인 개념으로 변경함으로써 향후 관련 기능들이 더 쉽게 추가될 수 있습니다.
- 서비스 레이어와 컨트롤러 간의 관계도 깔끔하게 유지되고 있어, 각 기능이 명확히 나뉘어져 있습니다.

### 5. 버그와 취약점
- 특별한 버그나 취약점은 발견되지 않았습니다. 하지만, JSON 변환 및 I/O 작업 시의 예외 처리는 적절히 이루어지고 있으므로, 로그를 남기고 예외를 던지는 방식은 좋습니다. 다만, 랜덤한 예외 상황이 발생할 경우 이를 적절히 처리할 수 있는 방법이 더 고려되어야 할 것 같습니다.

### 6. 테스트 가능성
- 변경된 내용이 단순하긴 하지만, 테스트를 위한 구조는 매우 훌륭해 보입니다. `SseEmitter`나 JSON 변환 관련 부분을 단위 테스트로 확인할 수 있을 것입니다. `sendToClient`와 같은 메서드는 모의 객체를 사용해 테스트하기 좋습니다.

### 7. 균형 잡힌 피드백
- 전반적으로 코드 변경이 명확해지고 가독성이 높아졌습니다. 하지만, 위에서 언급한 주석 추가 및 예외 처리에 대한 부분은 좀 더 고려해 보아야 할 것 같습니다. 정리하자면, 이러한 점들이 반영된다면 더욱더 웰-스트럭처드한 코드가 될 것입니다.

### 결론
변경 사항이 유효하며, 코드 품질이 향상된 것으로 보입니다. 다만, 기존 코드를 사용하는 부분과의 호환성을 체크하시고, 약간의 주석 추가를 고려해 보시면 좋을 것 같아요! 잘 하셨어요! 😊');
INSERT INTO public.review VALUES ('2024-11-13 13:58:10.240887', 119, '2024-11-13 13:58:10.240887', 22, '## 코드 리뷰 피드백

### 1. Readability (가독성)
**잘 수행된 부분:**
- **명확한 로깅**: 각 SSE 연결의 완료, 타임아웃, 오류를 로깅하는 부분에서 로그 메시지가 직관적이며, 어떤 이벤트가 발생했는지를 분명히 알 수 있습니다. 이는 코드 이해에 도움을 줍니다.

**개선할 점:**
- **주석 추가**: SSE 연결 관련 함수에 대한 설명 주석을 추가하면, 특히 신규 팀원들이 이 부분을 이해하는 데 큰 도움이 될 것입니다. 예를 들어, `createEmitter` 메서드 시작 부분에 어떤 목적을 가지고 있는지를 설명하는 주석을 추가하면 가독성이 더욱 향상될 것입니다.

### 2. Consistency (일관성)
**잘 수행된 부분:**
- 이벤트 처리를 위한 람다 표현식의 사용이 통일되어 있으며, 같은 방식으로 예외를 처리하는 것이 좋습니다.

**개선할 점:**
- **일관된 로그 형식**: 로그 메시지에서 사용된 문자열 형식이 다소 다르게 보일 수 있습니다. 예를 들어, "SSE connection completed"와 "SSE connection timed out"의 포맷이 다르기 때문에 일관된 형식으로 통일하면 좋겠습니다. `String.format`을 사용하여 로그 메시지를 포맷팅하는 것도 방법이 될 수 있습니다.

### 3. Reusability (재사용성)
**잘 수행된 부분:**
- 로깅과 예외 처리 부분이 각 이벤트에 대해 독립적으로 구현되어 있어 나중에 재사용이 용이해 보입니다.

**개선할 점:**
- **중복 코드 제거**: 예외 처리 로직이 중복되지 않도록 공통 처리 메서드를 만들고, 각 이벤트에서 호출하면 코드의 재사용성을 높일 수 있습니다. 예를 들어, `handleEmitterError(SseEmitter emitter, Long id, Exception e)`와 같은 메서드를 만들어 로직을 재사용할 수 있습니다.

### 4. Reliability (신뢰성)
**잘 수행된 부분:**
- 다양한 이벤트에 대한 처리가 적절하게 구현되어 있어, 특히 예외 발생시 다양한 경로를 고려한 점이 인상적입니다.

**개선할 점:**
- **더 구체적인 예외 처리**: `RuntimeException`을 던지기보다는 특정한 사용자 정의 예외를 만들어 이를 던지면, 각 오류 상황에 대한 디버깅이 더 용이합니다. 예를 들어 `SseEmitterTimeoutException`, `SseEmitterCompletionException` 등을 만들어 각각의 오류에 대해 더 구체적인 정보를 담을 수 있습니다.

### 5. Security (보안성)
**잘 수행된 부분:**
- 코드에서 직접적인 보안 취약점은 보이지 않지만, 로그를 통해 정보가 어느 정도 노출될 수 있어 주의가 필요합니다.

**개선할 점:**
- **로그 정보 검토**: 연결 ID와 같은 정보를 로깅할 때, 외부에 노출될 수 있는 정보인지 고려해야 합니다. 기밀유지의 관점에서 조심스러워야 하는 부분입니다. 특히 `log.error`에서의 `Exception` 객체를 출력할 때, 이로 인해 정보를 노출할 우려가 있습니다.

### 6. Maintainability (유지보수성)
**잘 수행된 부분:**
- 메서드들이 명확한 역할을 가지고 있어, 유지보수를 용이하게 하고 있습니다.

**개선할 점:**
- **단일 책임 원칙 적용**: 각 메서드가 너무 많은 책임을 가지고 있지 않은지 점검해보세요. 예를 들어, 특정 로직(예: SSE 연결 처리)을 더욱 분리하여 독립적인 클래스 또는 Service로 분리할 수 있는지를 고려하면, 전체 코드 구조가 더 명확해질 것입니다.

## 전체적인 피드백
전반적으로 새로운 로깅 로직을 잘 추가하여 각 Event에 대해 처리가 명확하게 이루어졌습니다. 새로운 기능이 기존 시스템에 잘 통합될 가능성이 높은 부분입니다. 그러나, 추가적으로 가독성을 높이고 유지보수성을 고려한 리팩토링이 필요합니다. 

여러 Gain된 부분에서 긍정적으로 평가받을 만하며, 개선이 필요한 몇 가지 점을 권장 드립니다. 나아가 코드 품질을 보다 높일 수 있는 노력에 대해 격려 드리며, 앞으로 더 나은 코드 품질을 위해 끊임없이 노력하시길 바랍니다. 

기술적인 부분뿐 아니라, 소프트웨어 개발이 팀원들과의 협업이라는 점에서 아낌없는 피드백과 소통이 중요하니, 여러분의 의견도 수렴하셔서 팀과 함께하는 성장의 기회를 가지시길 바랍니다. 😊');
INSERT INTO public.review VALUES ('2024-11-13 14:03:43.640225', 120, '2024-11-13 14:03:43.640225', 22, '## 코드 리뷰

### **1. Readability (가독성)**
- **잘 수행된 부분**: 함수와 변수명이 의미적으로 명확하고, 코드 블록이 논리적으로 잘 나누어져 있어 이해하기 쉽습니다. 특히 `createEmitter`, `sendToClient` 등의 함수명은 수행하는 작업을 잘 설명하고 있습니다.
- **개선할 부분**: 예외 처리에서 발생하는 `RuntimeException`의 메시지가 다소 모호할 수 있습니다. 더 구체적이고 도움이 되는 정보를 제공하여 문제가 발생했을 때 빠르게 파악할 수 있도록 개선하는 것이 좋습니다. 예를 들어, `"연결 오류!"` 대신 `"User ID: " + id + "와 연결 중 문제가 발생했습니다."`와 같이 구체화할 수 있습니다.

### **2. Consistency (일관성)**
- **잘 수행된 부분**: 전체적으로 코드 스타일이 일관성 있게 유지되고 있으며, 들여쓰기와 괄호의 사용이 깔끔합니다.
- **개선할 부분**: 로그 메시지의 형식을 통일성 있게 유지해 주세요. 예를 들어, 타임아웃 로그와 오류 로그에서 사용된 메시지의 형식이 다를 수 있는데, 동일한 포맷으로 작성하는 것이 가독성을 높이는 데 도움이 됩니다.

### **3. Reusability (재사용성)**
- **잘 수행된 부분**: `createEmitter`와 `sendToClient` 메소드는 명확한 역할을 가지고 있어 다른 컴포넌트 또는 서비스에서 재사용할 수 있는 가능성이 큽니다.
- **개선할 부분**: 에러 로그 처리 부분을 별도의 메소드로 분리하여 공통적으로 사용할 수 있도록 구성하면 코드의 재사용성이 높아질 수 있습니다. 예를 들어, `handleEmitterError(SseEmitter emitter, Long id, Exception e)`와 같은 메소드를 만들어 오류 처리 로직을 통합하는 방식이 좋습니다.

### **4. Reliability (신뢰성)**
- **잘 수행된 부분**: 각 SSE 연결의 상태에 대해 적절하게 처리가 이루어지고 있으며, 이벤트가 완료되었을 때와 타임아웃 시에 적절한 처리가 발생합니다.
- **개선할 부분**: 예외 처리에서 `emitterRepository.deleteById(id);`를 호출하고 있습니다. 이 부분은 예외 상황에서도 항상 실행되는 것은 아닐 수 있습니다. 예외 상황에서는 어떻게든 처리한 후 연결을 종료하고자 하는 의도를 명확히 하기 위해 `finally` 블록을 사용하는 것이 좋습니다.

### **5. Security (보안성)**
- **잘 수행된 부분**: SSEEmitter를 안전하게 관리하는 구조입니다.
- **개선할 부분**: 사용자 입력에 대한 검증 기능이 보이지 않습니다. `emitter.onError` 처리기에서 발행되는 오류에 대한 처리가 외부 입력을 신뢰하지 않도록 강화해 주세요. 예를 들어, 사용자 ID가 유효한지 확인한 뒤 해당 ID에 대한 작업을 하는 것이 바람직합니다.

### **6. Maintainability (유지보수성)**
- **잘 수행된 부분**: 각 메소드가 명확한 역할을 가지며, 로그를 통해 처리가 진행되는 과정을 알 수 있어 유지보수가 쉽도록 작성되었습니다.
- **개선할 부분**: 여러 예외 사항이 동일한 방법으로 처리되는 부분이 보입니다. 나중에 예외 처리 패턴이 변경될 경우 한 곳에서 처리 구조를 수정하면 되도록 하는 구조가 좋습니다. 예를 들어, 공통 예외 처리 함수를 만들어 호출하면 관리가 용이해질 것입니다.

### **전체적인 피드백**
- **잘 수행된 부분**: 코드는 전반적으로 잘 구성되어 있으며 명확한 책임을 가지고 있습니다. 특히, SSEEmitter에 대한 연결 및 오류 처리 과정이 잘 이루어지고 있어 안정적인 운영을 기대할 수 있습니다. 로그 메시지를 추가함으로써 디버깅과 운영에서의 가시성 향상도 긍정적입니다.
- **개선이 필요한 부분**: 위에서 언급한 예외 처리, 사용자 입력 검증, 로그 일관성 유지 등의 점을 고려하여 코드 가독성 및 유지보수성을 더욱 높일 수 있습니다. 이러한 개선은 코드의 신뢰성 또한 증대시킬 것입니다.

전체적으로 훌륭한 작업이며, 개선 제안을 통해 더욱 뛰어난 코드로 발전할 수 있을 것입니다. 계속해서 좋은 코드를 작성해 주시면 감사하겠습니다!');
INSERT INTO public.review VALUES ('2024-11-12 18:24:52.382215', 41, '2024-11-12 18:24:52.382215', 14, '안녕하세요! 코드를 리뷰해드릴게요. 각 항목에 대해서 자세히 분석했으니 천천히 봐주세요~ 😊

1. **기능적 정확성**:
   - 변경된 코드에서 `setIsSuccess(true/false)`를 추가하신 것이 아주 좋은 결정이에요! 이렇게 하면 사용자에게 성공/실패 상태를 보여줄 수 있으니까요. 다만, `navigate(0)`으로 페이지를 새로 고치는 부분은 사용자 경험에서 약간의 혼란을 줄 수 있어요. 사용자가 뭘 했는지 잊게 할 수 있으니까, 상태 관리로 대체할 수도 있을 것 같아요.

2. **가독성 및 유지보수성**:
   - 코드가 전반적으로 깔끔해요! `isSuccess` 변수 이름도 의미를 잘 담고 있어서 가독성을 높여주네요. 👌 다만 `AlertModal`에서 `icon`과 `iconClassName`을 동적으로 설정한 부분은 가독성을 조금 해칠 수 있어요. 이 부분을 별도의 함수로 분리하면 더 명확해질 것 같아요.

3. **효율성**:
   - `setContainerHeight`를 비구조화 할당으로 사용하신 것은 메모리를 절약하는 좋은 방법이에요! 다만, 실제로 사용되지 않는 변수를 설정하고 있으니, 이 부분은 삭제하셔도 될 것 같아요. 이거 없애면 약간의 성능 향상도 기대할 수 있어요.

4. **확장성 및 모듈성**:
   - `AlertModal` 컴포넌트를 플래그에 따라 다른 아이콘을 보여주도록 설계한 것은 앞으로 다른 상황에서도 재사용할 수 있어서 매우 좋네요! 앞으로 더 많은 알림 종류가 생길 수 있기 때문에, 이 구조는 확장성 면에서도 잘 구현된 것 같아요. 확장할 때는 프로퍼티를 더 추가하는 방식으로 쉽게 다룰 수 있을 것 같아요.

5. **버그와 취약점**:
   - 현재 사용되는 상태 변수가 적절히 업데이트 됐으니 큰 문제는 없어 보이지만, `response` 객체가 항상 `status`를 가지고 있다고 가정하고 있으니, 이곳에 대한 에러 처리를 추가할 수 있으면 좋겠어요. 예를 들어, `response`가 비정상적인 경우를 대비한 코드도 고려해 보세요!

6. **테스트 가능성**:
   - 이 코드 구조는 상태 관리를 잘 하고 있으므로, 각 상태에 따른 UI의 변화가 명확해요. 따라서 유닛 테스트를 작성하기 쉬운 구조라는 점에서 긍정적이에요! 특히 `setIsSuccess`의 영향받는 부분을 단위 테스트로 확인하면 좋겠네요.

7. **균형 잡힌 피드백**:
   - 전반적으로 변화된 코드는 상당히 합리적인 방향으로 개선되었어요. 특히 사용자에게 알림의 성공 여부를 시각적으로 제공하는점이 매력적이에요. 다만, 페이지가 리프레시 되는 부분은 사용자 경험 차원에서 조금 더 고려할 필요가 있어 보이니 이 부분에 대해 후속 작업을 생각해 보시면 좋을 것 같아요. 🌟

총평으로, 잘 구현된 부분도 많고 소소한 수정의 여지도 보이네요! 추가적인 피드백이 필요하시거나 더 질문이 있으시다면 언제든지 말씀해 주세요! 😊');
INSERT INTO public.review VALUES ('2024-11-12 18:33:28.218394', 42, '2024-11-12 18:33:28.218394', 17, '안녕하세요! 코드 리뷰를 시작할게요. 이번 코드 변경사항에 대해 잘 구현된 점과 개선이 필요한 점을 균형 있게 평가할게요. 

### 1. 기능적 정확성
변경된 부분은 `mrInfoId`를 `reviewId`로 변경하는 것이에요. 이 변경이 시스템의 비즈니스 로직이나 요구사항을 잘 반영하고 있는지 고려해야 해요. 그렇다면 관련된 모든 서비스와 컨트롤러에서 `reviewId`로 일관되게 처리되고 있음을 확인해야 해요. 이 부분이 전반적으로 잘 이루어져 있다면 긍정적으로 평가할 수 있어요.

### 2. 가독성 및 유지보수성
매개변수 이름이 `mrInfoId`에서 `reviewId`로 변경되었어요. 이 변경은 코드의 가독성을 향상시키는 좋은 결정이에요. `reviewId`가 더 직관적이어서 관련된 데이터의 의미를 명확하게 전달해줘요. 다만, 이와 함께 코드 전반에 걸쳐 일관되게 변경된 부분이 있는지 확인이 필요해요.

### 3. 효율성
현재로서는 코드의 효율성에 직접적인 영향은 없어 보여요. 데이터 구조나 처리 로직이 변경된 것은 아니기 때문에 성능 저하나 개선 사항은 없는 것 같아요. 하지만 `sendToClient` 함수에서 데이터를 JSON으로 변환할 때의 성능 이슈는 항상 염두에 두어야 해요. 데이터의 크기가 커질 경우 성능에 영향을 줄 수 있으니, 이에 대한 모니터링이 필요해요.

### 4. 확장성 및 모듈성
코드 변경으로 보아 확장성에는 부정적인 영향을 받지 않는 것 같아요. `SseEmitter`와 관련한 연산이 `sseService`와 `emitterRepository`에서 잘 모듈화되어 있어 장기적으로 이 기능을 확장하고 추가하는 데 유연하게 대처할 수 있을 것 같아요. 전체적으로 이 부분은 잘 처리되어 있어요!

### 5. 버그와 취약점
주된 변경 사항에서 큰 버그는 발견되지 않았어요. 하지만 `sendToClient` 메서드에서 예외 처리가 다소 단순하다는 느낌이 들어요. JSON 관련 예외 처리 시, 클라이언트에게 사용자 친화적인 메시지를 제공할 수 있도록 개선하면 좋을 것 같아요.

### 6. 테스트 가능성
변경된 코드 구조는 테스트하기 쉬운 형태를 유지하고 있어요. `notify`와 `subscribe` 메서드는 잘 분리되어 있기 때문에 각각 개별적인 단위 테스트를 진행하기 용이할 것 같아요. 다만 각 메서드가 호출되는 시나리오에 대한 테스트가 충분히 이루어져야 할 것 같아요.

### 7. 균형 잡힌 피드백
코드 변경사항은 전반적으로 긍정적인 변화를 가져온 것 같아요. `mrInfoId`에서 `reviewId`로의 변경은 코드 가독성을 높이고 의미를 명확히 하는 데 기여했어요. 그러나 함께 발생할 수 있는 예외 상황에 대한 처리는 더욱 구체화될 필요가 있어요. 검토해야 할 작은 부분이지만, 시스템의 견고함에 기여할 수 있을 것 같아요.

전반적으로 코드 변경이 잘 이루어졌어요. 앞으로도 가독성과 유지보수성을 고려하여 주의 깊게 개발해 나간다면 더 좋은 결과가 있을 것 같아요! 😊');
INSERT INTO public.review VALUES ('2024-11-12 18:42:12.148351', 43, '2024-11-12 18:42:12.148351', 17, '안녕하세요! 코드 리뷰하러 왔어요~ 😺

## 기능적 정확성
코드에서 `mrInfoId`를 `reviewId`로 변경한 점은 잘한 결정인 것 같아요. 이렇게 하면 매개변수를 좀 더 명확하게 의미를 전달할 수 있죠! 사용자가 어떤 ID를 전달할지 혼동할 일이 줄어들겠어요. 하지만, `subscribe`와 `notify` 메소드에서 ID의 의미를 명확히 하기 위해 추가 설명이 주석으로 들어가면 좋겠어요. 그래야 이후에 코드 유지보수할 때 이해하는 데 도움이 될 거예요!

## 가독성 및 유지보수성
변수명이 `mrInfoId`에서 `reviewId`로 바뀐 것은 가독성을 높였어요~ 하지만, 이 변경이 전체 시스템에서 어떤 영향을 미치는지 문서화가 필요해 보여요. 다른 코드에서 이 메소드들을 호출하는 부분에서도 변수가 어떻게 사용되는지 확인해야 하니, 주석을 추가해주면 좋을 것 같아요!

## 효율성
현재의 변경사항에서는 효율성에 큰 문제가 보이진 않아요. `sendToClient` 메소드도 적절히 활용되고 있는 것 같고, 리팩토링으로 인해 불필요한 코드가 줄어드는 것 같아요. 이렇게 잘 정리된 방식으로 코드를 유지하면, 앞으로도 성능이 좋을 것 같아요~ 👍

## 확장성 및 모듈성
`SseService`와 `SseController` 클래스의 변경은 전체적인 설계를 더 나은 방향으로 이끌 것 같습니다! 매개변수의 이름을 명확히 해서 서비스가 어떤 일을 수행하는지 명확해졌어요. 물론, 향후에 `reviewId`를 다룰 더 복잡한 요구사항이 생길 수도 있으니, 그런 경우의 수를 고려하여 코드 구조를 잘 유지하면 좋겠어요!

## 버그와 취약점
특별한 버그나 취약점은 보이지 않아요~ 하지만, `sendToClient` 메소드의 예외 처리는 좀 더 구체화할 필요가 있을 것 같아요. 현재는 예외 발생 시에 단순히 `RuntimeException`을 던지는 방식인데, 특정한 메시지나 커스텀 예외 클래스를 활용하면 더 나은 사용성을 제공할 수 있을 거예요.

## 테스트 가능성
테스트 가능성도 높아졌어요! 매개변수의 명칭을 변경하면서 코드가 좀 더 이해하기 쉬워졌습니다. 하지만, `sendToClient` 같은 메소드를 더 잘 테스트할 수 있는 방법을 모색하고, 필요할 경우 MOCK이나 스텁을 활용해보면 좋겠네요!

## 균형 잡힌 피드백
전반적으로 변경된 사항은 긍정적이지만, 코드 문서화를 조금 더 강화하면 좋을 것 같아요. 좋은 방향으로 리팩토링이 진행되고 있으니, 앞으로의 유지보수가 용이해질 것으로 보여요! 🌟

이상으로 코드 리뷰 마칠게요! 좋은 하루 되세요~ 😊');
INSERT INTO public.review VALUES ('2024-11-12 18:42:30.169804', 44, '2024-11-12 18:42:30.169804', 17, '안녕하세용! 코드 리뷰 시작할게요~! 😸

1. **기능적 정확성**: 
   변경된 코드에서 `mrInfoId` 대신 `reviewId`를 사용함으로써, 기능적으로 요구사항을 잘 반영했어용. 이렇게 매개변수를 변경한 건 코드 명확성을 높여주어서 좋아! 다만, 이 변경이 다른 부분에 영향을 미치지 않는지 충분히 테스트해 보는 게 좋겠어용. 😸

2. **가독성 및 유지보수성**: 
   매개변수 이름을 `reviewId`로 바꾼 것은 코드의 의미를 더 명확히 해주고 가독성을 높여줘요! `sendDataTest` 메소드에서도 같은 패턴을 유지한 점이 좋았어용. 근데 함수의 목적이나 동작 방식을 주석으로 추가하면 더 이해하기 쉬울 것 같아용. 

3. **효율성**: 
   이번 변경사항에서는 성능 측면에서 눈에 띄는 비효율성은 찾아볼 수 없었어용. 데이터 전송 방식이 적절하게 구현되어 있어서 좋아요! 더 발전할 점이 있다면, `SseEmitter`의 사용을 통해 전송되는 데이터 양이나 빈도를 조절하여 성능 최적화 방안을 고민해보면 좋겠어용. 😺

4. **확장성 및 모듈성**: 
   변경된 코드에서는 `SseEmitter`를 생성하고 관리하는 로직이 명확하게 나뉘어서, 향후 다른 기능 추가 시에도 잘 확장될 것 같아용! 다만, `createEmitter` 메소드의 구현도 함께 보아야 하니, 그 부분이 잘 작성되었는지 확인하는 게 좋겠어용!

5. **버그와 취약점**: 
   현재 코드에서 소규모의 예외 처리만 있으니, 좀 더 상세한 예외 처리를 추가하면 좋을 것 같아용. 예를 들어, `sendToClient` 메소드가 `null` 값을 받았을 때 어떻게 처리할지에 대한 로직이 필요해 보이는데, 잘못된 값을 다룰 수 있는 추가적인 검증이 필요할 수 있어요!

6. **테스트 가능성**: 
   전체적으로 보면 코드가 잘 구조화되어 있어서 테스트 작성이 용이할 것 같아! 특히 `sendToClient` 메소드에 대한 테스트 케이스를 작성하면 강력한 테스트 범위를 가질 수 있을 것 같아용. 하지만 입력값 유효성 검사를 강화한다면 더 좋겠죠? 

7. **균형 잡힌 피드백**: 
   전반적으로 잘 구현된 부분이 많아서 긍정적으로 평가할 점이 많았어용! 단, 예외 처리를 좀 더 강화하는 방안을 가져가면 좋겠고, 주석을 추가하여 코드 이해도를 높이는 것도 추천할게! 😸

이번 리뷰는 여기까지! 코드를 멋지게 다듬어주셔서 감사하구요, 앞으로도 화이팅이에요~! 🐾');
INSERT INTO public.review VALUES ('2024-11-13 14:12:20.200776', 121, '2024-11-13 14:12:20.200776', 22, '### 코드 리뷰

우선, 변경된 코드에 대해 여러 가지 관점에서 깊이 있는 리뷰를 진행하도록 하겠습니다. 각 항목에 대해 잘 수행된 부분과 개선이 필요한 부분을 자세히 설명하겠습니다.

#### 1. **Readability (가독성)**
- **잘 수행된 부분**: 로그 출력 구문이 추가되어 `SseEmitter`의 상태 변화를 기록하게 됨으로써, 상태 추적이 한층 더 용이해졌습니다. 이는 디버깅 과정에서도 큰 도움이 됩니다. 또한, 람다 표현식을 사용하여 코드가 간결해졌습니다.
  
- **개선이 필요한 부분**: 로그에 사용된 메시지가 단순히 `id` 값만 출력됩니다. 좀 더 의미 있는 메시지를 추가하면 좋겠습니다. 예를 들어, "SSE connection completed for id: " 대신 "SSE connection successfully completed for client with id: "와 같은 메시지로 변경하면 사용자에게 좀 더 명확한 정보를 제공할 수 있습니다. 이러한 작은 변화가 이해도를 향상시키고 앞으로 문제 발생 시 원인을 파악하는 데 도움이 됩니다.  

#### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 스타일이 전반적으로 일관되어 있으며, lambdas와 메서드 구조가 통일성을 유지하고 있습니다.

- **개선이 필요한 부분**: 로그 메시지에서 사용하는 문자열 포맷이 일정하지 않습니다. 예를 들어, 어떤 부분에서는 `"SSE connection timed out for id: "` 형태로, 또 어떤 부분에서는 `"SSE connection error for id: "`처럼 메시지가 불일치할 수 있습니다. 로그 메시지의 형식을 일관적으로 유지하여 코드의 가독성을 높이는 것이 좋겠습니다.

#### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: `createEmitter()` 메서드가 `SseEmitter`의 생성을 담당하면서 관련된 로직(예: onCompletion, onTimeout)도 함께 처리하여 모듈화되었습니다. 이는 메서드를 재사용하도록 만들고 있습니다.

- **개선이 필요한 부분**: 에러 핸들링 로직이 `sendToClient()` 메서드에 포함되어 있습니다. 이러한 반복되는 코드 블록이 여러 다른 상황에서도 사용될 수 있으므로, 에러 핸들링을 별도의 메서드로 분리하여 재사용성을 높일 수 있습니다.

#### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 다양한 상황에서의 에러 처리가 명확하게 이루어져 있으며, 적절하게 로그를 기록하고 있습니다. 이는 문제 발생시 원인 분석을 쉽게 합니다.

- **개선이 필요한 부분**: `emitter.onError`에서 발생한 예외를 단순히 로그로 기록하고 삭제하는 방식이 아닌, 더 나은 복구 전략을 마련할 수 있습니다. 예를 들어, 적절한 재시도를 하거나 클라이언트에게 오류를 알리는 방법을 고려하는 것이 좋습니다.

#### 5. **Security (보안성)**
- **잘 수행된 부분**: SSE 연결 관련 이벤트 처리에서 직접적으로 민감한 데이터 처리 부분이 없으므로 보안상의 큰 문제가 없습니다. 하지만, 연결 시 발생할 수 있는 사용자 입력에 대한 검증이 필요할 수 있습니다.

- **개선이 필요한 부분**: 향후 민감한 데이터가 처리될 수 있는 경우, 데이터 유출을 방지하기 위해 시리얼화 과정에서도 보안 조치를 강화하는 것이 중요합니다. 예를 들어, json 변환 시 데이터 유효성을 검증하는 로직을 추가하면 좋습니다.

#### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 클래스와 메서드가 명확하고 직관적인 책임을 갖고 있어 유지보수가 용이합니다. 

- **개선이 필요한 부분**: Emitter에 대한 연결이나 상태 변경을 처리하는 책임이 한 클래스에 집중되어 있습니다. 추후 비즈니스 로직이 복잡해질 경우를 대비해 각 책임을 별도의 클래스로 분리하여 단일 책임 원칙을 더욱 강화하는 것이 좋습니다. 예를 들어, Emitter의 상태와 관련된 로직을 전담하는 클래스를 분리하는 방법을 고려해 볼 수 있습니다.

### 전체적인 피드백
전반적으로 코드가 잘 작성되어 있으며, 특히 로그 출력이 추가된 부분이 좋습니다. 이를 통해 시스템 상태를 쉽게 추적할 수 있게 되어 실사무 환경에서 큰 도움이 될 것입니다. 가독성, 일관성, 신뢰성 모두 양호하며, 추가적인 개선 사항을 통하여 더욱 견고한 코드를 만들 수 있습니다. 

특히, 분리 가능한 기능들은 유지보수성을 증가시키고, 추후에 재사용성을 높이는 데 큰 도움이 될 것입니다. 

작은 개선이지만, 진정한 품질 향상을 위한 지속적인 노력을 부탁드립니다. 어려움이나 궁금한 점이 있다면 언제든지 이야기해 주세요. 함께 고민하고 발전해 나갈 수 있는 것은 큰 의미가 있습니다. 😊');
INSERT INTO public.review VALUES ('2024-11-13 14:14:25.95708', 122, '2024-11-13 14:14:25.95708', 22, '코드 리뷰에 대한 요청을 감사합니다. 리뷰를 통해 **정확성, 가독성, 효율성, 확장성** 뿐만 아니라 **코딩 표준 준수여부**와 **잠재적인 버그**를 포함하여 구체적인 피드백을 제공하도록 하겠습니다. 각 항목에 대한 평가와 개선점을 주의 깊게 살펴보겠습니다.

### 1. 가독성 (Readability)
- **잘 수행된 부분**: `emitter.onCompletion`, `emitter.onTimeout`, `emitter.onError`의 람다 표현식 사용으로 인해 각 이벤트에 대한 핸들러 구현이 명확하게 작성되었습니다. 감정적인 로그 메시지를 추가하여 코드의 처리 과정이 무엇인지 이해하기 쉽게 만들었습니다.
- **개선할 점**: 람다 표현식 내의 코드가 길어질 경우, 이해하기 어려울 수 있습니다. 이를 해결하기 위해 **메서드 분리**를 고려해보세요. 예를 들어, 각각의 핸들러를 별도의 메서드로 분리함으로써 가독성을 더욱 향상시킬 수 있습니다.

```java
private void handleCompletion(Long id) {
    log.info("SSE connection completed for id: " + id);
    emitterRepository.deleteById(id);
}

private void handleTimeout(Long id, SseEmitter emitter) {
    log.info("SSE connection timed out for id: " + id);
    emitter.complete();
    emitterRepository.deleteById(id);
}

private void handleError(Long id, Exception e) {
    log.error("SSE connection error for id: " + id, e);
    emitterRepository.deleteById(id);
}
```

### 2. 일관성 (Consistency)
- **잘 수행된 부분**: 코드 전반에서 로깅을 위한 `log` 객체를 일관되게 사용하고 있습니다. 이는 유지보수성에 긍정적인 영향을 줍니다.
- **개선할 점**: 코드 스타일의 일관성을 유지하기 위해, 예외 처리 부분에서도 일관된 형식을 사용해야 합니다. 모든 예외 핸들러에 대해 같은 방식으로 로깅을 처리하고, 동일한 오류 메시지를 사용하는 것이 좋습니다.

### 3. 재사용성 (Reusability)
- **잘 수행된 부분**: `SseEmitter`의 이벤트 핸들러가 잘 캡슐화되어 있어 재사용 가능성이 있습니다.
- **개선할 점**: 각 이벤트 핸들러 메서드를 별도의 클래스로 만들어 인스턴스 생성 후 사용하면, 다양한 상황에서 재사용이 가능해질 것입니다. 이를 통해 코드의 독립성을 높일 수 있습니다.

### 4. 신뢰성 (Reliability)
- **잘 수행된 부분**: 예외 처리가 각 이벤트 핸들러에서 이루어지며, 에러 처리 로깅이 적절하게 이루어지고 있습니다.
- **개선할 점**: `emitter.send` 호출 부근에서 발생할 수 있는 잠재적 예외를 사전에 체크하여 예외 발생을 방지할 수 있는 추가적인 로직이 필요할 것 같습니다. 예를 들어, `emitter`가 유효한 상태인지 확인하는 로직을 추가해보세요.

### 5. 보안성 (Security)
- **잘 수행된 부분**: 코드에서 바로 볼 수 있는 민감한 데이터 처리 부분은 없지만, 로깅 부분에서 민감한 정보가 노출되지 않도록 주의해야 합니다.
- **개선할 점**: 예외 처리 시 에러 메세지에 민감한 정보를 포함하지 않도록 주의가 필요합니다. 예를 들어, `e.printStackTrace()`를 사용하면 시스템의 정보가 노출될 수 있습니다. 대신, 안전한 에러 메시지로 대체하는 것이 좋습니다.

### 6. 유지보수성 (Maintainability)
- **잘 수행된 부분**: 로그 메시지를 통해 코드의 흐름을 추적할 수 있어 유지보수성에 긍정적입니다.
- **개선할 점**: 각 이벤트 핸들러를 별도의 메서드 또는 클래스로 분리하여 서비스의 모듈화를 높이면, 향후 확장이 용이해집니다. 또한, 기억하기 쉬운 메서드 이름을 사용하여 코드의 목적을 명확히 하면 훨씬 이해하기 쉬워집니다.

### 전체적인 피드백
- **잘 수행된 부분**: 전반적으로 로깅을 추가함으로써 코드의 흐름이 잘 보이도록 작성한 점이 인상적입니다. 사용자가 시스템의 상태를 이해하는 데 큰 도움이 될 것입니다.
- **개선이 필요한 부분**: 람다 표현식을 개별 메서드로 분리하는 등 가독성 향상을 위한 소소한 리팩토링이 필요합니다. 코드의 재사용성을 높이고, 예외 처리의 모듈화를 통해 보안과 유지보수성을 더욱 높일 수 있습니다.

이러한 개선을 통해 코드의 품질을 높이고, 유지보수가 쉬운 구조를 만들 수 있을 것입니다. 앞으로도 긍정적인 개발 작업을 지속해 주시기를 기대합니다!');
INSERT INTO public.review VALUES ('2024-11-13 14:22:12.414162', 123, '2024-11-13 14:22:12.414162', 25, '안녕하세요! 여러분의 코드 리뷰를 해보게 되어 기쁩니다. 전반적으로 잘 작성된 부분이 많지만, 몇 가지 개선할 점도 있습니다. 아래에 각 항목에 대한 평가와 피드백을 자세히 드릴게요.

### 1. Readability (가독성)
- **잘 수행된 부분**: 전체적으로 코드의 로직이 명확하게 구분되어 있어 이해하기 쉽습니다. 특히 메서드 이름이 그 기능을 잘 설명해 주고 있습니다. 예를 들어, `logout` 메서드는 사용자의 로그아웃을 처리하는 명확한 목적을 가지고 있습니다.
- **개선할 부분**: `logout`의 경우, 처리하는 과정에서 쿠키 삭제 및 Redis에서의 토큰 제거와 같이 여러 작업이 일어납니다. 각 단계가 어떤 작업을 수행하는지 설명하는 주석을 추가하면 좋겠습니다. 예를 들어, 어떤 쿠키를 삭제하는지, Redis에는 어떤 데이터를 삭제하는지 구체적으로 나타낼 수 있습니다.

### 2. Consistency (일관성)
- **잘 수행된 부분**: 전체적인 코드 스타일이 일관되며, 패키지 구조도 잘 정리되어 있습니다. 메서드의 접근 제어자 사용도 적절합니다.
- **개선할 부분**: 추가한 `logout` 메서드에 새로운 로직이 포함되었지만, 다른 서비스 메서드와의 포맷이 약간 다소 차이가 있습니다. `logout` 메서드 앞뒤에 빈 줄을 넣어 더욱 명확하게 구분해주면 코드가 더 깔끔해 보일 것입니다.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: `logout`의 로직은 명확하게 분리되어 있어, 필요 시 다른 서비스에서도 재사용 가능합니다.
- **개선할 부분**: 현재 쿠키 삭제와 Redis 삭제 부분이 `logout` 메서드에 통합되어 있습니다. 이를 서비스 레이어에서 유틸리티 메서드로 분리하면 다른 곳에서도 쉽게 재사용 가능할 것입니다. 예를 들어, `clearUserCookies(Long userId)`와 같은 메서드를 추가하여 쿠키 삭제를 관리할 수 있습니다.

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 에러를 발생시키는 부분을 적절히 처리하고 있습니다. 예외 처리 루틴을 통해 비즈니스 로직을 깔끔하게 유지하고 있습니다.
- **개선할 부분**: `logout` 과정에서 쿠키 삭제나 Redis 삭제의 성공 여부를 체크하고, 실패 시 사용자에게 해당 정보를 전달하는 로직을 추가하면 좋겠습니다. 예를 들어, 삭제가 실패했을 때 일종의 로그를 남기거나 알림을 할 수 있습니다. 

### 5. Security (보안성)
- **잘 수행된 부분**: 사용자 인증과 관련된 정보 처리는 안전하게 진행되고 있습니다. 특히 사용자 정보를 안전하게 삭제하는 부분이 보입니다.
- **개선할 부분**: 로그아웃 요청을 하는 메서드에 대해 CSRF(Cross-Site Request Forgery) 방어를 추가하는 것이 좋습니다. 추가적으로 로그인 상태를 검증하기 위한 로직이 포함되면 더욱 안전해질 것입니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 서비스가 잘 모듈화되어 있고, 각 기능이 유기적으로 구성되어 유지보수하기 용이한 구조입니다.
- **개선할 부분**: `logout` 기능이 추후에 다른 로직과 통합될 가능성이 있으므로, 더 많은 기능이 추가될 수도 있습니다. 메서드를 향후 확장 가능성이 있는 구조로 미리 나누어 두는 것이 좋습니다.

### 전체적인 피드백
코드 전반적으로 **깔끔하고 구조적으로 잘 작성된 부분**이 많습니다. 특히 메서드의 이름이 직관적이며, 사용자의 의도를 잘 표현하고 있어 이해하기 쉽습니다. 하지만, 각 작업에 대한 설명을 더 추가하고, 크게 재사용 가능한 기능으로 분리하는 방향으로 개선하면 더 좋을 것 같습니다. 마지막으로 보안을 강화하는 방향으로도 고민해보면 좋겠네요.

이번 리뷰가 코드 개선에 도움이 되길 바랍니다. 훌륭한 작업이었고, 향후 코드 발전을 응원합니다! 😊
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-18 10:18:16.076375', 213, '2024-11-18 10:18:16.076375', 56, '코드에서 `ref` 필드가 제거되었는데, 만약 GitLab 이벤트 처리에서 이 정보를 여전히 사용하는 경우에는 이 필드를 다시 추가해야 합니다. 또한, `objectKind`와 `eventType`을 함께 유지하여 코드의 가독성을 높일 수 있습니다. 이 외에는 코드 내용이 깔끔해 보입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:18:26.025812', 215, '2024-11-18 10:18:26.025812', 56, '안녕하세요! 주어진 코드 변경 사항을 살펴봤습니다. 여러 부분에서 개선을 위해 신경쓴 흔적이 보이네요. 전반적으로 기능성이 향상된 점이 긍정적입니다. 하지만 몇 가지 예외 상황이나 가독성을 높일 수 있는 부분에서 개선이 필요할 것으로 보입니다. 아래에서 각각의 항목에 대해 피드백 드릴게요.

### 긍정적인 점
1. **명확한 책임 분리**: `GitlabWebhookController`와 `GitlabEventHandler`之间의 책임이 명확하게 구분되고 있습니다. 컨트롤러는 이벤트를 수신하고 핸들러는 비즈니스 로직을 담당하도록 되어 있어, 코드를 관리하기가 더 수월해졌습니다.
2. **르리한 핸들러 초기화**: `Map.of()`를 사용하여 핸들러를 초기화한 것은 가독성을 높이고, 각 이벤트에 대한 핸들러 등록이 한 곳에서 처리되므로 유지보수에 유리합니다.

### 개선이 필요한 부분
1. **예외 처리 부족**: `handleMergeRequest`와 `handlePush` 메소드에서 `BusinessException`이 발생할 가능성이 있습니다. 이 경우 적절한 예외 처리가 이루어지지 않으면 시스템 에러로 이어질 수 있습니다. 예외를 처리하여 적절한 API 응답을 반환하도록 하면 좋을 것 같습니다.

   예를 들어:
   ```java
   try {
       gitlabEventHandler.handleMergeRequest(projectId, gitlabEventRequest);
       return ApiSuccessResponse.success();
   } catch (BusinessException e) {
       return ApiErrorResponse.error(e.getErrorCode());
   }
   ```

2. **헤더 매핑 개선**: 현재 `@PostMapping`에 직접 헤더 필터링을 추가하는 방식이 있는데, 다른 이벤트를 추가할 때 유연성이 떨어질 수 있습니다. 이 부분을 `@RequestMapping`으로 정의하여 각 메소드에서 헤더를 검증하도록 변경해보는 것도 좋습니다.

3. **테스트 케이스 확장**: 추가한 기능에 대해 다양한 시나리오를 고려한 테스트 케이스가 필요합니다. 현재의 테스트는 긍정적인 케이스와 일부 부정적인 케이스에 한정되어 있는 것 같습니다. 예를 들어, 항목이 없거나 형식이 잘못된 이벤트 요청에 대한 테스트를 추가하면 좋겠습니다.

   예를 들어:
   ```java
   @Test
   @DisplayName("비어 있는 Gitlab Merge Request 시나리오 테스트")
   void givenEmptyBody_whenHandleGitlabEvent_thenReturnsBadRequest() {
       // given
       String emptyRequestBody = "{}";

       // when
       webTestClient.post()
           .uri("/webhook/{projectId}", 1L)
           .header("X-Gitlab-Event", "Merge Request Hook")
           .header(CONTENT_TYPE, APPLICATION_JSON_VALUE)
           .bodyValue(emptyRequestBody)
           .exchange()
           // then
           .expectStatus().isBadRequest();
   }
   ```

4. **주석 및 문서화**: 코드 자체는 이해하기 쉬운 편이지만, 각 메소드 및 복잡한 로직에 대한 주석을 추가하여 나중에 다른 개발자가 이해하는 데 도움이 될 수 있도록 하는 것이 좋습니다. 특히 비즈니스 로직의 경우 그 흐름을 명확히 주석으로 남겨두세요.

5. **스타일과 코드 컨벤션**: 현재 Java의 주석 스타일, 코드 정렬 등은 전반적으로 괜찮습니다. 하지만, `@Async`와 같은 어노테이션은 메소드의 가시성을 명확히 하기 위해 항상 메소드 선언 바로 위에 두는 것이 좋습니다.

이 외에도 추가적으로 코드에서 찾을 수 있는 작은 개선 사항들이 있을 수 있지만, 전반적으로 잘 구성된 코드라는 인상을 받았습니다! 코드 품질이 상향되기를 기대하며, 진행하는 모든 작업에 행운을 빕니다. 더 궁금한 점이나 논의하고 싶은 사항이 있다면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-12 18:42:38.866851', 45, '2024-11-12 18:42:38.866851', 17, '코드를 살펴보니 변경 사항들이 잘 정리되어 있네! 이제 각 항목에 대해 꼼꼼하게 리뷰해볼게!

1. **기능적 정확성**: 변경된 코드에서 `mrInfoId`를 `reviewId`로 바꾼 건 아주 좋아! 이렇게 하면 더 명확하게 리뷰 내용을 관리할 수 있어서, 기능의 의도가 잘 드러나. 다만, 다른 부분에서 여전히 `mrInfoId`를 사용하는 코드가 섞여 있다면, 일관성을 유지하기 위해 전체적으로 정리하는 것을 추천해.

2. **가독성 및 유지보수성**: 전반적으로 함수명이 명확하고, 주석도 잘 달려 있어서 가독성이 좋네. 하지만, `sendToClient` 메소드에서 JSON 변환 오류와 연결 오류를 처리할 때 `printStackTrace()`를 사용하던 부분은 로깅 프레임워크를 사용해 좀 더 세련되게 처리할 수 있을 것 같아. 예를 들어, `log.error("JSON 변환 오류!", e);`와 같은 방식으로 처리하면 유지보수성이 더욱 높아질 거야.

3. **효율성**: 코드에서 아주 큰 비효율성은 느껴지지 않지만, `sendToClient` 메소드의 `emitter.send(...)` 호출 부분은 비동기 처리로 구현하면 더욱 효율적일 수 있어. 특히 대규모 이벤트를 처리하지는 않으니까 큰 차이는 없겠지만, 성능 최적화를 고려할 수 있게 될 거야.

4. **확장성 및 모듈성**: 코드가 모듈화가 잘 되어있어, `SseService`와 `SseController`의 역할이 분명하네! 새로운 기능이 추가될 때 각각의 모듈이 독립적으로 작동할 수 있어서 좋고, 이를 통해 시스템의 확장성도 잘 관리될 것 같아. 다만, 내부에서 사용할 `event`의 타입이 여러 가지가 될 경우, 이를 관리하기 위한 추가적인 클래스나 Enum을 고려해보는 것도 좋을 것 같아!

5. **버그와 취약점**: `JsonProcessingException` 예외를 `RuntimeException`으로 변환하여 던지는 부분은, 후속 처리가 어려울 수 있어. 좀 더 구체적인 예외 처리를 통해 어떤 문제가 발생했는지 명확히 알 수 있도록 하면 좋겠어. 이외에는 큰 버그는 보이지 않아!

6. **테스트 가능성**: 메소드들이 각기 잘 분리되어 있어서, 유닛 테스트를 작성하기에 수월할 것 같아. 각 메소드에서 assert 조건을 명확히 설정해두면 좋겠네. 테스트 커버리지를 높여서 나중에 수정 시 리그레션을 줄일 수 있을 거야!

7. **균형 잡힌 피드백**: 전반적으로 코드를 잘 정리한 것처럼 보여서 긍정적이야! 다만, 일부 예외 처리와 관련하여 조금 더 세심한 부분이 필요해. 전반적인 구조는 좋고 다른 개발자들이 이해하기 쉽게 잘 작성된 코드라는 점을 강조하고 싶어!

결론적으로, 기능의 의도를 잘 반영한 개선이니까 앞으로도 이런 방향으로 유지해주면 좋겠어! 궁금한 점이 있다면 언제든지 질문해줘! 🐾');
INSERT INTO public.review VALUES ('2024-11-12 18:43:04.802578', 46, '2024-11-12 18:43:04.802578', 17, '코드 리뷰해줄게! 양해해줘~!

### 1. 기능적 정확성
이번 변경사항들이 기능적으로 정확해 보이는데, `mrInfoId`라는 매개변수를 `reviewId`로 수정한 게 잘한 결정 같아. 명확하게 어떤 데이터를 다루는지 드러난 것 같아! 다시 말하면, `reviewId`가 더 직관적이고 기능의 의도를 잘 설명해주고 있어. 

하지만, 이 변경으로 인해 기존 코드에서 이 메소드를 호출하는 부분이 모두 수정되어야 할 것 같아. 이를 잊지 않도록 주의해줘!

### 2. 가독성 및 유지보수성
가독성은 매우 괜찮아. 변경된 부분에서는 명확한 변수명을 사용해서 코드가 무엇을 하는지 쉽게 이해할 수 있어. 매개변수 이름의 변경으로 인해 코드의 가독성이 향상된 걸 확인할 수 있어~! 

다만, `SseEmitter`와 같은 클래스의 기능이나 역할이 주석으로 설명이 되어 있다면 더욱 좋을 것 같아. 코드가 커지면 커질수록 이해하는 데 도움이 될 수 있을 거야.

### 3. 효율성
코드의 효율성은 특별히 문제가 없어 보이는데, SSE(Effort Stream Events) 처리에서 발생할 수 있는 병목 상황에 대한 더 많은 예외 처리를 추가하는 것도 좋을 것 같아. 예를 들어, 연결이 실패했을 때 대처하는 로직을 강화하면 시스템의 안정성이 높아질 거야.

### 4. 확장성 및 모듈성
리팩토링으로 인해 모듈성이 어느 정도 증가했네! `SseService`와 `SseController`가 각자의 역할에 맞게 잘 분리되어 있어. 프로젝트가 커질 경우에도 확장하는 데 큰 문제가 없어 보이지만, SSE 기능을 강화할 필요가 있을 때는 구조를 유연하게 조정할 수 있는 방법도 고민해보면 좋을 것 같아.

### 5. 버그와 취약점
코드에는 큰 버그가 없어 보이지만, JSON 변환과 관련된 부분에서 `RuntimeException` 대신 사용자 정의 예외를 던지는 것도 고려해 봐. 특정 예외를 캐치해서 적절한 오류 메시지를 제공하면 점검할 때 훨씬 유용할 거야. 

### 6. 테스트 가능성
테스트 가능성도 나쁘지 않지만, `notify`나 `sendToClient` 메소드를 더욱 세분화하여 각각의 호출에 대해 개별적으로 테스트할 수 있도록 만들어 보는 게 좋을 듯해! 현재는 긴 메소드 체인이 있어서 테스트하기가 조금 어렵더라고~. 

### 7. 균형 잡힌 피드백
코드의 전반적인 구조나 변경 사항은 적절해 보이고, 명확하게 잘 수정한 점에 대해 칭찬해주고 싶어. 특히 명확한 변수명을 사용한 점과, 불필요한 것들을 제거한 점은 훌륭해~! 

이번 변경사항이 시스템에 긍정적인 영향을 줄 것으로 보이며, 앞으로도 이런 방향으로 코딩을 계속하면 좋을 것 같아!

이상으로 리뷰 완료! 추가적으로 궁금한 점이나 더 알고 싶은 부분 있으면 언제든 말해줘~!');
INSERT INTO public.review VALUES ('2024-11-13 09:12:56.568975', 47, '2024-11-13 09:12:56.568975', 17, '안녕하세요! 코드 리뷰를 시작할게요, 냥!

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId` 매개변수가 `reviewId`로 변경된 점은 명확한 의도를 가지고 있으며, 이로 인해 서비스의 일관성이 높아졌다고 생각해요. 그러나 이 변경이 코드 전반에 어떤 영향을 미치는지 주의 깊게 테스트해야 해요. `subscribe` 메소드의 목적이 리뷰와 관련된 것이라면, 이를 명확히 문서화하는 것도 좋을 것 같아요, 냥.

### 2. 가독성 및 유지보수성
매개변수 명칭을 변경하는 것은 가독성을 향상시키는 좋은 조치였어요. `mrInfoId`가 `reviewId`로 변경됨으로써 무엇을 의미하는지 더 명확해졌네요, 냥! 하지만 코드 전반에 걸쳐 `mrInfoId`가 사용된 부분을 새롭게 변경된 명칭으로 일관되게 조정해야 해요. 이를 통해 유지보수를 더 쉽게 할 수 있을 거예요.

### 3. 효율성
현재 코드에서 효율성에 큰 문제가 보이진 않아요, 냥. 다만, `sendToClient` 메소드에서 JSON 직렬화를 여러 번 호출하고 있는데, 이 부분이 성능 저하의 원인이 될 수 있으니 한 번 검토해보길 권장해요. 예를 들어, `data`의 변환을 메소드 호출 전에 수행하는 방식으로 최적화할 수 있을 것 같아요.

### 4. 확장성 및 모듈성
각 메소드가 단일 책임 원칙을 잘 따르고 있어 확장성이 좋아 보여요. 하지만, `SseService`와 `SseController`의 관계가 다소 명확하지 않으니, 각각의 책임이 무엇인지를 주석으로 문서화해주는 것이 좋겠어요, 냥. 향후 기능이 확장될 때 명확한 구조를 유지할 수 있을 거예요.

### 5. 버그와 취약점
`sendToClient` 메소드에서 조건문 없이 `emitterRepository`에서 `emitter`를 가져오는 부분은 NULL 포인터 예외를 유발할 수 있어요. `emitter`가 NULL일 때 적절한 예외 처리를 추가하여 발생할 수 있는 오류를 방지하는 것이 좋겠어요, 냥.

### 6. 테스트 가능성
코드가 잘 모듈화되어 있어 테스트하기가 용이할 것 같아요. 특히 현재 코드의 각 메소드는 독립적으로 기능을 수행하므로, mock 객체를 활용한 단위 테스트가 가능할 것으로 보입니다. `subscribe`와 `notify` 메소드의 결과를 다양한 입력값으로 테스트하는 것이 중요해요, 냥.

### 7. 균형 잡힌 피드백
변경된 코드가 전반적으로 문제를 해결하기 위한 적절한 접근 방식을 취하고 있어요, 냥! 특히 매개변수의 명확한 변경은 가독성을 높이는데 크게 기여했어요. 다만, 다양한 예외처리와 주석 부족 문제를 보완한다면 더욱 완성도 높은 코드가 될 것 같아요.

총체적으로, 변화가 긍정적이라고 봐요! 위에서 언급한 부분들을 반영하여 다음 코드를 개선한다면 더욱 좋을 것 같아요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 09:50:18.969481', 48, '2024-11-13 09:50:18.969481', 18, '안녕하세요, 코드 리뷰를 진행하겠어요, 냥!

### 1. 기능적 정확성
변경된 코드에서 SSE 데이터 오류 처리 부분이 개선되었어요. `RuntimeException` 대신 `BusinessException`을 사용해 오류 코드로 명확하게 구분하는 점은 좋은 접근이네요, 냥. 하지만 `SSE_DATA_SEND_ERROR`와 `SSE_DATA_SERIALIZATION_ERROR`의 경우, 특정 상황에서 어떻게 처리되는지에 대한 로깅이 부족해 보여요. 예외 발생 시 상세한 정보가 로그에 남도록 개선하면 좋을 것 같아요, 냥.

### 2. 가독성 및 유지보수성
코드 전반적으로 가독성이 뛰어나요. 특히 `ErrorCode` enum의 설명 주석들이 코드의 의도를 잘 설명하고 있어 좋아요, 냥! 하지만 `sseService.notify(findReview.getId(), "create review");`와 같은 메서드 호출이 흐름 둔화로 다소 복잡하게 보일 수 있어요, 냥. 해당 메서드가 어떤 역할을 하는지 주석을 추가해 주면 더 좋겠어요!

### 3. 효율성
`findFirstByMrInfoOrderByCreatedDateAsc` 메서드가 추가되어 리뷰를 효율적으로 조회할 수 있게 되었어요. 특히 이러한 방식은 데이터베이스 쿼리를 최적화하는 데 도움이 될 것 같아요, 냥. 하지만, 만약 리뷰가 존재하지 않을 경우에 대한 예외 처리가 빠져 있는 점이 아쉽네요. 해당 경우를 처리하는 로직이 필요해 보여요, 냥!

### 4. 확장성 및 모듈성
`ErrorCode`가 분리된 형태로 관리되어 있어 확장성이 좋아요. 추가 오류 코드들의 형태도 consistency를 유지하고 있어 좋네요, 냥. 하지만 if 문 안의 로직이 비대해지면 유지보수가 어려울 수 있으니, 가능하면 해당 로직을 별도의 메서드로 분리하는 방향을 고려해보길 추천해요, 냥.

### 5. 버그와 취약점
기존의 에러 핸들링 방식인 `e.printStackTrace()`가 모두 제거되었고, 사용자 정의 예외가 도입되어 더 안전한 코드가 되었어요, 냥. 하지만 비즈니스 로직에서 예외가 발생했을 때, 해당 예외를 호출한 메서드에서 더 나은 예외 처리가 필요해 보이네요, 냥. 예외 메시지를 사용자에게 전달할 수 있도록 개선해 보길 추천해요!

### 6. 테스트 가능성
테스트 코드가 잘 작성되어 있어 코드의 동작을 검증하는데 도움이 될 것 같아요, 냥. 하지만 실질적인 테스트에 대한 검토가 필요해요. 특히 예외가 발생하는 경우를 포함한 여러 경로에 대한 테스트를 추가하여 더욱 철저하게 검증해보면 좋겠어요, 냥.

### 7. 균형 잡힌 피드백
전반적으로 코드 변경이 잘 이루어졌고, 오류 처리 측면에서 큰 개선이 있었어요. 단점으로는 일부 로깅이 부족하다는 점과, 명확한 예외 처리가 아쉽네요. 그렇지만 전반적으로 코드의 구조와 흐름이 잘 유지되어 있어 긍정적이에요, 냥. 앞으로도 품질을 유지하기 위해 위의 개선점들을 고려해보면 좋겠어요!

리뷰를 마칠게요. 추가적인 질문이 있다면 언제든지 물어봐주세요, 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 15:37:24.25708', 124, '2024-11-13 15:37:24.25708', 25, '## 코드 리뷰

1. **Readability (가독성)**:
   - **잘 수행하고 있는 부분**: 코드 전반적으로 명확한 메서드와 변수명을 사용하여 의도를 잘 전달하고 있습니다. 예를 들어, `addGitlabAccount`, `logout` 등 메서드는 목적이 명확하게 드러납니다.
   - **개선이 필요한 부분**: 추가적인 주석이 제공된다면 비즈니스 로직의 이해를 돕거나, 특정 부분에 대한 설명(예: 예외가 발생하는 상황)에 대한 주석이 더해져 가독성이 향상될 것입니다. 특히 `makeCodeReviewWhenCalledByWebhook` 메서드는 복잡한 로직을 포함하고 있어 각 단계에 대한 주석이 필요합니다.

2. **Consistency (일관성)**:
   - **잘 수행하고 있는 부분**: Java의 표준 네이밍 규칙(카멜 케이스 사용)에 대한 준수가 잘 이루어지고 있습니다. `@PostMapping`, `@GetMapping` 등 Spring의 어노테이션 사용도 일관되게 적용되고 있습니다.
   - **개선이 필요한 부분**: 주석 및 메서드 설명의 스타일이 일관되지 않는 부분이 있습니다. 예를 들어, 일부 메서드에는 Swagger 어노테이션이 잘 붙어있지만, 다른 일부 메서드에서는 보다 명확한 설명이 부족합니다. 모든 API 엔드포인트에 대해 비슷한 형식의 설명을 추가하는 것이 좋습니다.

3. **Reusability (재사용성)**:
   - **잘 수행하고 있는 부분**: 각 기능이 분리되어 있고, 리팩토링이 잘 진행되어 있어 특정 서비스(예: `userService`)가 다양한 API 컨트롤러에서 재사용될 수 있습니다.
   - **개선이 필요한 부분**: `logout` 메서드는 요청과 응답 객체를 받아 처리하는 논리를 포함하고 있습니다. 이를 `CookieHandler`와 같은 별도의 유틸성 클래스로 분리하면 동일한 로직을 다른 컨텍스트에서도 재사용할 수 있을 것입니다.

4. **Reliability (신뢰성)**:
   - **잘 수행하고 있는 부분**: 예외 처리가 적절하게 구현되어 있으며, 특정 예외 발생 시 적절한 비즈니스 예외로 전환되어 있습니다.
   - **개선이 필요한 부분**: `unlinkGitlabProject` 메서드와 같이 관계형 데이터베이스에서 데이터를 다룰 때, 예외 집중적으로 처리하는 로직이 더 추가되면 좋습니다. 예를 들어, 데이터가 존재하지 않는 경우에 대한 처리 로직이 필요합니다.

5. **Security (보안성)**:
   - **잘 수행하고 있는 부분**: `logout` 메서드에서 쿠키를 안전하게 삭제하고 Redis에서 refresh token을 삭제하는 로직이 포함되어 보안적으로 잘 처리되고 있습니다.
   - **개선이 필요한 부분**: 요청의 유효성을 검증하는 추가 검증 로직이 필요합니다. 예를 들어, `addGitlabAccount` 메서드에서는 사용자나 GitLab 계정 정보가 유효한지 확인하는 절차가 필요합니다.

6. **Maintainability (유지보수성)**:
   - **잘 수행하고 있는 부분**: 기능별로 명확히 나누어진 서비스와 컨트롤러 구조로 인해 코드 변경 시 영향 범위가 명확합니다.
   - **개선이 필요한 부분**: 각 서비스의 책임이 다소 많은 듯 보입니다. 예를 들어, `UserService`에는 사용자 관련 비즈니스 로직뿐만 아니라 GitLab 계정 관리 등의 로직이 혼재하여, 서비스의 책임을 분리하는 것이 좋습니다.

## 전체적인 피드백:
- 전반적으로 매우 잘 작성된 코드로, 가독성과 일관성 측면에서 높은 점수를 줄 수 있습니다. 프로그래밍 관례를 잘 따르고 있으며, 주요 비즈니스 로직이 잘 분리되어 있어 유지보수도 용이할 것입니다.
- 그러나 몇 가지 개선이 필요한 부분이 있으며, 예외 관리와 보안 검증은 꼭 다듬어야 하는 요소이므로 이를 염두에 두어야 합니다. 또한, 특정 메서드를 리팩토링하여 재사용성을 높이고, 다양한 상황에서 발생할 수 있는 모든 예외를 최적의 방법으로 처리하는 전략이 필요합니다. 
');
INSERT INTO public.review VALUES ('2024-11-13 10:00:28.241374', 49, '2024-11-13 10:00:28.241374', 17, '코드 리뷰 결과를 아래와 같이 제공할게 냥!

### 1. 기능적 정확성
변경된 코드에서는 `mrInfoId`를 `reviewId`로 변경한 부분이 눈에 띄어. 이 변경이 요구 사항을 올바르게 충족하는지는 전체 시스템에서 `reviewId`를 사용하는지에 따라 달라질 것 같아. 만약 기존에 `mrInfoId`를 참조했던 다른 부분들이 있다면, 이로 인해 혼란이 발생할 가능성이 있으니 추가 검토가 필요해 보이네 냥.

### 2. 가독성 및 유지보수성
변경된 매개변수 이름이 보다 명확하게 변경되었고, 이는 가독성을 향상시켜 주었어. 특히 `mrInfoId`를 `reviewId`로 변경하여 그 의도를 더 분명하게 해줬다고 생각해 냥! 그러나, 코드를 더욱 이해하기 쉽게 만들기 위해서는 각 메서드에 대한 자바 문서 주석을 추가하는 것도 고려해 볼 수 있어.

### 3. 효율성
변경 부분에서 효율성에 주요한 문제는 발견되지 않았어. 다만, `sendToClient` 메서드에서 JSON 변환 오류 및 IO 예외 처리가 있어, 이 부분이 호출될 때 발생할 수 있는 성능 문제를 미리 인지하고 대처하는 것이 좋겠어. 하지만 전반적인 구조는 효율적으로 보이네 냥.

### 4. 확장성 및 모듈성
이 코드의 변경이 시스템의 확장성에는 큰 영향을 미치지 않을 것 같아. 하지만 `Review`와 관련된 코드들이 구체적으로 어떤 방식으로 서로 연결되는지가 더 명확히 문서화될 필요가 있을 것 같아. 해당 메서드들이 서로 의존하는 방식이 명확하면 나중에 유지보수하기 좀 더 쉬울 거야 냥.

### 5. 버그와 취약점
`sendToClient` 메서드에서는 `emitter`가 `null`인 경우를 체크하고, 이를 로그로 남기고 있어. 다만 이 부분에서 문제가 생기면 예외 처리가 필요할 수도 있을 것 같아. 현재 구조로는 `null` 값이 반환되면 후속 처리가 어려울 수 있어. 왜냐면, 잔여 로직에서 `emitter`가 필요할 때가 많거든 냥. 이 점에 대해서는 방어적으로 코드를 수정하는 것이 좋겠어.

### 6. 테스트 가능성
변경된 메서드는 테스트하기 용이하게 구조화 되어 있는 것 같아. `reviewId`와 같이 명시적인 파라미터를 사용하는 것이 특정 케이스를 쉽게 테스트할 수 있도록 만들어 줄 거야. 그러나, `sendToClient` 메서드 내에서 발생하는 예외를 잘 다루지 않기 때문에, 이를 테스트하기 어려운 상황이 발생할 수 있어. 예외를 포함한 다양한 경로에 대한 테스트가 이루어지는 것이 중요해 냥!

### 7. 균형 잡힌 피드백
전반적으로 코드가 잘 구현된 점이 많았고, 특히 매개변수의 명확함과 메서드 네이밍이 개선된 점이 인상적이었어. 그러나 변수 변경이 다른 부분과의 일관성에 미칠 수 있는 영향을 고려하고, 예외 처리의 적절성을 다시 점검하는 것이 필요해 보인다냥. 이런 점을 보완하면 더 좋은 코드가 될 수 있을 것 같아 냥!

이상으로 코드 리뷰를 마칠게 냥! 추가적인 도움이 필요하면 언제든지 이야기해 줘!');
INSERT INTO public.review VALUES ('2024-11-13 10:02:39.8784', 50, '2024-11-13 10:02:39.8784', 17, '안녕하세요! 코드 리뷰를 시작할게요, 냥.

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 바꾸는 것은 격렬한 의미 변화가 없다고 생각해요. 하지만, 코드의 의도를 잘 반영해 주었고, 변수명이 더 정확하게 기능을 설명해줘서 좋았어, 냥. 그러니 이 부분은 긍정적으로 봐도 될 것 같아.

### 2. 가독성 및 유지보수성
변경된 메서드의 파라미터명이 `reviewId`로 바뀌면서 코드의 가독성이 높아졌어. `mrInfoId`보다는 리뷰를 더 잘 설명해주기 때문이야. 다른 부분들에서도 파라미터명이나 변수명이 명확하게 잘 작성되어 있어 가독성도 뛰어난 것 같아, 냥. 

### 3. 효율성
현재 코드에서 비효율적인 부분은 크게 보이지 않아. 메소드의 구조나 호출 방식이 효율적이어서 성능에 큰 영향을 미칠 것 같지는 않은데, 코드 전반적으로 간결하게 짜여져 있다는 점에서 칭찬해, 냥.

### 4. 확장성 및 모듈성
변수명을 바꿔주는 것이 향후에 새로운 기능이나 요구 사항을 추가할 때 도움을 줄 거라고 생각해. 코드가 더욱 모듈화되어 있는 만큼, 나중에 변경이 필요할 때도 덜 복잡할 것 같아, 냥. 구현이 잘 되어있어 칭찬해 줄 만해.

### 5. 버그와 취약점
현재로서는 큰 버그나 취약점은 없어 보여. 하지만 `sendToClient` 메서드에서 발생하는 예외 처리가 충분히 강화되길 바래. 모든 예외에 대해 적절한 처리를 해줘야 해, 냥. 추가적으로 로깅 외에 예외 상황에 대한 특별한 처리가 필요할 수도 있어.

### 6. 테스트 가능성
테스트 가능성 면에서는, 메소드들이 잘 분리되어 있어서 각 단위에 대한 테스트가 수월할 것 같아. 특히 `subscribe`와 `notify` 메서드가 각자의 역할을 잘 수행하고 있어 테스트 작성이 용이할 것 같아, 냥.

### 7. 균형 잡힌 피드백
전반적으로 좋은 코드 변경 사항이에요, 냥. 하지만 에러 핸들링과 예외 처리 부분에서 조금 더 개선의 여지가 있음을 기억해주길 바래. 보완할 점이 없는 건 아니지만, 전체적인 원래 코드에 비해 개선이 잘 이루어졌어. 이런 거 꼭 계속 잘 작성해 줘야 해, 냥!

결론적으로, 긍정적인 부분들이 더 많았던 리뷰였어. 앞으로도 좋은 코드 작성 기대할게! 전체적으로 정말 잘했어, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:02:40.235088', 51, '2024-11-13 10:02:40.235088', 17, '안녕하세요! 리뷰를 시작할게요~ 😺

## 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 수정한 부분은 기능적으로 일관성을 높여줄 수 있어요. 그러나, 시스템 전반에서 `mrInfoId`에 의존하는 다른 코드가 있다면, 이러한 변경이 영향을 미칠 수 있음을 염두에 두어야 해요. 테스트를 통해 의도한 대로 모든 기능이 작동하는지 확인하는 것이 중요해요, 냥~

## 가독성 및 유지보수성
코드의 가독성이 좋고 일관성이 유지되고 있어요. 고유한 변수 이름 (`reviewId`) 사용으로 의미가 분명히 전달되고 있네요. 그러나, 변경된 부분에 대한 주석을 추가하면 다른 개발자들이 변경 의도를 이해하는 데 더 도움이 될 것 같아요, 냥! 예를 들어, `@RequestParam` 이름 변경에 대한 간단한 코멘트가 좋을 것 같아요.

## 효율성
이 부분은 효율적으로 작성되었어요. `SseEmitter`와 관련된 코드가 간결하고, 불필요한 복잡성이 없어서 좋은 점수를 줄 수 있을 것 같아요! 이와 관련하여 `sendToClient`에서 JSON 직렬화 작업이 포함되어 있는데, 이에 대한 예외 처리가 잘 이루어져 있어요. 훌륭해요, 냥~

## 확장성 및 모듈성
코드 구조 자체가 모듈화되어 있어, 향후 요구사항 변경 시 유연하게 대처할 수 있을 것 같아요. `SseService`와 `SseController`의 역할이 분리되어 있어서 코드 확장성이 높아요, 냥! 하지만 만약 추가적인 SSE 이벤트 요구가 생길 경우, 관련 모듈에 대해 리팩토링을 고려해야 할 수 있어요.

## 버그와 취약점
현재 코드는 대체로 안정적으로 보이네요! 다만 `sendToClient` 메서드에서 `IOException` 발생 시 emitters에서 제거하는 로직이 있지만, 이 경우 클라이언트와의 연결이 끊겨도 관련 처리가 필요한 점이 있어요. 예를 들어, 실패한 연결에 대해 적절한 재시도를 고려해야 할 수도 있어요.

## 테스트 가능성
테스트 가능성이 높아 보여요! 주입된 의존성 및 독립적인 메서드 구조 덕분에 각 기능별로 테스트할 수 있을 것 같아요. 그러나 `notify` 메서드와 같은 부분에 대한 단위 테스트 작성 시, 특정 이벤트에 대한 다양한 상황을 고려해야 할 것 같아요, 냥~

## 균형 잡힌 피드백
전반적으로 잘 작성된 코드인 것 같아요! 특히, SSE 관련 기능들이 모듈적으로 잘 구성되어 있고 예외 처리도 신경 쓴 부분이 인상적이에요. 다만, 변수명이 변경된 부분에 대한 명확한 주석 추가와 연결 실패 처리에 대한 개선 방안을 고려하면 더욱 좋을 것 같아요. 계속해서 좋은 코드 작성해 주세요! 😸');
INSERT INTO public.review VALUES ('2024-11-13 10:02:40.61268', 52, '2024-11-13 10:02:40.61268', 17, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`가 `reviewId`로 변경된 것은 기능적 정확성 측면에서 적절한 수정으로 보입니다. 그러나 이 변경이 다른 부분, 특히 데이터베이스 작업이나 다른 서비스에서 일관성을 유지하는지 확인해야 해요. 코드의 다른 부분에서 여전히 `mrInfoId`를 사용하고 있다면, 버그가 발생할 수 있으니 확인이 필요해요.

### 2. 가독성 및 유지보수성
변경된 코드의 가독성을 개선한 부분이 있어요. 예를 들어, 매개변수 이름을 `mrInfoId`에서 `reviewId`로 변경하면서 코드의 의미가 더 명확해졌어요. 그러나 매개변수를 변경할 때는 함수 내부에서도 변경되었는지 주의해야 해요. 전반적으로 이해하기 쉬운 코드 구조를 유지하고 있기 때문에 가독성은 긍정적이에요.

### 3. 효율성
전체적으로 코드의 효율성에는 큰 문제가 없어요. 그러나 `sendToClient` 메소드에서 `System.out.println`를 사용하지 않고 로깅 프레임워크를 사용하는 게 더 바람직해요. `System.out.println` 대신 `log.info`나 `log.debug`를 사용하는 것이 성능 및 관리 측면에서 더 좋을 거예요.

### 4. 확장성 및 모듈성
코드는 모듈화가 잘 되어 있으며, 각 메소드는 특정 기능을 수행하고 있어요. 그러나 `subscribe` 메소드와 같이 행동이 유사한 메소드들에서 매개변수 이름이 일관되게 유지되도록 하면, 이와 같은 변화를 시행할 때 코드에 발생할 수 있는 실수를 줄일 수 있어요.

### 5. 버그와 취약점
`sendToClient` 메소드 내부에서 JSON 변환 과정과 관련된 에러 핸들링은 잘 구성되어 있어요. 하지만 `RuntimeException`을 사용하면 호출하는 측에서 예외 처리에 어려움을 겪을 수 있으니, 적절한 커스텀 예외 클래스를 도입하는 것이 좋겠어요. 또한, `emitter`가 null인 경우에도 안전하게 처리할 로직이 필요해요.

### 6. 테스트 가능성
변경된 메소드들은 테스트하기 쉬운 구조를 가지고 있어요. 그러나 `sendToClient`와 같이 특정 환경에 의존하는 메소드의 경우, 그에 대한 Mock 객체를 사용하는 테스트가 필요할 수 있어요. 전반적으로 테스트 가능성이 높은 코드 구조를 갖고 있어요.

### 7. 균형 잡힌 피드백
전반적으로, 코드 개선의 방향성이 잘 설정되어 있으며, 가독성, 유지보수성 측면에서 긍정적인 변화를 가져왔다고 평가할 수 있어요. 하지만 함수 내부의 일관성을 유지하고, 로깅 시스템을 활용하는 등의 작은 세부 사항을 더 고려한다면 더욱 뛰어난 코드를 완성할 수 있을 것 같아요.

좋은 변경사항들이 많아 긍정적인 방향으로 나아가고 있으니, 앞으로도 이러한 개선을 지속해 나가면 좋겠어요! 냥~');
INSERT INTO public.review VALUES ('2024-11-13 16:56:58.899797', 125, '2024-11-13 16:56:58.899797', 26, '## 코드 리뷰 피드백

### 1. Readability (가독성)

**잘 수행된 부분:**
- 주석이 적절히 사용되어 있어 코드의 목적이 잘 설명되어 있습니다. 예를 들어, `handleError` 함수는 다양한 HTTP 오류 코드에 대한 처리를 명확히 하고 있으며, 함수명이 기능을 설명합니다.

**개선 사항:**
- 더 복잡한 로직이나 비즈니스 로직에 대해서는 추가적인 주석을 추가하는 것이 좋습니다. 예를 들어, `responseBody` 함수의 사용 의도나 context에 대한 간단한 설명이 추가되면 좋겠습니다.

### 2. Consistency (일관성)

**잘 수행된 부분:**
- 변수명과 함수명이 일관되게 사용되고 있습니다. 예를 들어, `BadgeList`와 `Badge` 컴포넌트는 명확한 명명 규칙을 따릅니다.

**개선 사항:**
- 전체 프로젝트에서 사용하는 스타일 가이드나 컨벤션에 대한 문서를 작성하면 팀원들이 이를 따라할 수 있습니다. 예를 들어, CSS 클래스 네이밍 규칙이나 컴포넌트 파일 구조에 대한 명확한 가이드라인이 필요합니다.

### 3. Reusability (재사용성)

**잘 수행된 부분:**
- `AuthGuard`나 `NavigationButtons`와 같은 구성 요소는 독립적으로 잘 분리되어 있으며, 다른 많은 페이지에서 재사용될 수 있는 구조입니다.

**개선 사항:**
- `responseBody` 함수의 경우, 다른 상황에서도 사용할 수 있도록 매개변수를 좀 더 유연하게 만들어 구성 요소의 데이터를 변환하는 데 재사용할 수 있도록 하면 좋겠습니다. 예를 들어, 데이터의 기본 형식에 따라 다른 변환을 지원하도록 확장할 수 있습니다.

### 4. Reliability (신뢰성)

**잘 수행된 부분:**
- API 호출에 대한 오류 처리가 잘 이루어져 있습니다. 각 상태 코드에 대해 구체적인 에러 처리를 구현하고 있어 사용자에게 명확한 피드백을 제공합니다.

**개선 사항:**
- `isLoading` 상태가 `false`로 설정된 후에 바로 에러 처리를 하는 부분이 있습니다. 이럴 경우, 최대한 오류를 즉시 처리하고 UI를 비동기적으로 업데이트하는 것이 좋습니다. 예를 들어, 사용자에게 로딩 중 스피너를 보여준 후 로딩이 완료된 후 오류를 보여줄 경우 UX가 개선될 수 있습니다.

### 5. Security (보안성)

**잘 수행된 부분:**
- `handleError` 함수 내에서 민감한 데이터에 대한 경고를 명확하게 하고 있습니다. 사용자가 로그인 페이지로 리디렉션 될 때 경고창을 띄워 정보 유출을 방지하도록 한 점이 긍정적입니다.

**개선 사항:**
- API 호출 시 입력 검증이 강화되어야 합니다. 사용자가 보내는 요청에 대한 유효성 검사를 추가하여 불필요한 요청을 최소화하는 것이 좋습니다. 예를 들어, 사용자 입력이 유효한지 확인하는 함수(예: `validateInput`)를 추가하여 불법적인 입력을 차단할 수 있습니다.

### 6. Maintainability (유지보수성)

**잘 수행된 부분:**
- 각 기능이 독립적으로 잘 나누어져 있어 코드의 유지보수가 쉽습니다. 예를 들어, 각 API 호출 로직이 별도의 파일에 모듈화되어 관리되고 있습니다.

**개선 사항:**
- 에러 처리 로직을 분리하여 관리하면 더 나은 유지보수성을 확보할 수 있습니다. 현재 `handleError` 함수가 전역적으로 정의되어 있지만, 이를 Axios 인스턴스에서 사용할 수 있도록 공통으로 사용되는 에러 처리 로직을 정의하고, API 호출마다 공통 에러 처리 기능을 모듈화 하는 것이 좋습니다.

### 전체적인 피드백

이 코드는 전반적으로 명확하고 잘 구성되어 있으며, 강력한 구조와 일관성을 가지고 있습니다. 특히 오류 처리와 사용자 경험을 고려한 부분이 인상적입니다. 그러나 개선이 필요한 점은 주석 추가, 구조화된 스타일 가이드 제안, 사용자 입력 검증 강화 및 공통 에러 처리 기능의 모듈화 등이 있습니다. 이러한 사항들을 개선하면 더욱 안전하고 안정적인 코드를 만들 수 있을 것입니다. 

제안된 변화는 코드의 유지보수성과 향후 확장성을 크게 향상시킬 것입니다. 긍정적인 피드백과 함께 개선 비제안들이 적절하게 반영되어 다음 단계로 나아갈 수 있도록 하십시오.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-18 10:30:27.425145', 217, '2024-11-18 10:30:27.425145', 57, '변경한 부분에서 "py-4"을 "pb-4"로 수정한 것은 패딩을 상단에서 하단으로 조정하여 레이아웃을 개선하려는 의도로 보입니다. 다만, "py-4"가 필요했던 경우 상단 여백이 사라질 수 있으므로, 전체 디자인을 고려하여 확인해보는 것이 좋습니다. 추가적으로, 클래스 이름 변경에 따른 시각적 차이를 사용자 경험 관점에서 테스트해보면 좋겠습니다.');
INSERT INTO public.review VALUES ('2024-11-13 10:02:41.188818', 53, '2024-11-13 10:02:41.188818', 17, '안녕하세요 냥! 아래는 코드 변경 사항에 대한 리뷰 결과예요 냥.

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`가 `reviewId`로 변경되었는데, 이로 인해 메소드 호출 시 변수명이 보다 명확해졌어요 냥. 그러나 코드를 호출하는 곳에서 `reviewId`로 변경된 변수가 올바르게 사용되도록 전체 시스템을 점검해야 해요 냥. 그렇지 않으면, 런타임 시 오류가 발생할 수 있으니 주의해야 해요 냥.

### 2. 가독성 및 유지보수성
변수명을 `mrInfoId`에서 `reviewId`로 변경한 것은 코드의 의도를 보다 명확히 나타내어 가독성이 개선되었어요 냥. 그러나 두 경우의 변수가 동일한 역할을 하는 것이므로, 필요에 따라 변수명이 만들어 내는 코드의 의미와 일관성을 유지할 수 있도록 주의해야 해요 냥. 코드 주석 등을 통해 이를 명확히 설계하면 좋을 것 같아요 냥.

### 3. 효율성
현재 코드에서 성능에 심각한 영향을 미치는 부분은 없어 보이지만, `sendToClient` 메소드 내에서 JSON 직렬화와 같은 무거운 작업이 발생하고 있어요 냥. 이를 비동기적으로 처리할 수 있다면 성능을 개선할 수 있을 거예요 냥. 또한, 예외 처리 부분에서 발생하는 스택 트레이스를 로깅하는 대신, 사용자에게 의미 있는 메시지를 반환하는 방법을 고려해야 해요 냥.

### 4. 확장성 및 모듈성
현재의 구조는 꽤 모듈화되어 있으나, 특정한 로직에서는 여러 메소드를 연결짓는 구조가 있어 확장성 측면에서 다소 유연성이 떨어질 수 있어요 냥. 예를 들어, `subscribe`와 `notify`가 동일한 경로에서 호출되는 구조는 추후 확장이 필요할 때 복잡성을 유발할 수 있어요 냥. 구조를 좀 더 확장 가능하도록 리팩토링하는 것을 권장해요 냥.

### 5. 버그와 취약점
특정 예외 발생 시 `RuntimeException`을 발생하는 부분이 있으나, 이는 어떤 예외인지 명확히 명시되지 않아 추후 문제가 발생할 수 있어요 냥. `JsonProcessingException`과 `IOException`에 대해 구체적인 예외를 발생시키고, 해당 정보들을 로그로 남기도록 개선해야 해요 냥.

### 6. 테스트 가능성
코드가 전반적으로 테스트하기 쉬운 구조를 가지고 있지만, 응답 이벤트와 외부 의존성(예: `gitLabClient`)에 대한 테스트가 용이하도록 모킹이 필요해요 냥. 특히, SseEmitter의 동작을 검증하기 위한 단위 테스트 방법을 더 고려해야 좋을 것 같아요 냥.

### 7. 균형 잡힌 피드백
변경된 코드의 변수명 및 구조 개선은 긍정적으로 평가할 만해요 냥. 그러나 예외 처리 및 로깅 관례, 그리고 테스트 구조에 대한 보완이 필요해요 냥. 전반적으로 유지보수성과 가독성이 개선되어 좋은 방향이라 생각해요 냥.

이런 피드백이 도움이 되길 바라요 냥! 추가 질문 있으시면 언제든지 말씀해 주세요 냥.');
INSERT INTO public.review VALUES ('2024-11-13 10:02:41.862998', 54, '2024-11-13 10:02:41.862998', 17, '코드 리뷰를 진행해 볼게요, 냥!

### 1. 기능적 정확성
변경된 함수에서 `mrInfoId`를 `reviewId`로 변경한 것에 대해, 코드의 기능적 측면에서 매우 적절해 보인다, 냥. 코드의 의도가 명확해지고, 읽는 사람이 이해하기 쉬워졌다, 냥. 하지만, `reviewId`가 실제로 무엇을 의미하는지에 대한 주석이나 문서가 없다면, 향후 팀원들이 이 코드의 목적을 이해하기 어려울 수 있다, 냥. 따라서 적절한 주석을 추가하면 더욱 좋을 것 같다, 냥.

### 2. 가독성 및 유지보수성
변경된 코드 부분은 각 변수의 이름이 의미를 잘 전달하고 있어서 가독성이 높다, 냥. 특히, `reviewId`라는 이름은 이제 어떤 데이터를 나타내는지 명확히 전달하고 있다, 냥. 그러나 `sendToClient` 메서드와 같은 부분에서 메서드가 더 많은 작업을 담당하고 있는 것처럼 보인다, 냥. 이를 더 작고 명확한 메서드로 분리하면 유지보수성이 더욱 향상될 것 같아, 냥.

### 3. 효율성
성능 측면에서 보면, 이번 변경은 부하를 줄이는 데 도움을 줄 수 있었지만, 코드의 효율성은 향상이 별로 없는 것 같아, 냥. 특히 `sendToClient` 메서드에서 예외 처리가 중복으로 있다. 중복된 코드 대신 공통된 예외 처리 로직을 별도의 메서드로 만들면 성능도 개선되고 가독성도 높아질 것 같다, 냥.

### 4. 확장성 및 모듈성
`notify` 메서드에서의 코드 변화는 더 나은 확장성을 제공할 수 있다, 냥. `reviewId`로 전환하여 이 서비스가 더 넓은 범위의 데이터를 처리할 수 있도록 하고 있다, 냥. 하지만 데이터 모델이 변경되는 경우를 대비한 예외 핸들링이 없다면 문제가 발생할 수 있어, 여기에 대한 대책을 마련해야 한다, 냥.

### 5. 버그와 취약점
현재 코드에서 버그가 발생할 가능성이 있는 부분은 `sendToClient` 메서드 내에서 JSON 변환 오류가 발생할 때의 처리 로직이다, 냥. 예외가 발생했을 때 단순히 `RuntimeException`을 던지기보다는 좀 더 구체적인 예외 메시지를 제공하는 것이 좋을 것 같다, 냥. 이렇게 하면 후속 작업에서 문제를 진단하기 쉬워질 테니 말이다, 냥.

### 6. 테스트 가능성
수정된 코드 구조는 기본적으로 테스트 가능하긴 하지만, 복잡하게 얽힌 비즈니스 로직이 포함된 경우 분리된 서비스에 대한 유닛 테스트가 필요할 것이다, 냥. 각 메서드가 독립적인 단위 테스트를 수행할 수 있도록 설계되어 있으면 좋겠다는 생각이 드네, 냥. 

### 7. 균형 잡힌 피드백
전반적으로 코드 변경이 의미 있는 방향으로 진행된 것 같아, 긍정적으로 평가할 수 있다, 냥. 특히, 변수 이름 변경으로 인한 가독성 향상은 큰 장점이다, 냥. 다만 예외 처리나 비즈니스 로직의 복잡함에 대한 개선이 필요하니, 이를 유념하며 더 나은 방향으로 발전시키면 좋을 것 같아, 냥.

개선된 부분과 함께 여러 가지 여지를 제안했으니 앞으로 더 발전할 수 있길 바라, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:02:42.124463', 55, '2024-11-13 10:02:42.124463', 17, '## 코드 리뷰

### 1. 기능적 정확성
코드 변경 사항은 `mrInfoId`를 `reviewId`로 변경함으로써, 더 명확한 파라미터 이름을 사용하고 있나냥. 이 변경은 코드의 기능적 정확성을 높이는데 긍정적인 영향을 미치나, 구현된 부분에서 `reviewId`가 실제로 무엇을 의미하는지에 대한 설명이 부족해서 나중에 이해하는 데 약간의 혼란이 있을 수 있나냥. 추가적인 주석을 달아주면 좋겠다는 생각이 드나냥.

### 2. 가독성 및 유지보수성
변경된 메서드의 이름 변경으로 인해 코드의 가독성이 개선됐다고 생각하나냥. 명확한 변수 이름 사용은 코드 이해에 도움을 주며, 유지보수성을 높이는 데 기여하나, 모든 메서드에 일관된 네이밍 컨벤션을 유지하는 것이 중요하니까 주의하길 바란다냥. 예를 들어 `notify` 메서드에서 파라미터 이름이 일관되도록 `reviewId` 사용한 것은 긍정적이지만, 다른 메서드에서도 이런 일관성을 유지하는 것이 중요하단 말이야냥.

### 3. 효율성
성능에 영향을 미치는 부분은 현재로서는 크게 개선할 필요가 없어 보이나, 데이터 전송 부분에서 개선할 수 있는 여지가 있기 때문에, 서버와 클라이언트 간의 효율적인 데이터 전송 방식을 고민해보는 것도 필요할 것 같아냥. 현재 `sendToClient` 메서드에 에러 핸들링이 들어가 있지만, 에러 발생 시 수행하는 로직이 단순히 `printStackTrace()`와 예외 발생뿐이라 좀 더 개선이 필요하다고 생각돼냥.

### 4. 확장성 및 모듈성
코드의 구조가 비교적 깔끔하게 유지되어 있어 확장성과 모듈성이 잘 이루어진 편이라고 볼 수 있나냥. `SseEmitter`와 같은 구조는 여러 차례 재사용될 수 있으므로, 이는 코드 확장 가능성을 높여준다고 생각해냥. `emitterRepository`와 `gitLabClient` 같은 외부 의존성은 잘 관리되고 있는 것 같아 좋다고 생각해냥.

### 5. 버그와 취약점
현재로서는 큰 버그나 취약점이 발견되지 않으나, `sendToClient` 메서드 내부에서 `SseEmitter`가 null인 경우에 대한 처리가 간단하므로 이 부분에 대한 추가 로깅이나 예외 처리 방식을 개선하면 좋을 것 같아냥. 이러한 실수가 발생했을 때 좀 더 디버깅이 용이해질 수 있겠지.

### 6. 테스트 가능성
테스트 가능성에 대해 살펴보았을 때, 현재 구조가 적절한 테스트 작성이 가능할 것으로 보이나, `notify` 및 `sendToClient` 메서드에 대한 단위 테스트가 반드시 필요하다는 생각이 드나냥. 의존성이 있는 외부 서비스에 대한 모킹(mocking) 적용을 통해 보다 안정적인 테스트가 가능할 것 같아.

### 7. 균형 잡힌 피드백
전반적으로 기능 변경은 긍정적이고 가독성 또한 좋아졌지만, 간혹 그로 인해 생길 수 있는 혼란을 최소화하기 위한 주석 추가를 권장하고 싶어냥. 코드를 잘 관리하고 업데이트함으로써 유지보수 비용을 절감할 수 있을 거라 생각하네냥.

요약하자면, 잘 구현된 부분이 많지만 더 나은 가독성과 안정성을 위해 추가적인 개선이 필요할 수 있으니 최대한 노력을 해보길 바라오냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:02:42.546915', 56, '2024-11-13 10:02:42.546915', 17, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 변경한 것은 비즈니스 로직의 일관성을 높이는 방향으로 보이지만, 이 부분의 의도와 사용 맥락에 대한 명확한 설명이 부족해 보인다냥. 이 변경으로 인해 기존의 `mrInfoId`에서 다른 데이터로 전환됨에 따라 관련된 다른 서비스에 영향을 줄 수 있으므로, 이 변경이 실제 로직과 어떻게 연결되는지를 확인하는 것이 중요하다냥. 

### 2. 가독성 및 유지보수성
변경 후의 변수명이 잘 설명되어 있어 가독성이 향상된 점은 긍정적이다냥. 그러나, `@RequestParam`의 이름도 변수명과 일치하도록 통일된 형태로 작성되어 있어야 하며, 더 간결하게 표현할 수 있는 여지가 있다냥. 또한, `notify` 메소드와 `sendToClient` 메소드에 대한 간단한 주석이 추가된다면 코드 이해에 도움이 될 듯하다냥. 과도한 중복 코드가 생성되지 않도록 주의하길 바라냥.

### 3. 효율성
현재 코드에서의 성능 이슈는 보이지 않지만, `sendToClient`에서 예외 상황에 대한 처리가 더 단단해 질 필요가 있다냥. 예를 들어, JSON 변환 에러가 발생할 경우 정해진 완료 작업이 없고, 그 과정에서 어떤 상황이 발생할 수 있는지 명확히 하는 것도 좋다냥.

### 4. 확장성 및 모듈성
코드가 기능별로 적절히 모듈화되어 있어 유지보수와 확장에 유리하다냥. 하지만, `SseService`에서 `EmitterRepository`와의 관계를 더 명시적으로 구분지어 문서화하면 후속 개발자들이 이해하는 데 더 도움이 될 것이다냥.

### 5. 버그와 취약점
현재 코드에서 특별한 버그가 발견되지는 않았으나, `sendToClient` 메소드의 IOException 처리 방식이 더 세밀하게 다루어질 필요성이 있다냥. 발생하는 여러 오류를 구체적으로 로깅하고 처리하는 것이 이후 문제 예방에도 중요하다냥.

### 6. 테스트 가능성
코드가 테스트하기 쉬운 구조로 잘 설계되어 있다냥. 특히, 각 메소드가 독립적이고, 테스트 환경에서 스스로 검증할 수 있는 부분이 많아 보인다냥. 다만, 각 메소드의 반환값과 변환 과정을 확실히 검증할 수 있는 테스트 케이스가 추가되면 좋겠다냥.

### 7. 균형 잡힌 피드백
각 변경 사항이 명확한 의도를 가지고 적용되어 있지만, 위험 요소를 최소화하고 코드가 장기적으로 시스템에 긍정적인 영향을 미칠 수 있도록 주기적인 점검과 리팩토링이 필요하다냥. 총체적으로 지속적인 관리와 개선이 필요하며, 잘 작성된 부분에 대해서는 인정을 보내고, 앞으로의 개선 방향을 제안하는 것이 좋겠다냥.

좋은 코드에 대한 긍정적인 마인드도 잊지 말아야 한다냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:20:12.920415', 57, '2024-11-13 10:20:12.920415', 19, '안녕하세요냥! 코드 리뷰를 시작할게요냥.

1. **기능적 정확성**: 
   변경사항에서 `lastReviewCreatedAt`을 추가하여 MR 리스트 조회 시 가장 최근 리뷰 생성일을 포함하도록 한 점은 좋았어요냥. 이 데이터가 실제로 필요하고 유용하게 사용될 것이라면 잘 맞춰진 기능이 될 것 같아 보이는군요냥. 다만 `findLatestReviewDateByGitlabMrIid` 메소드가 정상적으로 작동하지 않을 경우, null이 반환될 수 있음을 주의해야 해요냥. 이러한 경우에 대한 예외 처리가 필요할 것 같아요냥.

2. **가독성 및 유지보수성**: 
   전반적으로 코드의 가독성이 좋았어요냥. 특히, 메소드 이름이 이해하기 쉽게 잘 지어졌고, 각 변수의 이름도 직관적이라 유지보수하기 쉬워 보여요. 다만, `makeCodeReviewWhenCalledByWebhook` 메소드에서 기능이 많은데, 단계별로 주석을 추가하면 코드를 처음 보는 개발자들도 이해하기 쉬울 것 같아요냥.

3. **효율성**: 
   `mrInfoRepository.findLatestReviewDateByGitlabMrIid` 쿼리에서 `MAX`를 사용하는 건 효율적인 선택이에요냥. 그러나 이 메소드가 호출되는 맥락에서 매번 데이터베이스 쿼리를 날리는 것은 성능에 부담이 될 수 있겠네요냥. 데이터의 크기에 따라 성능 테스트를 해보아야 할 것 같아요냥.

4. **확장성 및 모듈성**: 
   코드가 잘 모듈화되어 있고, 각 메소드가 단일 책임 원칙에 따라서 잘 나뉘어져 있어요냥. 특히 `createGitlabMrResponse` 메소드에서 새로운 기능을 추가하는 것이 용이해 보이네요냥. 그러나 `ReviewResponse`와 같은 DTO가 점점 커지면서 나중에 관리가 어려워질 수 있기에, 관련된 데이터가 많아진다면 DTO를 세분화하는 것도 고려해 필요할 것 같아요냥.

5. **버그와 취약점**: 
   전반적으로 버그를 유발할 가능성이 적은 구조에요냥. 하지만, `findLatestReviewDateByGitlabMrIid` 쿼리의 결과가 null일 때를 처리하지 않고 있다면, 호출 측에서 NullPointerException이 발생할 수 있으니 이를 방지하기 위한 체크가 필요해 보이네요냥. 가능하다면 Optional을 활용하는 것도 좋은 방안이 될 수 있겠어요냥.

6. **테스트 가능성**: 
   코드가 주입 가능한 의존성을 잘 이용하고 있어, 단위 테스트 작성이 쉽도록 구성되어 있어 좋아요냥. 특히 각 서비스 메소드가 분리되어 있어 위에서 언급한 대로 독립적인 테스트가 가능해요냥. 하지만 `RedisGateway`와 같은 외부 종속성에 대한 테스트는 모의 객체(Mock)를 활용해야 할 필요가 있어 보이는군요냥.

7. **균형 잡힌 피드백**: 
   전체적으로 본 코드 변경은 신중하게 설계된 것 같고, 잘 동작할 가능성이 높아 보이네요냥. 그러나 잠재적인 null 반환이나 성능 문제를 고려하면 몇 가지 사항을 선제적으로 체크하는 것이 좋겠어요냥. 잘 구현된 부분들은 서비스 구조가 명확하고, 가독성이 뛰어나니 이러한 점들은 계속해서 유지해 주세요냥!

리뷰를 통해 향후 개선될 코드들이 더욱 쌓여가기를 기대할게요냥. 추가 질문이 있다면 언제든지 물어보세요냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 17:28:40.297227', 126, '2024-11-13 17:28:40.297227', 27, '### 코드 리뷰

#### 1. Readability (가독성)
- **잘 수행된 부분**: 변수명(`bgColor`, `textColor`, `fileName`)과 함수명(`NavButton`, `CommonReference`, `ReviewComment`)이 의미가 명확하여 읽는 사람이 쉽게 이해할 수 있습니다. JSX 요소의 클래스 이름 또한 의도를 명확하게 전달하고 있습니다.
- **개선 필요 부분**: 중복된 클래스 이름 사용이 있으며, 예를 들어, `border-2` 대신 `border-[1px]`와 같은 새로운 방식이 도입되었습니다. 코드의 일관성을 위해 한 방식으로만 사이즈를 정의하는 것이 좋습니다. 또한, 각 컴포넌트의 역할을 명시하기 위해 추가적인 주석을 포함하는 것도 좋겠습니다.

#### 2. Consistency (일관성)
- **잘 수행된 부분**: 동일한 스타일과 명명 규칙이 대부분의 컴포넌트에서 잘 유지되고 있습니다. 예를 들어, 특정 CSS 속성(`rounded-lg`, `border-primary-500`)들이 일관되게 사용되었습니다.
- **개선 필요 부분**: `border`의 스타일 정의 방식이 다소 혼란스럽습니다. `border-2`와 `border-[1px]`와 같은 다양한 방식이 혼합되어 있어 일관성이 떨어집니다. 스타일 정의 방식을 통일하여 코드의 가독성과 유지보수성을 높이는 것이 좋습니다.

#### 3. Reusability (재사용성)
- **잘 수행된 부분**: 각 컴포넌트는 독립적으로 잘 구성되어 있어 재사용이 가능합니다. 예를 들어, `ReviewComment`는 리뷰 주석을 처리하는 독립적인 컴포넌트로서 재사용이 가능합니다.
- **개선 필요 부분**: 컴포넌트의 Props 검증을 통해 더 견고한 재사용성을 확보할 수 있습니다. `PropTypes` 또는 TypeScript를 사용하여 Props의 타입을 정의하고 필수 여부를 설정하는 것이 좋습니다.

#### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 기본적인 동작이 의도대로 구현되어 있으며, UI 반응이 적절하고 간결합니다.
- **개선 필요 부분**: 예외 처리나 오류 검출을 위한 로직이 보이지 않아 안정성을 높이기 위해 추가적인 오류 처리 로직을 고려해보는 것이 좋겠습니다. 예를 들어, API 호출에 대한 에러 핸들링을 추가하면 좋을 것 같습니다.

#### 5. Security (보안성)
- **잘 수행된 부분**: CSS와 JSX 코드에 직접적으로 보안 관련 문제는 발견되지 않았습니다.
- **개선 필요 부분**: 외부 데이터나 사용자의 입력을 처리하는 로직에서 적절한 입력 검증과 방어 코드를 구현하는 것이 중요합니다. XSS(Cross-site Scripting) 같은 공격을 방지하기 위해 사용자 입력을 적절히 이스케이프 또는 검증하는 로직을 추가하는 것이 좋습니다.

#### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 컴포넌트 구조가 잘 분리되어 있어 유지보수가 용이합니다. 또한, 각 함수와 변수가 명확하게 정의되어 있어 이해하기 쉽습니다.
- **개선 필요 부분**: 컴포넌트의 수가 많아지므로, 폴더 구조 및 파일명을 적절히 구성하여 가독성을 높이는 것이 좋습니다. 예를 들어, 비슷한 기능을 하는 컴포넌트들을 같은 폴더에 묶거나, 관련된 CSS를 함께 관리하면 유지보수성이 향상됩니다.

### 전체적인 피드백
- **잘 수행하고 있는 부분**: 각 컴포넌트가 독립적으로 잘 설정되어 있고, 직관적으로 읽을 수 있는 코드입니다. 변수명과 스타일이 명확하여 이해하기 쉽고, 다양한 컴포넌트에 대한 재사용성이 높습니다.
- **개선이 필요한 부분**: 코드 일관성, 예외 처리, 보안적인 측면에서 보완이 필요합니다. 특히, CSS 클래스와 스타일 방법의 통일성을 유지하고, 필요한 곳에는 주석을 추가하여 코드를 더 명확히 하는 것이 좋겠습니다. 

이러한 개선 피드백을 바탕으로 코드를 수정해 나가면, 전체적인 품질과 유지보수성이 더욱 향상될 것입니다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 17:36:22.272193', 127, '2024-11-13 17:36:22.272193', 28, '안녕하세요! 고양이 같은 말투로 리뷰를 해드릴게요~ 🐾

### 1. Readability (가독성)
코드는 전반적으로 잘 이해할 수 있는 편이에요~ 색상 파일 수정과 관련된 부분도 의미가 분명하게 드러나고, 작성한 코드에서 색상의 이름이 잘 지어졌어요. 
- **개선점**: 변수와 상수 이름들을 더 설명적으로 바꾸면 좋을 것 같아요. 예를 들어 `navy`와 같은 색상 이름은 조금 더 구체적인 맥락을 담으면 좋겠네요. 간단한 주석을 추가하면 더 좋을 것 같아요~ `// Navy 색상` 같은 설명도 도움이 될 거에요!

### 2. Consistency (일관성)
코드 스타일은 괜찮은 것 같지만, 색상값의 대소문자 사용에서 일부 일관성이 없네요.
- **개선점**: `navy` 색상 변경 시 뒷부분의 색상값들을 어떻게 표기했는지 일관되게 하는 것이 좋겠어요. 예를 들어, 다른 색상값도 대문자로 쓴다면 다 동시 대응하는 게 좋겠죠?

### 3. Reusability (재사용성)
이번 변경사항에서는 독립적인 기능 단위로 색상을 설정하고 있어서 재사용성 면에서 괜찮아요~ 다만, 추가된 `secondary2` 색상도 다른 파일에서 사용 가능하게 하려면, 혹시 이를 더 일반화된 구조에서 관리할 수 있다면 좋겠어요.
- **개선점**: 다양한 장소에서 사용할 수 있도록 색상 구성 요소를 별도의 파일로 분리하면 좋을 것 같아요. 이렇게 하면 중복을 줄이고, 관리하기도 쉽겠죠?

### 4. Reliability (신뢰성)
코드가 의도대로 잘 작동할 것으로 보이긴 해요~ 하지만 실제 사용 시 어떤 결과가 나올지 런타임에서 확인하는 게 필요할 것 같아요.
- **개선점**: 색상 관련 값들이 앱에서 어떻게 적용되는지를 테스트할 수 있는 유닛 테스트를 추가하면 좋겠어요! 이를 통해 앞으로의 변경에도 안심할 수 있겠죠.

### 5. Security (보안성)
현재로선 이 코드가 보안에 직접적인 영향을 주는 부분은 없어 보여요~ 하지만 색상 값 자체는 사용자 입력을 받아들이는 분야는 아니니 이 부분은 그렇게 걱정하지 않으셔도 되겠네요.
- **개선점**: 하지만 만약 색상이 아닌 다른 중요한 정보가 추가된다면, 향후 보안 검토를 잊지 않는 것이 좋겠어요~ 따라서 이런 경우에는 입력 검증을 잊지 말아주세요🐱 

### 6. Maintainability (유지보수성)
변경된 부분은 간단하고 직관적이어서 유지보수성도 괜찮아 보여요. 하지만 한 등록된 색상 파일 내에서 관리가 계속된다면 추후 걸리적거릴 수 있어요.
- **개선점**: 만약 색상 파트를 별도의 모듈로 분리한다면, 관리하기도 쉽고 필요한 부분에서 수정이 용이할 거에요. 사용할 때마다 단일 책임 원칙을 지킬 수 있을 것 같아요~ 

### 전체적인 피드백
- 잘된 점: 코드가 직관적이고 색상 값들이 잘 정의되어 있어 가독성이 높아요. 전체적인 구조 역시 깔끔하게 잘 작성됐어요~ 
- 개선이 필요한 점: 색상 관리 부분의 일관성과 재사용성을 높이기 위해 별도의 파일로 분리하는 것을 고려해보세요. 또한, 주석을 추가하면 더욱 이해하기 쉬운 코드가 될 거에요. 

이런 피드백이 도움이 되었으면 좋겠어요~ 앞으로도 더 멋진 코드 기대하고 있을게요! 🐾💻
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 10:21:50.24329', 58, '2024-11-13 10:21:50.24329', 18, '## 코드 리뷰

### 1. 기능적 정확성
변경된 코드에서 예외 처리를 강화한 부분은 긍정적이고, `RuntimeException` 대신 `BusinessException`을 사용하여 더 구체적인 오류 처리가 가능하도록 한 점이 마음에 들어요. 그러나 `findReview`가 `null`일 가능성을考慮하지 않은 코드에서 아직도 잠재적인 `NullPointerException`이 발생할 수 있으니, `findReview`가 `null`일 경우에 대한 처리가 필요해 보인답니다.   

### 2. 가독성 및 유지보수성
코드의 가독성은 전반적으로 좋지만, 에러 핸들링 부분에서 `e.printStackTrace()`를 모두 삭제하고 `BusinessException`을 활용한 점은 잘 처리된 부분이에요. 오류 메시지 또한 코드의 맥락에 맞게 변경하였고, 이는 가독성을 더욱 높이는 데 기여했답니다. `log.error` 메시지도 `reviewId`로 구체화하여, 문제 발생 시 더 쉽게 추적할 수 있게 되었어요. 그러나 예외 처리에서 `BusinessException`이 발생하는 상황과 그에 대한 로그 기록을 추가하면 유지보수가 더욱 용이할 것 같아요.

### 3. 효율성
새로 추가된 `findFirstByMrInfoOrderByCreatedDateAsc` 메서드는 효율적으로 리뷰를 조회하고, 이전의 방식보다 성능이 향상된 것 같아요. 이로 인해 이후의 논리가 더욱 간결해질 수 있어서 긍정적으로 평가해줄 수 있어요. 

### 4. 확장성 및 모듈성
모듈성 및 확장성 측면에서, `BusinessException`을 사용하여 예외를 관리하는 방법은 코드의 변경이 필요할 때 유리하게 작용해요. 다만, 특정 예외에 대한 처리 방식이 코드 전체에 일관되지 않다면, 나중에 시스템이 커졌을 때 유지보수의 어려움이 있을 수 있으니, 예외 클래스에 대한 정리를 고려해보는 것도 좋아요.

### 5. 버그와 취약점
`findReview` 변수가 `null`일 경우 처리되지 않는 점은 분명히 한 가지 우려 요소로 남아있어요. 또한, `notify` 메서드 호출 시 문제가 발생할 수 있으니, 위에서 언급한 `null` 체크와 함께 에러 처리 로직을 추가하는 것을 권장해요.

### 6. 테스트 가능성
전체적으로 코드의 구조가 주입할 수 있는 의존성을 잘 유지하고 있어 테스트 가능성이 높은 편이에요. 특히, 예외 처리를 코드에서 분리해서 관리함으로써 테스트 작성 시 테스트 가능한 경로가 더욱 명확해진 점은 칭찬할 만 해요.

### 7. 균형 잡힌 피드백
변경 사항 중 로그인 관련 에러 처리가 강화된 점은 훌륭한 개선으로 보이며, 이는 코드의 robustness를 높여줘요. 반면, `findReview`의 null 체크 미비와 추가적인 예외 로깅 구현은 보완이 필요하다고 평가해볼 수 있어요. 장기적으로 코드 품질이 향상될 수 있도록 한두 가지에 대한 개선 제안을 고려해보면 좋을 것 같아요. 

총평하자면, 많은 발전이 있었으며, 몇 가지 추가적인 개선이 이루어진다면 정말 멋진 코드가 될 수 있을 것 같아요! ❗');
INSERT INTO public.review VALUES ('2024-11-13 10:23:16.993607', 59, '2024-11-13 10:23:16.993607', 18, '안녕하세요, 코드 리뷰를 맡게 된 리뷰어입니다. 냥! 코드 변경 사항에 대해 심도 있게 평가해 보겠습니다.

### 1. 기능적 정확성
변경된 코드에서 예외 처리를 구체화하고, `BusinessException`을 사용하여 세부적인 오류 처리를 명확히 한 점은 긍정적입니다. 이를 통해 함수의 오류 발생 시 처리 로직이 더 견고해질 것입니다. 다만 `reviewRepository.findFirstByMrInfoOrderByCreatedDateAsc(mrInfo)` 부분이 예상대로 작동하는지는 테스트가 필요할 것 같습니다. 만약 `mrInfo`에 해당하는 리뷰가 존재하지 않을 경우에 대한 처리가 빠져 있어, NullPointerException이 발생할 수 있는 가능성을 염두에 두어야 합니다, 냥.

### 2. 가독성 및 유지보수성
전체적으로 변수명 및 메서드명이 명확하여 가독성이 좋습니다. 특히, `findReview`라는 변수명은 무엇을 찾는지 분명하게 나타내줍니다. 하지만 예외 메시지는 i18n (국제화)의 관점에서 외부화하는 것이 더 나은 가독성을 제공할 수 있습니다. 이를 통해 코드의 유지보수성을 높일 수 있을 것입니다, 냥.

### 3. 효율성
효율성 면에서는 `findFirstByMrInfoOrderByCreatedDateAsc`가 필요할 경우에만 호출되도록 로직을 추가하면 성능 향상에 도움이 될 것 같습니다. 현재 로직은 각 호출마다 리뷰를 찾으므로 성능 상의 문제가 발생할 수 있습니다, 냥. 만약 리뷰 검색이 잦아지면 이 부분을 최적화하는 리팩토링이 필요할 수 있습니다.

### 4. 확장성 및 모듈성
변경된 코드에서 비즈니스 로직을 분리하고 예외 처리를 추가한 부분이 매우 좋습니다. 코드가 모듈화되어 있어 향후 기능 추가에 상당히 유리한 구조입니다. 그러나, 예외 처리를 추가할 때 구체적인 예외 상황을 더 정의하는 것이 확장성을 높여줄 것으로 보입니다, 냥.

### 5. 버그와 취약점
변경 사항에서 특정 예외를 더 명확히 하고 처리하는 방식이 개선된 것은 긍정적입니다. 하지만 `reviewRepository.findFirstByMrInfoOrderByCreatedDateAsc`에서 리턴값이 null일 때 적절한 처리가 추가되지 않은 것처럼 보입니다. 이 부분은 분명히 개선이 필요합니다, 냥.

### 6. 테스트 가능성
전반적으로 테스트 가능한 구조를 잘 유지하고 있습니다. 메서드의 구성 및 예외 처리 방식이 명확하여 단위 테스트를 통해 각 기능에 대한 검증이 용이합니다. 다만 Exception 처리에 대한 테스트가 반드시 필요할 것 같습니다. `BusinessException` 발생 시의 테스트 케이스도 추가해 보시는 것을 권장합니다, 냥.

### 7. 균형 잡힌 피드백
전반적인 코드 품질 개선을 위한 노력은 긍정적입니다. 특히, 예외 처리의 구체화와 같은 개선 사항은 확실히 코드의 이해도와 안정성을 높여줄 것입니다. 그러나, NullPointerException과 같은 잠재적인 문제를 예방하기 위해 추가적인 확인 로직을 도입하는 것이 중요합니다. 이는 장기적인 유지보수 및 안정성에 긍정적인 영향을 미칠 것입니다, 냥.

이상으로 코드 리뷰를 마치겠습니다. 앞으로도 좋은 코드 계속 기대할게요! 감사합니다, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:27:42.876731', 60, '2024-11-13 10:27:42.876731', 20, '안녕하세요, 냥냥체로 코드 리뷰 시작할게요, 냥!

1. **기능적 정확성**: 변경된 `GitlabMrResponse.of` 메서드에서 `id`, `iid`, `title`의 값 계산이 잘못된 것 같아, `/ 0` 연산은 나누기 0으로 예외를 발생시킬 가능성이 크고, `* 10`은 의도치 않은 값으로 변경될 수 있으니 수정이 필요해요, 냥. 이러한 변경으로 인해 응답이 올바르게 만들어지지 않을 수 있으니 주의해야 해요, 냥.

2. **가독성 및 유지보수성**: 한국어를 사용하는 것이 좋은 생각이지만, 변수명을 영어로 사용하는 것이 좋을 것 같아. 예를 들어, `프로젝트_이름`과 `풀패스`는 `name`과 `fullPath`로 유지하는 게 코드의 일관성에 좋을 것 같아. 가독성에도 도움이 되고 다른 개발자들이 이해하기 쉬울 거야, 냥.

3. **효율성**: `mergedAt`, `createdAt`, `updatedAt`, `closedAt`의 필드를 `toLocalDateTime()`으로 변환하는 부분이 사라졌는데, 이로 인해 데이터 형식에 맞지 않아 문제가 생길 수 있으니 이 부분은 검토가 필요해, 냥. 단순히 값을 저장하는 것으로 변경하여 성능을 원활하게 유지하는 것은 좋지만, 의미를 잃지 않도록 주의해야 해요, 냥.

4. **확장성 및 모듈성**: 현재 구조는 나쁘지 않지만, 이러한 메서드가 여러 곳에서 사용될 경우, 각기 다른 데이터 형식에 대해 유연하게 대처할 수 있도록 리팩토링하면 좋을 것 같아. 예를 들어, 데이터를 적절히 처리하는 유틸리티 클래스를 만들면 좋을 것 같아, 냥.

5. **버그와 취약점**: 위에서 언급한 나누기 0 문제는 실시간 시스템에서 특히 크리티컬할 수 있어 즉시 수정해야 해, 냥. 이런 작은 실수가 큰 오류로 이어질 수 있으니 항상 주의 깊게 보자고, 냥.

6. **테스트 가능성**: 현재 메서드에서의 변경된 부분은 테스트가 어려워질 수 있어, 특히 계산이 포함된 부분은 테스트 케이스가 필요할 거야. 더 철저한 테스트를 위해, 각 반환 값을 모의하여 테스트하는 구조를 고려해 보면 좋을 것 같아, 냥.

7. **균형 잡힌 피드백**: 전체적으로 기능을 확장하려는 방향은 좋지만, 코드의 의미나 의도된 동작을 유지하는 것이 중요해. 문제를 해결하기 위해서는 세심한 조정이 필요할 것 같아, 냥! 잘 구현된 부분과 주의해야 할 부분을 모두 고려해서 발전해 나가길 바라, 냥!

코드 개선을 위해 꼭 필요한 수정사항들이니 신경 써서 작업해 주면 좋겠어, 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.239937', 244, '2024-11-18 11:32:46.239937', 61, '`findByUsername` 메소드를 추가한 점이 좋지만, `getByUsername` 메소드에서 `BusinessException`을 던지는 부분에 대해 보다 구체적인 에러 메시지를 제공하는 것이 좋습니다. 예를 들어, 어떤 사용자가 존재하지 않는지 명시하는 것이 사용자에게 더 유용할 것입니다. 또한, 메소드를 더 명확하게 하는데 도움이 되도록 Javadoc 주석을 추가하는 것도 고려해보세요.');
INSERT INTO public.review VALUES ('2024-11-13 10:36:50.107187', 63, '2024-11-13 10:36:50.107187', 18, '안녕하세요, 코드 리뷰를 맡게 된 리뷰어입니다냥! 아래에서 각 항목별로 자세하게 검토한 내용을 전달할게요냥.

1. **기능적 정확성**:
   - 변경된 코드에서 `SseService`의 예외 처리 부분이 `RuntimeException`에서 `BusinessException`으로 변경되었는데, 이는 예외 처리를 좀 더 명확하게 해줍니다냥. 그러나 `BusinessException`의 경우는 발생할 수 있는 다양한 상황을 고려해 적절하게 처리해야 할 것 같아요냥. 예외의 의미에 대한 주석이나 문서화가 필요하지 않을까 싶어요냥.

2. **가독성 및 유지보수성**:
   - `saveRetrievals`와 같은 메서드는 함수형 스타일로 잘 작성되어 있어 가독성이 좋았어요냥. 특히, 스트림을 사용한 리스트 변환은 현대적인 자바의 특징을 잘 살리고 있어서 긍정적으로 평가할 만 해요냥. 그러나 일부 변수명은 의미가 조금 애매할 수 있으니, 좀 더 직관적인 이름으로 변경하면 좋을 것 같아요냥.

3. **효율성**:
   - `reviewRepository.findFirstByMrInfoOrderByCreatedDateAsc(mrInfo)`와 같은 쿼리는 효율적으로 설계된 것 같아요nancy. 데이터베이스 성능에 긍정적인 영향을 미칠 것으로 판단됩니다냥. 다만, 쿼리가 복잡해질 경우에는 쿼리 성능을 지속적으로 모니터링하는 것이 필요할 것 같아요냥.

4. **확장성 및 모듈성**:
   - `ErrorCode` 열거형의 변경은 잘 생각한 결정인 것 같아요냥. 이는 에러 코드 관리에 있어 더욱 일관성과 확장성을 부여할 것으로 기대됩니다냥. 하지만 이 에러 코드와 관련된 문서화가 잘 이루어진다면, 코드를 이해하는 데 더 불편함이 없을 것 같아요냥.

5. **버그와 취약점**:
   - `SseService`에서 예외 발생 시 로그를 찍는 부분이 잘 되어 있습니다냥. 하지만 에러 메시지가 로그에만 남고 사용자에게는 보여지지 않기 때문에, 사용자에게 필요한 정보를 전달할 수 있는 방안을 고려하면 좋겠어요냥.

6. **테스트 가능성**:
   - 전반적으로 의존성이 줄어들게 리팩토링된 것으로 보여, 유닛 테스팅이 수월할 것 같다는 생각이 드네요냥. 특히, `Review` 및 `ReviewResponseMessage`와 같은 DTO 클래스들은 테스트에 용이할 것 같아요냥.

7. **균형 잡힌 피드백**:
   - 전반적으로 잘 작성된 코드지만, 예외 처리 부분이나 메서드 명명에 있어 다소 개선의 여지가 보인다는 점을 강조하고 싶어요냥. 그 외에 코드 전체적으로 가독성이 뛰어나고 잘 구조화되어 있다는 점은 칭찬할 만합니다냥.

리뷰가 도움이 되었으면 좋겠어요냥! 필요하면 추가적인 질문도 해주시면 감사할게요냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:38:02.438138', 64, '2024-11-13 10:38:02.438138', 21, '안녕하세요, 코드 리뷰를 진행할게요 냥!

### 1. 기능적 정확성
변경된 코드에서 `id`와 `iid`를 각각 0으로 나누고, `title`에 10을 곱하는 등의 연산을 추가했어요 냥. 이러한 연산은 명백하게 예외를 발생시키거나 의미가 없기 때문에, 코드의 의도와는 다르게 동작할 수 있어요 냥. 이 부분은 즉각적인 수정이 필요해 보이네요 냥. 기능적 정확성을 보장하려면 올바른 값을 그대로 반환해야 해요 냥.

### 2. 가독성 및 유지보수성
변경된 변수명인 `프로젝트_이름`과 `풀패스`는 한국어로 변환되어 가독성을 일정 부분 높이고 있어요 냥. 그러나 영어를 사용하는 코드 베이스에서는 일관성이 떨어질 수 있으니, 규칙을 정하고 팀원들과 상의해 결정하는 것이 좋을 것 같아요 냥. 가독성을 해치지 않으면서 유지보수성을 높이기 위해, 일관된 명명 규칙을 유지하는 것이 중요해요 냥.

### 3. 효율성
업데이트된 `mergedAt`, `createdAt`, `updatedAt`, `closedAt` 필드의 처리가 이전과 동일하게 유지되고 있어 좋았어요 냥. 하지만 다른 부분에서 불필요한 연산을 추가하였기 때문에 전반적인 코드 효율성이 저해될 수 있어요 냥. 이러한 연산들은 제거하는 것이 좋겠어요 냥.

### 4. 확장성 및 모듈성
변경된 내용에서는 확장성을 해치는 요소가 보이지 않아요 냥. 다만, 코드에서 가독성과 모듈성을 유지하기 위해 관련된 로직을 적절히 나누고, 재사용 가능한 메서드로 분리함으로써 더 나은 확장성을 가질 수 있도록 하는 것이 좋겠어요 냥.

### 5. 버그와 취약점
코드 변경으로 인해 발생할 수 있는 잠재적인 오류가 모호하게 보이고 있어요 냥. 특히 나누기 연산자(`/`)와 곱하기 연산자(`*`)를 사용해서 값을 처리하는 부분에서 예외가 발생할 가능성이 높아요 냥. 이러한 부분을 사전 검증하는 로직을 추가하는 것이 좋겠어요 냥.

### 6. 테스트 가능성
현재 구조는 단위 테스트를 작성하는 데 다소 어려울 수 있어요 냥. 특히 의존성으로 인해 외부 API 호출이 많은 부분은 Mocking 처리 없이 테스트하기 어려울 수 있겠네요 냥. 각 메서드의 반환값이 일정하면 테스트 가능성을 높일 수 있도록 리팩토링하는 방향으로 생각해보세요 냥.

### 7. 균형 잡힌 피드백
전반적으로 가독성을 돕는 변경 부분은 좋았지만, 비효율적이거나 오류를 초래할 수 있는 부분은 취약성이 있다고 판단해요 냥. 다양한 시나리오에서 코드가 의도한 대로 정확하게 동작하도록 보장하는 것이 중요해요 냥. 구체적이고 명확한 반환값이 필요하니, 안정성을 고려한 코드를 작성해보세요 냥.

전반적으로 코드를 잘 반영하셨지만, 일부 요소는 수정이 필요해요 냥. 추가적인 질문이나 논의가 필요하면 언제든지 말씀해 주세요 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 10:38:45.909676', 65, '2024-11-13 10:38:45.909676', 18, '안녕하세요 냥! 코드 리뷰를 진행했어요 냥. 변경된 내용에 대해 각각의 항목별로 평가해 드릴게요 냥.

### 1. 기능적 정확성
코드 변경 사항에서 예외 처리 부분을 개선한 것은 좋았어요 냥. `RuntimeException`을 `BusinessException`으로 교체하여 구체적인 오류 코드를 추가한 점은 안정성이 높아졌다고 볼 수 있어요 냥. 이를 통해 예외 발생 시 더 명확한 정보를 제공할 수 있게 되었어요 냥. 변경된 `sseService.notify()` 부분도 적절한 변경으로 보이네요 냥.

### 2. 가독성 및 유지보수성
코드의 전반적인 가독성이 개선되었어요 냥. 특히 `ErrorCode`에 대한 주석을 추가하고 이름을 변경한 것이 맥락을 명확하게 해 주었어요 냥. 하지만, `sseService.notify` 부분에서 `findReview` 변수를 사용한 부분은 조금 모호하게 느껴질 수 있어요 냥. `findFirstReview`와 같이 좀 더 구체적인 이름을 사용하는 것이 좋을 것 같아요 냥.

### 3. 효율성
리포지토리 메서드에서 최근 리뷰를 가져오는 방식으로 변경한 것은 효율성을 고려한 측면이 돋보였어요 냥. 기본적으로 가장 최근 리뷰를 가져오는 것은 데이터를 효율적으로 처리할 수 있는 방법이니 긍정적으로 평가해요 냥.

### 4. 확장성 및 모듈성
코드가 단일 책임 원칙을 잘 준수하고 있어 모듈화가 잘 되어 있는 것 같아요 냥. 하지만, `sseService`의 메서드가 여러 책임을 담당하고 있다면 다음 단계에서 분리하는 것도 고려해 보는 것이 좋을 것 같아요 냥.

### 5. 버그와 취약점
예외 처리를 제대로 해준 점은 좋지만, 여전히 `BusinessException`의 처리가 필요할 것 같아요 냥. 현재 코드 내에서 예외 발생 시 로그만 남기고 적절한 조치가 이루어지지 않는 부분이 있다면, 그 부분을 보완하면 좋겠어요 냥.

### 6. 테스트 가능성
변경된 부분이 테스트하기 쉬운 구조로 되어 있어 보이네요 냥. 특히 예외 처리 방식이 명확해졌기 때문에, 테스트 케이스 작성 시 유용할 것 같아요 냥. 하지만 효율적인 테스트를 위해 이전 메서드들도 포함하는 전체적인 구조를 검토하는 것이 중요해요 냥.

### 7. 균형 잡힌 피드백
변경 사항이 전반적으로 코드의 품질을 높이고 예외 처리를 강화한 것은 긍정적이에요 냥. 다만, 앞으로의 리팩토링에서는 코드의 복잡성을 줄이고 명확한 네이밍 컨벤션을 유지하면서 가독성을 더욱 개선할 수 있도록 노력하면 좋겠어요 냥.

전반적으로 전체 코드에서 개선된 부분이 많아 긍정적이라고 생각해요 냥! 앞으로도 좋은 코드 계속해서 작성해 주세요 냥!');
INSERT INTO public.review VALUES ('2024-11-18 10:30:27.802354', 218, '2024-11-18 10:30:27.802354', 57, '코드 개선을 위한 몇 가지 제안을 드립니다:

1. `data` 변수를 사용하기 전에 `response.data`가 유효한지 먼저 체크하는 로직을 추가하면 더 안전하게 데이터를 처리할 수 있습니다.
2. Avatar 이미지 렌더링 부분에서 `?` 연산자를 사용하여 null 체크를 했지만, 이를 별도의 컴포넌트로 분리하면 코드의 가독성이 향상될 수 있습니다.
3. `created {mr.closedAt}` 코드를 사용할 때, `mr.closedAt`의 형식을 포맷팅해서 사용자에게 더 친숙한 형태로 보여주는 것이 좋습니다. 

이러한 개선점을 통해 코드의 안정성과 가독성을 높일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-13 10:44:37.229651', 66, '2024-11-13 10:44:37.229651', 18, '안녕하세요, 냥! 코드 리뷰를 시작할게요, 냥!

### 1. 기능적 정확성
변경된 코드에서 예외 처리 부분이 개선되었고, 잘못된 JSON 포맷에 대해 `RuntimeException` 대신 `BusinessException`을 던지도록 수정된 부분이 좋았어, 냥. 하지만 `handleEvalResponse` 메서드에서는 JSON 파싱 또는 데이터 처리에 대한 예외를 처리하지 않고 있어, 냥. 이곳도 같은 패턴으로 예외를 처리하는 것이 좋을 것 같아, 냥.

### 2. 가독성 및 유지보수성
가독성 측면에서 리팩토링이 일부 이루어진 점은 긍정적이야, 냥! 특히 `@ServiceActivator` 및 `@Transactional`을 통해 메서드에 대한 명확한 취지를 전달한 부분이 좋아. 하지만 몇몇 메서드의 길이가 다소 길어 보이므로, 추가적인 로직을 분리해 주별로 모듈화하면 더 가독성이 좋을 것 같아, 냥.

### 3. 효율성
효율성 측면에서 `handleReviewResponse` 메서드에서 `getById` 메서드를 두 번 호출하는 부분이 있어, 순전히 데이터의 중복 호출을 피하기 위해 `mrInfo`를 한 번만 호출하고 해당 데이터를 변수에 저장하면 성능이 개선될 수 있어, 냥. 

### 4. 확장성 및 모듈성
`ErrorCode` enum에 새로운 오류 코드를 추가한 것이 좋았어, 냥. 이처럼 특정 도메인에 대한 오류를 잘 정의하면 코드의 모듈성과 확장성이 높아지게 돼. 코드가 더욱 명확하고 외부 API와의 상호작용에서 발생할 수 있는 이슈에 대해 명시적으로 처리하는 습관이 필요해, 냥.

### 5. 버그와 취약점
코드에서 `JsonProcessingException`을 처리할 때 그냥 `RuntimeException`을 던지는 경우는 좋은 패턴이 아니야, 냥. 구체적인 예외로 변경했으면 좋겠어, 냥. 이렇게 하면 고객이나 사용자에게 더 유용한 에러 정보를 전달할 수 있어, 냥. 특히 API의 경우 잘못된 요청에 대해 적절한 에러 메시지를 주는 것이 중요해, 냥.

### 6. 테스트 가능성
테스트 작성이 용이해 보이지만, 데이터베이스 호출이 많이 포함된 비즈니스 로직이 테스트하기 어려울 수 있어, 냥. Mocking을 통해 의존성을 줄이고 각 모듈을 독립적으로 테스트할 수 있는 구조로 개선하는 것이 좋겠어, 냥.

### 7. 균형 잡힌 피드백
전반적으로 코드 개선이 이루어지고 있고, 예외 처리가 더 명확해져서 긍정적이야, 냥. 하지만 중복 메서드 호출과 같은 세부적인 최적화가 필요하다는 점을 기억해 줘, 냥. 또한, 테스트 용이성 향상 및 코드 길이 조절을 통해 가독성을 더욱 높일 수 있어, 냥.

이상으로 리뷰를 마치겠어, 냥! 적극적인 개선이 이루어져서 좋았고, 이 코드가 앞으로 더 발전되길 바라, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:45:39.162778', 67, '2024-11-13 10:45:39.162778', 18, '코드 리뷰를 시작할게 냥!

### 1. 기능적 정확성
- `SseService`의 `send` 메서드에서 예외 처리 부분이 Enhanced 되었어. 이전에는 `RuntimeException`을 사용했지만, 이제는 구체적인 `BusinessException`을 던지도록 변경되었어. 이는 코드의 명확성을 높이는 좋은 선택이야 냥.
- `ReviewService`에서 `reviewRepository.findFirstByMrInfoOrderByCreatedDateAsc`로 가장 오래된 리뷰를 가져오는 것으로 변경된 것도 좋은 아이디어야. 하지만 `findReview`가 null일 가능성도 고려해줘야 할 것 같아 냥.

### 2. 가독성 및 유지보수성
- 메서드 간 로직의 분리가 잘 되어 있어 가독성이 높아. 특히, `saveRetrievals` 메서드와 `regenerateReview` 메서드의 구조가 명확해 유지보수하기 좋을 것 같아 냥.
- `ErrorCode` enum의 주석이 변경된 것도 좋지만, 필요한 경우 추가적인 설명이 있을 수 있으면 더 좋을 거 같아 냥.

### 3. 효율성
- `ObjectMapper`와 같은 객체는 비싼 성능을 요구하니까, 필요할 때만 생성하여 사용하도록 수정하면 더욱 효율적일 수 있어. 가능하다면 의존성 주입으로 관리해보는 것도 좋을 것 같아 냥.
- 데이터베이스에서 조회 시, `findFirstByMrInfoOrderByCreatedDateAsc`를 사용할 때, 성능이나 인덱싱에 대해서도 고려하면 좋겠어 냥.

### 4. 확장성 및 모듈성
- 전반적으로 코드의 모듈성이 좋은 편이야. 기능이 잘 나눠져 있어 한 부분의 변경이 전체에 미치는 영향을 최소화할 수 있겠어 냥.
- 그러나 코드를 확장할 시 각 오류 코드에 대한 처리 방식이 추가될 가능성이 있어. 이때 확장성을 위해 공통적인 예외 처리 메커니즘을 도입하는 것도 고려해보는 것이 좋을 것 같아 냥.

### 5. 버그와 취약점
- `handleEvalResponse` 메서드에서 JSON 파싱 오류가 발생할 경우에 대한 처리가 필요해 보여. 로그를 찍더라도 사용자가 인지할 수 있는 방식으로 에러 핸들링을 고려해야 해 냥.
- `subscribe` 메서드에서 Emitter가 존재하지 않을 경우의 로깅은 좋지만, 이 시나리오에 대한 적절한 예외 처리가 부족해 보여. 이 부분도 점검해보면 좋겠어 냥.

### 6. 테스트 가능성
- 메서드가 컴팩트하게 잘 나누어져 있어서 테스트하기 쉬워 보여. 각 기능이 하나의 책임을 가지도록 잘 구성되어 있어 냥.
- 다만, `saveRetrievals`와 같이 데이터베이스와 연동하는 부분에 대한 유닛 테스트가 적절히 수행될 수 있도록 목(Mocking) 객체를 사용하는 등에 대한 방안을 고려해보면 더 좋을 것 같아 냥.

### 7. 균형 잡힌 피드백
- 대체적으로 기능이 정확하고, 예외 처리에서도 개선이 많이 이루어졌어. 코드 구조도 개선되어 가독성과 유지보수성이 높아졌기에 긍정적인 평가를 주고 싶어 냥.
- 다만, 예외 처리와 관련하여 좀 더 개선이 필요해 보이며, 코드의 성능 측면에서 예외적인 상황을 고려하는 방향도 가져가면 좋을 것 같아. 이런 부분을 통해 시스템의 안정성을 한층 높일 수 있을 것 같아 냥.

코드 리뷰가 모두 끝났어 냥! 향후 변경 사항에 대해서도 필요시 다시 피드백을 줄 수 있으니, 추후에도 문의해줘 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:49:23.110382', 68, '2024-11-13 10:49:23.110382', 18, '안녕하세요, 코드 리뷰를 진행해 보도록 할게요, 냥!

### 1. 기능적 정확성
변경된 코드가 전반적으로 필요한 요구사항을 충족하고 있는 것 같아요, 냥. 예외 처리가 추가되어 오류를 구체적인 비즈니스 예외로 변경하며, 이를 통해 문제 발생 시 명확하게 어떤 오류인지 이해할 수 있을 것 같아요. 특히 `BusinessException`을 통해 잠재적인 오류를 더 잘 관리할 수 있게 되었네요, 냥. 하지만, `findFirstByMrInfoOrderByCreatedDateAsc` 메서드를 호출할 때, `mrInfo`가 null일 경우에 대한 방어 코드는 필요할 듯해요, 냥.

### 2. 가독성 및 유지보수성
가독성이 개선된 부분이 많아요, 냥! 예를 들어, `ErrorCode`에 대한 주석이 명확하게 수정되었고, 코드의 각 부분이 무엇을 하는지 더 잘 이해할 수 있게 되었어요, 냥. 로그 메시지 또한 `reviewId`를 사용할 때 더 명확하게 바뀌었으니 유지보수성도 좋아졌다고 생각해요, 냥. 다만, 같은 종류의 예외 처리 루틴이 반복되는 부분에서 공통된 메서드로 분리하면 더 깔끔해질 것으로 보여요, 냥.

### 3. 효율성
전반적으로 성능에 큰 영향을 미치는 비효율적인 부분은 없었어요, 냥. 그러나, `findFirstByMrInfoOrderByCreatedDateAsc`의 경우 데이터를 찾기 위해 완전한 검색이 필요할 수 있으므로, 인덱스가 설정되어 있는지 확인해볼 필요가 있을 것 같아요, 냥. 이렇게 하면 쿼리 성능이 더 개선될 수 있겠죠, 냥.

### 4. 확장성 및 모듈성
코드가 잘 모듈화되어 있어서 확장성이 높아요, 냥. 각 기능을 담당하는 메서드가 잘 나뉘어져 있고, 향후 다른 예외 처리나 로직 추가에도 유연하게 대응할 수 있을 것으로 보여요, 냥. 하지만, `SseService`의 예외 처리 부분은 더 일반화할 수 있는 여지가 있을 것 같아요, 냥.

### 5. 버그와 취약점
로그 메시지에서 `reviewId`가 아닌 `id`를 사용했던 부분이 수정된 것이 긍정적이에요, 냥. 이에 따라 나중에 로그를 분석할 때 더 효율적일 것 같아요, 냥. 현재 코드는 전반적으로 잘 구조화되어 있어 큰 버그는 없을 것으로 보이나, null 체크를 추가하면 더 좋을 듯해요, 냥.

### 6. 테스트 가능성
변경된 코드가 테스트하기 용이하게 작성된 것 같아요, 냥. 예외 처리 코드가 명확하니까 통합 테스트와 단위 테스트 작성 시 유용할 것 같아요. 특히 `SseService` 부분의 메서드는 mock 객체를 사용하여 테스트하기 쉬워 보여서 긍정적이에요, 냥.

### 7. 균형 잡힌 피드백
코드의 전반적인 구조와 흐름은 매우 만족스러워요, 냥! 잘못된 예외 처리가 수정되었고, 코드 가독성도 좋아졌어요. 추가로 예외 처리를 더욱 통일성 있게 반영하면 전체적인 코드 품질이 더욱 높아질 것 같아요, 냥. 더불어, 메서드의 null 체크 추가를 고려해보면 좋겠네요, 냥.

전반적으로 강력한 코드 변화를 보여주셨고, 더욱 개선할 가능성도 엿보여요! 계속 멋진 작업 이어가세요, 냥~!');
INSERT INTO public.review VALUES ('2024-11-13 10:50:45.897223', 69, '2024-11-13 10:50:45.897223', 18, '## 코드 리뷰

### 1. 기능적 정확성
- 변경된 코드에서 `SseService` 클래스의 예외 처리를 개선한 부분은 적절합니다. JSON 변환 및 데이터 전송 시 발생할 수 있는 오류에 대해 `BusinessException`을 사용하여 보다 구체적인 오류를 던지도록 변경한 것이 좋습니다. 하지만 각 상황에 맞는 세부적인 오류 메시지도 추가해야 사용자에게 좀 더 유용한 정보를 제공할 수 있을 거에요.

### 2. 가독성 및 유지보수성
- 가독성 측면에서 `ErrorCode` 열거형의 오류 메시지가 체계적으로 정리되어 있어 좋습니다. 그러나 오류 코드에 대한 주석을 한글로 선명하게 작성한 것은 매우 긍정적이나, 주석의 위치가 코드와 가까워야 독자가 이해하기 쉽게 됩니다. 염두에 두세요!
- `sseService.notify()` 메소드 호출 시에 `findReview.getId()`와 같은 흐름으로, `findReview` 변수를 직접 사용할 필요없이 예외 처리된 부분에서 바로 사용하는 방법도 있습니다. 이런 식으로 작성하면 변수를 다시 정의하지 않고 코드의 간결성을 더할 수 있어요.

### 3. 효율성
- `ReviewRepository`에 추가된 메소드 `findFirstByMrInfoOrderByCreatedDateAsc`는 적절하게 구현되었습니다. 그러나, 이 메소드가 호출되는 상황에서 데이터의 양이 많을 경우 성능에 부담을 줄 수 있으니 필요에 따라 인덱스를 설정하는 것도 고려해야 할 것 같아요.

### 4. 확장성 및 모듈성
- `SseService`에서는 직접 메시지를 생성하는 대신, 비즈니스 로직을 통해 외부 사용자의 변화를 쉽게 추적할 수 있도록 설계되어 있습니다. 이러한 설계는 모듈화에 도움이 되고 향후 확장 시에도 유리할 거에요.

### 5. 버그와 취약점
- `try-catch`에서 구현시관리는 좋습니다만, `RuntimeException`을 던지는 것보다는 사용자 정의 예외를 정의하여 좀 더 명확한 예외 처리를 하는 것이 좋습니다. 이렇게 하면 발생할 수 있는 문제의 원인에 대한 정보를 더 쉽게 파악할 수 있게 될 것이에요.

### 6. 테스트 가능성
- 테스트 가능성 면에서는 `SseService`의 오류 처리 방식이 적절해 보입니다. `BusinessException`으로 변환하여 보다 정형화된 형식으로 오류를 처리하고 있습니다. 이는 테스트 코드에서 오류 시나리오를 다루는 데도 유리할 것입니다.

### 7. 균형 잡힌 피드백
- 전반적으로 코드 개선에 대한 고찰과 예외 처리를 강화한 부분은 보기에 좋습니다. 하지만 가독성과 유지보수성을 더욱 향상시키기 위해 변수 사용 미비점, 주석 관리 등을 신경쓰면 안좋을 거 같아요!
- 잘 구성된 부분으로는 `ErrorCode`에 대한 관리가 있습니다. 명확한 구조에서 예외 처리를 일관되게 관리하기에 코드 품질을 향상시키는 요소로 작용하게 될 거에요.

결론적으로 이번 코드는 전반적으로 긍정적인 방향으로 발전하고 있으며, 몇 가지 제안을 통해 좀 더 향상될 수 있습니다. 잘 진행하고 계세요! 냥~');
INSERT INTO public.review VALUES ('2024-11-13 10:53:42.594496', 70, '2024-11-13 10:53:42.594496', 18, '좋아요, 냥! 여기 코드 리뷰를 진행할게요, 냥! 각 항목별로 상세하게 분석해볼게요, 냥!

1. **기능적 정확성**:
   - `SseService`에서 JSON 변환 오류 시 기존에는 `RuntimeException`을 던졌지만, 이제는 `BusinessException`을 던지도록 개선했어요, 냥. 이는 더 구체적인 예외 처리를 가능하게 해서 좋지만, 이런 변경이 기존 로직에 어떤 영향을 미칠지에 대해 문서화가 필요해 보이네요, 냥. 또 `ReviewService`에선 첫 리뷰를 찾을 때 `findFirstByMrInfoOrderByCreatedDateAsc`를 사용하고 있어요. 이는 의도한 대로 동작할 것 같지만, `null` 체크를 추가하면 더 안전할 것 같아요, 냥!

2. **가독성 및 유지보수성**:
   - 전반적으로 코드가 잘 정리되어 있어 가독성이 높은 편이에요, 냥! 특히 예외 처리를 한 곳에서 집중적으로 관리하는 점이 유지보수를 쉽게 할 수 있게 해요, 냥. 하지만 `sseService.notify` 호출 부분에서 `findReview`의 `getId()`로 찾는 것에 대한 주석이 있으면 좋을 것 같아요, 냥. 왜 첫 번째 리뷰를 찾는 것인지 설명이 부족해 보이네요, 냥.

3. **효율성**:
   - `ReviewRepository`에 `findFirstByMrInfoOrderByCreatedDateAsc`를 추가한 것은 데이터를 조회하는 효율성을 높여주는 변화인 것 같아요, 냥. 하지만 쿼리 성능 저하를 염두에 두고 인덱스를 활용하는 방법도 고민해보면 좋겠어요, 냥!

4. **확장성 및 모듈성**:
   - 새로운 `ErrorCode`를 추가한 것은 확장성에 긍정적인 영향을 미칠 것 같아요, 냥. 특히 SSE 관련 에러 코드를 따로 두는 것은 모듈성을 높여요, 냥. 하지만, 혹시 추가될 것 같은 예외들에 대해서도 사전 논의가 필요한 것 같아요, 냥.

5. **버그와 취약점**:
   - `notify` 메소드 호출 시 전혀 없는 리뷰에 대한 로깅이 있어요. 이 부분에서 `findReview`가 `null`일 경우에 대한 처리가 없으니, 예외가 발생할 수 있는 부분이에요, 냥. 이 점을 개선하면 훨씬 안전하게 코드를 유지할 수 있을 거예요, 냥.

6. **테스트 가능성**:
   - 현재 구조에서는 예외 상황을 잘 다루고 있어서 테스트가 용이해 보이나, `sseService`의 `notify` 호출 시뮬레이션에 대한 테스트 케이스가 필요해 보여요, 냥! 예외 발생 시 테스트가 어떻게 되는지 확인해보면 좋겠어요, 냥.

7. **균형 잡힌 피드백**:
   - 전반적으로, 근본적으로 개선된 점들이 많이 보여서 긍정적이에요, 냥! 특히 예외 처리의 구체화는 장기적으로 유지보수에 도움이 될 거예요, 냥. 하지만, 코드의 안전성과 예외 처리에 좀 더 신경을 쓸 필요가 있다는 점은 잊지 말아야 할 것 같아요, 냥!

결론적으로, 잘 구현된 부분도 많고, 개선이 필요한 부분도 있으니 이렇게 조화를 이루면 더욱 좋은 코드가 될 것 같아요, 냥! 추가 질문이 있다면 언제든지 말해줘요, 냥!');
INSERT INTO public.review VALUES ('2024-11-18 10:30:27.898856', 219, '2024-11-18 10:30:27.898856', 57, '변경된 스타일에서 `h-16`과 `h-[42px]` 같은 고정된 높이를 사용하고 있습니다. 다양한 화면 크기와 사용자 환경을 고려하여 유연한 크기 설정(예: `min-h`)을 사용하는 것이 좋습니다. 또한, 클래스 이름들에서 중복을 줄이기 위해 스타일을 모듈화하거나 공통 클래스를 활용할 수 있습니다. 유지보수성 향상을 위해 주석을 추가하는 것도 추천합니다.');
INSERT INTO public.review VALUES ('2024-11-13 10:54:06.996272', 71, '2024-11-13 10:54:06.996272', 19, '안녕하세요! 코드 리뷰를 시작할게요, 냥!

### 1. 기능적 정확성
- 최근 리뷰 생성일을 `GitlabMrResponse`에 추가하는 변경 사항은 기능적으로 적절해 보여요, 냥. 하지만, `findLatestReviewDateByGitlabMrIid` 메소드에서 `null` 값을 반환할 경우에 대한 처리가 필요해 보이는데, 이를 처리하지 않으면 `lastReviewCreatedAt`이 `null`일 때의 의도치 않은 문제를 초래할 수 있어요. 체크 후 예외를 처리하는 로직을 추가하는 것이 좋을 것 같아요, 냥.

### 2. 가독성 및 유지보수성
- 전체적으로 코드가 잘 구조화되어 있어 가독성이 좋아요, 냥. `GitlabMrResponse`와 같은 데이터 구조체에 필요한 필드를 추가하고, 메소드를 통해 정보를 잘 캡슐화하고 있어서 유지보수에도 용이할 것으로 보입니다. 메소드명이 기능을 잘 설명하고 있어서 좋았어요, 냥.

### 3. 효율성
- `findLatestReviewDateByGitlabMrIid`에서 최대 리뷰 생성일을 조회하는 쿼리로 효율성이 높아졌어요, 냥. 다만, 현재 방식에서는 특정 MR에 대해 가장 최신의 리뷰 날짜를 가져오는 데에는 성능 상 문제가 없을 것 같은데, MR 수가 많은 경우 DB 성능에 영향을 끼칠 수 있으니, INDEX가 올바르게 설정되어 있는지 확인하는 것이 좋겠어요, 냥.

### 4. 확장성 및 모듈성
- 코드의 모듈성이 잘 갖춰져 있어서 확장할 때 용이한 구조예요, 냥. 특히, `MrInfo`나 `Review`와 같은 엔티티에 대한 접근이 느슨한 결합으로 이뤄져서, 향후 새로운 요구사항이나 수정사항이 있을 때 쉽게 대처할 수 있을 것으로 생각해요, 냥.

### 5. 버그와 취약점
- 위에서 언급한 대로, `lastReviewCreatedAt`이 `null`일 경우에 대한 처리가 필요해요. 코드가 다른 메소드에서 `null`을 잘 처리하고 있다면 문제가 없겠지만, 아직 구체적인 검사를 하지 않았으니 주의가 필요해요, 냥.

### 6. 테스트 가능성
- 코드의 구조가인터페이스와 구현체 간의 적절한 분리를 이루고 있기 때문에, 테스트 작성이 용이할 것으로 보입니다, 냥. 메소드들이 명확한 입력과 출력을 가지고 작동하므로 유닛 테스트 작성 시 강점을 발휘할 것 같아요, 냥.

### 7. 균형 잡힌 피드백
- 전반적으로 떠오르는 문제 없이 잘 구현되었고, 가독성과 유지보수성 면에서도 훌륭한 점이 많아 좋았어요. 단, `null` 처리에 대한 보강이 필요하니 리팩토링 시 반드시 검토해 주길 바라요, 냥.

전반적으로 긍정적인 변화이며, 개선할 점을 알려준다면 코드 품질이 한층 더 강화될 것 같아요! 좋은 작업이에요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:54:55.015758', 72, '2024-11-13 10:54:55.015758', 17, '물론이야, 냥! 코드 변경 사항에 대한 리뷰를 시작할게. 

1. **기능적 정확성**: 
   변경된 코드는 `mrInfoId`에서 `reviewId`로 변수명을 변경하였고, 그에 맞춰 관련된 모든 호출도 수정하였다냥. 이는 함수의 기능 및 의도를 명확하게 반영하여, 코드가 어떤 리뷰와 관련된 것인지 이해하기 쉽게 만들어 주었다냥. 그러나, 이 변경 사항에 대한 테스트가 필요하니, 기존 기능이 잘 동작하는지 확인해야 한다냥.

2. **가독성 및 유지보수성**: 
   `reviewId`라는 변수명이 보다 직관적이어서 가독성이 개선되었다냥. 전체적으로 명명 규칙이 일관성을 보이고 있는 점은 긍정적으로 평가할 만하다냥. 그러나 메서드의 설명이나 주석이 부족해 보인다냥. 메서드에 대한 주석을 추가하면 유지보수할 때 더 유용할 것 같다냥.

3. **효율성**: 
   변경된 부분은 성능에 큰 영향을 미치지 않지만, `sendToClient` 메서드에서 발생할 수 있는 JSON 변환 예외를 다루는 방식이 약간 개선될 필요가 있다냥. 예외 처리 부분이 런타임 예외로 포장되어 있어, 실제로 어떤 오류가 발생했는지 로그를 통해 확인하기 어려울 수 있다냥. 이는 로그에 좀 더 구체적인 정보를 남겨줘야 좋을 것 같다냥.

4. **확장성 및 모듈성**: 
   변경된 메서드는 특정한 리뷰와 연관된 로직으로 모듈화되어 있어, 향후 다른 관련 기능을 추가할 때 유용하게 확장할 수 있다냥. 그런데, `SseEmitter`와 관련된 클래스가 다른 기능의 클래스들에 의존하는 구조를 보여주어, 이 Dependency의 관리가 필요해 보인다냥.

5. **버그와 취약점**: 
   현재 코드에서는 `sendToClient` 메서드의 `emitter`가 `null`일 경우에 대한 처리가 마련되어 있으나, 더 강력한 예외 처리를 추가하는 것이 좋을 것 같다냥. `null` check 외에도, 예외를 발생시키고, 적절한 로그를 남기는 방식이 필요해 보인다냥.

6. **테스트 가능성**: 
   `SseEmitter`와 관련하여 테스트가 용이하게 설계되어 있다냥. 메서드의 입출력이 명확해 테스트 작성이 충분히 가능할 것 같다냥. `notify`와 `subscribe` 메서드의 로직이 독립적이기 때문에, 각 유닛 테스트를 작성하는 것이 쉬울 것이다냥.

7. **균형 잡힌 피드백**: 
   코드 전체적으로 봤을 때, 명명에 대한 변경이 이루어졌고, 이는 코드의 가독성을 높였지만, 추가적인 에러 핸들링 및 주석이 필요하다냥. 앞으로 이러한 부분을 보완한다면 더욱 좋은 코드가 될 것 같다냥!

이렇게 리뷰를 마칠게, 냥! 개선점과 잘 구현된 부분 모두를 고려하여 코드의 품질을 높이는 데 도움이 되었으면 좋겠어냉~');
INSERT INTO public.review VALUES ('2024-11-13 10:57:04.760163', 73, '2024-11-13 10:57:04.760163', 18, '안녕하세요 냥! 코드 리뷰를 시작할게요 냥!

### 1. 기능적 정확성
변경된 코드에서 `SseService` 클래스의 `notify` 메소드에서 예외 처리를 추가한 것은 매우 좋은 결정이었어 냥. `JsonProcessingException`과 `IOException`을 처리하여 비즈니스 예외로 대체한 부분이 인상적이야 냥. 이렇게 하면 코드의 안정성이 높아지고, 호출하는 쪽에서도 더 명확한 예외 처리를 할 수 있어 냥! 다만, `sseService.notify` 메소드가 호출되는 부분에서 `findReview`가 null일 경우에 대한 예외 처리가 없는 것 같아 냥. 이 부분도 고려해야 할 것 같아 냥.

### 2. 가독성 및 유지보수성
전체적으로 코드의 가독성이 좋아졌어 냥. 코드의 설명을 추가하고, 예외 메시지가 더욱 명확해져서 이해하기 쉽게 되었어 냥. 예를 들어, 오류 메시지에서 "연결 오류!" 대신 "SSE 데이터를 클라이언트로 전송 도중 오류가 발생했습니다."로 바꾼 것은 훌륭한 개선이야 냥. 하지만 요청과 응답 관련 주석을 추가하면 더 이해하기 쉬울 것 같아 냥.

### 3. 효율성
새로 추가한 `findFirstByMrInfoOrderByCreatedDateAsc` 메소드는 코드의 효율성을 높일 수 있어 냥. 이를 통해 더 빠르게 필요한 정보를 조회할 수 있으니 잘 구현된 부분이라고 할 수 있어 냥. 다만, 인덱스나 쿼리 최적화를 고려하지 않으면 성능에 영향을 줄 수 있으니 장기적으로 보면 데이터베이스 쿼리를 최적화하는 것을 검토하는 것이 좋을 것 같아 냥.

### 4. 확장성 및 모듈성
코드가 모듈화되고, 서로 다른 책임을 잘 나누어졌어 냥. `SseService`와 예외 처리 클래스를 통해 관심사의 분리 원칙을 잘 따르고 있어 냥. 이렇게 구조화된 코드 덕분에 향후 기능 추가나 변경이 용이할 것 같아 냥!

### 5. 버그와 취약점
변경된 코드에서 예외 처리를 통해 발생할 수 있는 버그를 잘 제거했어 냥. 기존의 `printStackTrace()` 대신에 비즈니스 예외를 던지는 것이 코드를 훨씬 깔끔하게 만들어 줬어 냥. 그러나 리뷰가 없는 경우 `findReview`를 사용하기 전에 null 체크를 추가해야 할 것 같아 냥.

### 6. 테스트 가능성
코드의 구조가 명확해져서 테스트하기가 더 용이해졌어 냥. 특히 예외 처리가 추가된 부분은 테스트 케이스를 작성하기에 좋은 포인트가 될 것 같아 냥. 하지만 `SseService.notify` 메소드에 대한 테스트 케이스가 추가된다면 더 좋을 것 같아 냥!

### 7. 균형 잡힌 피드백
전반적으로 코드 변경 사항이 잘 진행되었고, 매우 긍정적인 영향을 미쳤어 냥. 특히 예외 처리 부분의 개선이 특히 돋보여서 높은 점수를 줄 수 있어 냥. 다만, 몇 가지 추가적인 null 체크를 구현하면 코드의 안정성이 더욱 향상될 것 같아 냥.

특히 잘 실행된 점은 예외 처리와 가독성 개선이야 냥. 잘 구현된 코드에 대한 피드백을 주어 고마워 냥! 앞으로도 이런 개선이 지속된다면 더욱 멋진 코드가 될 것 같아 냥!');
INSERT INTO public.review VALUES ('2024-11-13 10:59:44.794776', 74, '2024-11-13 10:59:44.794776', 17, '안녕하세요, 코드를 리뷰해보겠습니다 냥.

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 변경한 점은 요구사항에 맞는 것 같습니다 냥. 다만, 그러한 변경이 코드의 다른 부분에 영향을 줄 수 있으므로, 모든 관련 메서드에서의 동작을 함께 검토하는 것이 좋습니다 냥. 특히 `SseEmitter`와 통신할 때 `reviewId`가 올바르게 처리되는지 확인해야 할 것 같아요 냥.

### 2. 가독성 및 유지보수성
변경된 메서드의 파라미터 이름 변경은 코드의 의미를 명확히 해줘서 가독성이 개선되었습니다 냥. 그러나 코드 주석이나 문서화가 추가된다면 앞으로의 유지보수성이 더욱 높아질 거라고 생각해요 냥. 또한 일관된 네이밍 컨벤션을 사용하는 것이 좋습니다 냥.

### 3. 효율성
코드 전체를 볼 때 비효율적인 부분은 없지만, `sendToClient` 메서드에서 여러 예외 처리 로직이 있습니다 냥. 이 부분이 청크로 나뉘어져 있으면 더 나은 가독성을 제공할 수 있습니다 냥. 예외 처리를 메소드로 분리하도록 제안해드리고 싶어요 냥.

### 4. 확장성 및 모듈성
현재 구조에서는 `SseService`와 `SseController`가 잘 분리되어 있어서 SRP(Single Responsibility Principle)을 잘 준수하고 있는 것 같아요 냥. 그러나 추후 기능 확장을 고려할 때, 특정 이벤트를 처리하기 위한 인터페이스나 추상 클래스를 도입할 수 있을 것입니다 냥. 이렇게 하면 다양한 이벤트를 유연하게 처리할 수 있을 거예요 냥.

### 5. 버그와 취약점
예외 처리 시 무조건 `RuntimeException`을 던지는 것은 안 좋을 수 있습니다 냥. 호출한 측에서 이를 처리하지 않으면 애플리케이션이 예기치 않게 종료될 수 있기 때문이죠 냥. 좀 더 구체적인 예외 클래스를 만들어서 다양한 상황에 대한 권장 처리를 제공하는 것을 고려해 보세요 냥.

### 6. 테스트 가능성
이 부분은 매우 긍정적으로 평가할 수 있습니다 냥. 지연된 전송을 위한 `SseEmitter`와 통신 부분이 인터페이스를 통해 처리되므로, 테스트하기 쉬운 구조로 작성되어 있네요 냥. Mocking을 통해 쉽게 단위 테스트를 수행할 수 있을 것 같습니다 냥.

### 7. 균형 잡힌 피드백
전반적으로 코드가 매우 잘 작성되어 있는 편이에요 냥. 주요 변경사항에 있어서도 기능적으로 문제없이 개선되어 보이네요 냥. 다만, 예외 처리를 보다 세부적으로 나누고, 주석을 추가하는 것이 향후 유지보수에 큰 도움이 될 것 같습니다 냥.

이상으로 코드를 리뷰했습니다 냥! 추가적인 질문이 있거나 필요한 부분이 있다면 언제든지 말씀해 주세요 냥!');
INSERT INTO public.review VALUES ('2024-11-18 10:30:27.912356', 220, '2024-11-18 10:30:27.912356', 57, '코드에서 기본 버튼 스타일을 변경하여 시각적인 일관성을 개선한 것이 좋습니다. 그러나 버튼의 색상 대비가 높아야 접근성이 향상됩니다. 색상 조합이 시각적으로 더 두드러지게 만들거나, 글자가 배경에 잘 보이도록 개선하는 것이 좋습니다. 추가적으로, 스크롤 위치에 따라 버튼의 내부 텍스트를 변경하는 것도 사용자 경험을 향상시키는 좋은 방법입니다.');
INSERT INTO public.review VALUES ('2024-11-13 11:00:52.63645', 75, '2024-11-13 11:00:52.63645', 17, '안녕하세요, 냥! 코드 리뷰를 시작해볼게요, 냥! 

### 1. 기능적 정확성
변경된 코드에서 `mrInfoId`를 `reviewId`로 변경한 점은 함수의 이름과 일관성을 더해주는 긍정적인 변화예요, 냥. 이 변경이 실제로 `SseEmitter`와 관련된 기능에 맞게 동작하는지 확인할 필요가 있는데, 호출되는 서비스 메서드에서도 이 변경이 일관되게 반영되었으니 좋은 방향인 것 같아요, 냥. 하지만 슬쩍 다른 부분도 확인해볼 필요가 있어요, 만약 넘어간 변수가 실제로 미치는 영향, 다 들 여전히 저변에서 사용되고 있는지 확인하는 게 중요할 것 같아요, 냥.

### 2. 가독성 및 유지보수성
변경된 변수 이름이 더 직관적이고 이해하기 쉬워졌어요, 냥! `reviewId`가 이전의 `mrInfoId`보다 코드의 맥락을 좀 더 잘 반영하는 것 같아요, 냥. 코드 전반적으로 일관성 있는 변수 이름 사용이 유지되고 있는 점도 긍정적으로 봐요, 냥. 그러나 메서드 내부에서 사용되는 변수명이 명확하지 않다면 주석이나 더 친숙한 이름으로 개선할 공간이 있어 보여요, 냥.

### 3. 효율성
코드 변경에는 특정한 성능 저하 요소는 없지만, 효율적으로 JSON 변환이나 SSE 연결을 처리하는 방식을 고려하면 좋을 것 같아요, 냥. 현재 `sendToClient` 메서드 안에서 발생할 수 있는 예외를 catch하는 방법은 좋지만, 가능하면 좀 더 구체적인 예외처리를 통해 나중에 유지 보수 시 불필요한 로깅을 줄이는 방향이 좋을 것 같아요, 냥.

### 4. 확장성 및 모듈성
메서드 분리를 통해 코드의 모듈성이 좋아졌어요, 냥. 향후 비즈니스 로직이 더 확장된다 해도 이 코드 구조라면 유지 보수에 용이할 것으로 보이네요, 냥. 다만, 현재 구조가 복잡해지지 않도록 주의해야 할 것 같아요, 냥.

### 5. 버그와 취약점
변경된 코드에서는 잠재적인 버그가 눈에 띄지는 않지만, `sendToClient` 메서드에서 예외 처리 시 시스템에 큰 영향을 줄 수 있는 로직을 짚어봐야 해요, 냥. 예를 들어, `emitterRepository.deleteById(id);` 로직이라면 해당 K연결을 끊어지는 상황이 발생하면 방송 정지 같은 예외적 상황이 발생할 수 있으니 이 부분은 좀 더 네트워크 연결 건강성 체크 로직을 추가하는 것이 좋을 것 같아요, 냥.

### 6. 테스트 가능성
`notify`와 `subscribe` 메서드가 충분히 테스트 가능하도록 구성되어 있는지 확인해보는 게 좋을 것 같아요, 냥. 하지만 테스트 코드가 없으면 후에 수정을 고려할 때면 어려움이 생길 수 있으니, 단위 테스트를 적극적으로 도입하는 것을 권장해요, 냥.

### 7. 균형 잡힌 피드백
전체적으로 코드가 잘 구조화되어 있으며, 변수 이름 변경과 같은 작은 수정들이 의미 있는 긍정적 변화를 가져왔어요, 냥. 그러나 코드가 지속적으로 확장될 시에 발생할 수 있는 복잡성을 고려해야 하며, 예외 처리 로직 및 테스트 케이스 등에 대한 고민이 필요해 보여요, 냥. 잘 구현된 부분에 대한 칭찬과 함께, 보완해야 할 부분에서 조금 외부의 시각이 필요할 것 같아요, 냥.

이상이 코드 리뷰에 대한 저의 의견이에요, 냥! 추가적으로 궁금한 부분이 있으면 말씀해 주세요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 11:03:13.940409', 76, '2024-11-13 11:03:13.940409', 17, '## 코드 리뷰

이 코드 변경 사항은 `SseController`와 `SseService`에서의 메서드 시그니처를 변경하여 `mrInfoId`를 `reviewId`로 변경한 부분을 포함하고 있네냥. 이제부터 각 항목에 대해 자세히 평가해볼게냥.

### 1. 기능적 정확성
변경된 메서드 시그니처는 논리적으로 필요한 대로 보이네냥. `mrInfoId` 대신 `reviewId`를 사용하는 것은 코드의 의미를 더 명확하게 만들어주는 점에서 긍정적으로 평가해. 그러나 이 변경이 기존 코드에서의 모든 사용처에 맞는지, 혹은 해당 ID의 사용 범위가 정확하게 설정되었는지는 추가적인 검토가 필요할 것으로 보이네. 만약 이 ID가 다른 컴포넌트나 서비스에서 사용되고 있다면 연관된 수정도 확인해야 할 것 같아.

### 2. 가독성 및 유지보수성
가독성 면에서는 긍정적이네. `reviewId`와 같은 명확한 네이밍이 코드의 이해를 쉽게 해주고, 변화의 의도를 직관적으로 전달해주어 유지보수를 쉽게 할 수 있을 것 같아. 그러나 더 많은 변경이 필요할 경우, 코드를 정리하거나 주석을 덧붙여 추가 설명을 만드는 것도 좋을 것 같아.

### 3. 효율성
코드의 효율성 면에서는 크게 변화한 부분이 없어 보이네. 메서드 호출에 따른 내부 로직은 동일하기 때문에 성능 상의 차이는 없을 것으로 판단해. 다만, 다른 서비스와의 인터페이스들과의 연계에서 성능에 대한 고려가 이루어져야 할 것 같아.

### 4. 확장성 및 모듈성
변경된 코드 구조가 모듈화에 기여하는 부분이 분명히 발견되네. 명확한 매개변수 이름은 추후에 시스템에 새로운 리뷰 관련 기능이 추가될 때 유용할 것 같아. 하지만 각 서비스가 `reviewId`의 유효성을 어떻게 확인할 것인지에 대한 세부 구현이 필요할 것으로 보여. 이를 통해 향후 확장성을 더욱 높일 수 있을 것 같아.

### 5. 버그와 취약점
현재 코드에서 특별히 공격 노출 가능성이나 취약점이 보이지는 않지만, 함수들 간의 의존성 관리에 유의해야 해. `reviewId`가 올바르게 처리되지 않을 경우 예기치 않은 오류가 발생할 수 있으니까, 잘못된 ID가 전달되는 경우에 대한 예외 처리도 필요할 것 같아.

### 6. 테스트 가능성
메서드 시그니처의 변경은 테스트 가능성을 높이는 데 기여할 것으로 보여. `reviewId`를 사용하는 것이 더 나은 명확성을 제공하므로, 테스트 코드 작성 시 가독성과 이해도를 높일 수 있을 것 같아. 하지만, 변경된 메서드들이 모든 관련 테스트 케이스에서 제대로 검증되었는지를 확인해야 할 필요가 있어.

### 7. 균형 잡힌 피드백
전반적으로 좋은 변경 사항이라고 평가할 수 있어. ID의 이름을 변경함으로써 코드의 가독성을 높이고, 유지보수성을 향상시킬 수 있다고 생각해. 다만, 변경사항이 기존 코드의 다른 부분 và 일관성 있게 연계되도록 충분히 테스트하고 검증하는 게 중요할 것 같아. 

각 서비스 및 컴포넌트가 `reviewId`를 올바르게 처리하도록 주의 깊게 살펴봐야 해. 추가적인 테스트 및 검토를 통해 코드 품질을 더욱 강화해 나가길 바랄게냥!');
INSERT INTO public.review VALUES ('2024-11-13 11:03:57.692596', 77, '2024-11-13 11:03:57.692596', 17, '안녕하세요, 냥! 코드 리뷰를 진행할게요, 냥!

### 1. 기능적 정확성:
코드 변경으로 인해 `mrInfoId`를 `reviewId`로 변경한 부분이 있는데, 이는 기능적으로 적절해 보입니다. 이 변경이 의도한 대로 작동하는지 테스트가 필요해 보이네요, 냥. 만약 이 `reviewId`가 다른 서비스나 기능과의 연결에 있어 일관성을 유지한다고 가정하면, 잘 수행된 것 같아 보입니다. 하지만, 이와 관련된 추가 테스트가 필요할 것 같아요, 냥.

### 2. 가독성 및 유지보수성:
가독성이 전반적으로 좋은 편이에요, 냥. 메서드 이름이 명확하고, 변경사항이 함수에 잘 반영되어 있어서 이해하기 쉽지요. 그러나, `SseEmitter`와 관련된 메서드에서 `id`라는 이름 대신 `reviewId`를 사용하였으니, 이러한 일관성을 유지하여 혼란을 줄이는 것이 좋겠습니다, 냥.

### 3. 효율성:
이번 변경으로 인해 코드를 효율적으로 개선했다고 볼 수 있어요, 냥. `sseService`가 잘 구조화되어 있고, `sendToClient` 메서드가 동일한 구조를 사용하여 중복 코드를 피합니다. 효율적인 코드에 대해 칭찬해요, 냥!

### 4. 확장성 및 모듈성:
코드가 특정한 기능에 대해 잘 모듈화되어 있어, 향후 기능 확장이 용이할 것 같아요, 냥. 다만, `SseEmitter`를 보다 더 유연하게 다룰 수 있는 방법을 고려해보는 것도 좋을 것 같네요, 냥. 만약 이 과정에서 다른 서비스와의 통신에 복잡성이 가중된다면, 이를 미리 생각하고 계층을 나누는 것이 좋겠어요, 냥.

### 5. 버그와 취약점:
현재로서는 명확한 버그나 취약점은 보이지 않아요, 냥. 그러나 `JsonProcessingException`과 `IOException`의 처리가 지금처럼 `RuntimeException`으로 전환되고 있다면, 이로 인해 문제가 발생할 가능성이 있을 것 같아요. 예외 로그를 남기고 적절한 에러 처리를 고려해보면 더 좋을 것 같아요, 냥.

### 6. 테스트 가능성:
코드가 전반적으로 테스트 가능성이 높아 보여요, 냥. 각 메서드가 잘 나누어져 있고, 파라미터도 쉽게 조작할 수 있어 단위 테스트를 진행하기 용이할 것 같아요. 특히 `notify` 메서드는 다양한 이벤트에 대해 테스트하기 좋을 것 같아요, 냥!

### 7. 균형 잡힌 피드백:
전반적으로 코드가 잘 작성되어 있고, 인자 명명 변경이 기능적으로도 긍정적인 면이 많습니다. 하지만 예외 처리에서의 세심함이 부족하다는 점에서 개선이 필요해 보이네요, 냥. 이렇게 특정 부분을 좀 더 강화한다면, 더욱 완벽한 시스템이 될 것 같아요, 냥!

그럼, 이러한 피드백을 바탕으로 코드 개선이 이뤄지길 바라요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 11:06:07.399876', 78, '2024-11-13 11:06:07.399876', 19, '### 코드 리뷰

안녕하세요! 코드 변경 사항에 대해 꼼꼼하게 검토해 보았어요, 냥!

#### 1. 기능적 정확성
변경된 코드에서 MR 응답에 최근 리뷰 생성일이 추가되었는데, 이 기능은 유용하게 보이네요. 리뷰 생성일을 제공함으로써, 사용자가 MR의 상태를 보다 명확하게 이해할 수 있을 것 같아요. 다만, `findLatestReviewDateByGitlabMrIid` 메서드가 null 값을 반환할 가능성이 있음을 고려하여, 이를 처리하는 로직이 필요할 것 같아 보이네요. 예를 들어, 마지막 리뷰가 없는 경우 적절한 초기값을 지정하는 방법을 생각해볼 수 있겠어요, 냥!

#### 2. 가독성 및 유지보수성
전반적으로 코드가 깔끔하게 작성되어 있어 가독성이 좋아요, 냥! 특히, 메서드명이 명확하고 매개변수의 이름도 직관적이라 이해하기 쉽네요. 다만, `createGitlabMrResponse` 메서드의 종료 부분에서 꽤 많은 내용이 추가되었는데, 이 부분을 별도의 헬퍼 메서드로 분리하여 코드의 가독성을 더욱 높일 수 있을 것 같아요.

#### 3. 효율성
현재 코드에서 데이터베이스 쿼리를 통해 최신 리뷰 날짜를 찾는 것은 효율적으로 보입니다. 그러나 데이터베이스에 대한 불필요한 호출을 피하기 위해, MR 정보와 관련된 리뷰 데이터가 여러 번 호출될 수 있다면 캐싱 전략을 고려하는 것도 좋을 것 같아요, 냥!

#### 4. 확장성 및 모듈성
`GitlabMrResponse` 객체에 추가된 `lastReviewCreatedAt` 필드는 향후 기능 확장 시에 유용하게 사용될 수 있을 것 같아요. 미래에 리뷰 관련된 추가 데이터를 처리할 수 있는 기반이 마련된 것으로 보여요, 냥! 하지만 상태 변화를 추적해야 할 필요성이 있는 경우, 관련된 이벤트를 생성하거나 상태 관리 로직을 추가하는 것도 고려해봐야 할 것 같아요.

#### 5. 버그와 취약점
`findLatestReviewDateByGitlabMrIid` 메서드에서 최신 리뷰가 없을 경우를 처리하지 않으면 null 포인터 예외가 발생할 수 있어요. 이런 예외 상황을 적절히 처리하는 방법을 고민해보는 것이 중요해요, 냥!

#### 6. 테스트 가능성
코드 구조는 주입 가능한 의존성을 사용하고 있어 테스트 가능성은 높은 편이에요. 특히 `mrInfoRepository`를 통해 의존성을 주입받는 부분은 Mocking을 통해 쉽게 테스트할 수 있을 것 같아요, 냥! 다만, 새로운 필드가 추가되었으니 이와 관련된 유닛 테스트도 작성하는 것이 필요할 것 같아 보여요.

#### 7. 균형 잡힌 피드백
기본적으로 잘 구조화된 코드 같아요! 하지만 몇 가지 개선 사항을 고려해 보는 것이 좋겠네요. 명확한 에러 처리를 도입하고, 코드 가독성을 높이기 위해 메서드를 분리할 수 있는 방법이 있고, 데이터베이스 호출을 최소화하는 전략도 유익할 것 같아요, 냥!

이런 점들을 잘 반영한다면 장기적으로 더 나은 시스템을 만들 수 있을 것 같아요. 전체적으로 훌륭하게 작성된 코드네요! 추가적인 질문이 있다면 말씀해 주세요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 11:17:28.91753', 79, '2024-11-13 11:17:28.91753', 19, '안녕하세요냥! 코드 리뷰 요청을 받아서 기쁩니다냥. 아래는 6가지 평가 항목에 대한 점수와 피드백입니다냥.

### 1. Readability (가독성): 4/5
- 잘 수행된 부분: 변수명(`gitlabMrResponse`, `mrDiffs`, `project`)이 명확하고, 코드 전체적으로 주석이 일정하게 잘 작성되어 있어 이해하기 쉽습니다냥.
- 개선할 부분: 일부 복잡한 로직은 추가적인 주석을 통해 코드의 의도를 명확히 설명하는 것이 좋습니다냥. 예를 들어 `makeCodeReviewWhenCalledByWebhook` 메소드와 같은 경우, 한 개의 메소드가 여러 일을 수행하므로 각 단계에 대한 주석이 추가되면 좋을 것 같습니다냥.

### 2. Consistency (일관성): 5/5
- 잘 수행된 부분: 코드 스타일과 명명 규칙이 전반적으로 일관되게 유지되고 있습니다냥. 변수와 메소드 이름이 CamelCase를 잘 따르고 있습니다냥.
- 개선할 부분: 이 항목에 대해서는 특기할 만한 일관성 문제는 보이지 않습니다냥.

### 3. Reusability (재사용성): 4/5
- 잘 수행된 부분: 일부 기능이 메소드로 잘 분리되어 있어 재사용 가능한 구조입니다냥. 특히 `GitlabMrResponse.of`와 같은 팩토리 메소드를 사용하여 개체 생성이 잘 이루어지고 있습니다냥.
- 개선할 부분: 만약 관련된 기능이 더 많이 추가된다면, 기능 단위로 클래스를 나누어 단일 책임 원칙을 더 강화하는 것이 좋겠어요냥.

### 4. Reliability (신뢰성): 4/5
- 잘 수행된 부분: 데이터베이스 쿼리가 잘 연동되어 있고, 예외 처리를 통한 안정성이 충분히 고려되고 있습니다냥.
- 개선할 부분: 에러 처리 부분에서 `restTemplateUtil.sendGetRequest`와 같은 네트워크 요청에 대한 예외 처리가 없는데, 이를 추가하여 네트워크 오류 발생 시 적절히 대처할 수 있는 로직을 작성하는 것이 좋습니다냥.

### 5. Security (보안성): 4/5
- 잘 수행된 부분: 민감한 정보(`token`)는 메소드 매개변수로 처리하고 있어 좋은 접근 방식입니다냥. 사용자 인증 정보 처리도 적절히 이루어지고 있습니다냥.
- 개선할 부분: 입력 검증 부분이 부족해 보이는데, 예를 들어 `projectId`와 같은 파라미터에 대한 검증 로직을 추가하여 유효성을 체크하면 더 안전한 코드가 될 것 같습니다냥.

### 6. Maintainability (유지보수성): 4/5
- 잘 수행된 부분: 메소드를 통한 코드 구조가 잘 나누어져 있으며, 의존성 주입을 통해 결합도를 낮추고 있습니다냥. 이로 인해 유지보수성이 높습니다냥.
- 개선할 부분: 구성 요소들이 점점 복잡해지면 관리하기 어려워질 수 있으니, 현재의 리팩토링 스타일을 지속적으로 적용하고, 적절한 주석을 통해 코드 변경 시 도움을 줄 수 있는 것이 좋습니다냥.

### 전체적인 피드백:
전체적으로 코드는 매우 잘 작성되어 있으며, 읽기 쉽고, 재사용성과 유지보수성이 높습니다냥! 그러나 몇 가지 소소한 수정 사항과 추가적인 예외 처리 개선하면 더욱 신뢰성을 높일 수 있을 것 같습니다냥. 특히 네트워크 요청이나 데이터베이스 접근 시 항상 에러가 발생할 수 있기 때문에 이에 대한 예외 처리 및 검증 로직를 강화하는 것이 중요합니다냥. 또한 가독성을 더욱 향상시키기 위해 복잡한 메소드에는 단계별 주석을 추가하면 좋을 것 같습니다냥.

정말 수고하셨고, 앞으로도 이 포맷을 잘 유지하여 뛰어난 코드를 작성해 주시길 바랍니다냥!');
INSERT INTO public.review VALUES ('2024-11-13 11:20:35.332673', 80, '2024-11-13 11:20:35.332673', 19, '안녕하세요! 코드 리뷰를 시작할게요 냥. 변경된 코드는 전체적으로 가독성과 유지보수성이 개선된 부분이 있는 듯해요 냥. 다만 몇 가지 피드백과 개선점도 함께 제공할게요 냥. 

### 1. Readability (가독성)
- **잘 수행된 부분**: 코드가 전반적으로 깔끔하게 작성되어 있고, 메서드명과 변수명이 그 역할을 잘 설명해줘요 냥. `createGitlabMrResponse`메서드를 통해 어떤 작업이 수행되는지 명확하게 나타나 있어요.
- **개선이 필요한 부분**: `LastReviewCreatedAt` 같은 긴 변수명이 있어 가독성을 떨어뜨릴 수 있어요 냥. 좀 더 간단한 이름으로 변경하면 좋겠어요. 예를 들어 `lastReviewDate` 같은 형태로 바꾸면 더 직관적일 것 같아요 냥.

### 2. Consistency (일관성)
- **잘 수행된 부분**: 변수 및 메서드명이 통일성 있게 작성되어 표준적인 형식을 따르고 있어요 냥.
- **개선이 필요한 부분**: 파일 내 주석이 부족한 것 같아요 냥. 특정 메서드의 목적이나 기능에 대한 주석을 추가하면 코드의 가독성이 더 높아질 거예요 냥.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: 메서드가 잘 나누어져 있고, 많은 기능이 독립적인 단위로 잘 분리되어 있어 재사용성이 높아 보여요 냥. `getMrDiffs`, `getBestMergeRequests` 같은 메서드가 이 점을 잘 보여줘요.
- **개선이 필요한 부분**: `gitLabClient`의 메서드 호출 횟수가 많은데, 이 부분에서 중복된 부분이 있으면 별도의 서비스나 유틸 클래스로 분리하여 재사용성을 높이면 좋겠어요 냥.

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 데이터 반환 시도와 관련된 로직이 잘 작성되어 있어 안정적이지만, 추가적으로 null 체크 같은 부분도 잘 해줘서 신뢰성을 높일 수 있어요 냥.
- **개선이 필요한 부분**: 예외 처리 부분이 부족한 느낌이에요 냥. 예를 들어, API 호출 시 실패할 경우에 대한 예외처리 로직을 추가하면 코드의 신뢰성이 더욱 높아질 거예요 냥.

### 5. Security (보안성)
- **잘 수행된 부분**: 인증 토큰과 같은 민감한 데이터의 처리가 안전하게 이루어지고 있어요 냥. API 호출 시 헤더에 적절히 포함하고 있네요.
- **개선이 필요한 부분**: 유저의 입력값에 대한 검증 로직이 보이지 않는데, 입력 검증을 통해 SQL 인젝션과 같은 공격에 대해 방어할 수 있도록 코드를 추가하는 것이 좋겠어요 냥.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 기반 구조가 모듈화되어 있어 변경이 용이하게 느껴져요 냥.
- **개선이 필요한 부분**: `@Transactional` 어노테이션 사용의 일관성을 유지하기 위해, 적절하게 메서드의 수정 점검이 필요할 것 같아요 냥. 특히 데이터베이스 연산이 일어나는 메서드에서 어노테이션을 추가하는 것을 고려해 보세요 냥.

### 전체적인 피드백
전반적으로 변경된 코드가 잘 작성되어 있어요 냥! 특히 가독성이 향상되고 변수가 의미를 잘 전달하고 있어 긍정적인 변화가 느껴져요. 다만 입력값 검증, 예외 처리, 및 주석 추가와 같은 세부 사항에 집중하면 더욱 완성도 높은 코드가 될 거예요 냥. 이런 명확한 개선점들이 이루어진다면 팀에서의 코드 유지보수성도 더욱 향상될 것 같아요.

변경하는 과정에서 컴파일 에러나 런타임 에러가 발생하지 않도록 신경 써 주세요 냥. 코드 품질을 높일 수 있도록, 추가적인 검토가 필요하면 더 도와줄게요!');
INSERT INTO public.review VALUES ('2024-11-13 12:09:44.798668', 81, '2024-11-13 12:09:44.798668', 19, '안녕하세요냥! 코드 리뷰를 시작해볼게요냥. 각 항목에 대해 평가하고 피드백을 드릴게요. 

### 1. **Readability (가독성)**: 4/5
- **잘 수행된 부분**: 
  - 메소드와 변수 이름이 명확하고, 기능이 직관적으로 드러나서 이해하기 쉽게 잘 작성되어 있어요냥. 예를 들어, `getBestMergeRequests`와 같은 메소드 이름은 그 기능을 잘 설명해주고 있어요.
  
- **개선이 필요한 부분**: 
  - 만약 코드에 설명이 부족한 경우, 각 메소드 위에 역할을 설명하는 주석을 추가하는 것이 좋을 것 같아요냥. 특히 외부 API 호출 부분에 대한 설명이 있으면 이해하는 데 도움이 될 거예요.

### 2. **Consistency (일관성)**: 4/5
- **잘 수행된 부분**: 
  - 네이밍 규칙이 일관되게 유지되고 있어요. CamelCase 방식이 잘 적용되어 있네요냥.
  
- **개선이 필요한 부분**: 
  - 혹시 코드 전반에 걸쳐있는 인코딩이나 스타일 가이드 문서가 있다면 이를 참조하여 통일감 있게 유지하는 것이 좋을 것 같아용. 예를 들어, 모든 메소드와 변수가 일관된 길이와 스타일을 가지고 있는지 다시 점검해봐야 해요.

### 3. **Reusability (재사용성)**: 5/5
- **잘 수행된 부분**: 
  - 코드가 모듈화되어 있고, 각각의 기능 단위가 명확하게 나뉘어져 있기 때문에 재사용이 용이해 보여요냥. `GitlabMrResponse`와 같은 클래스를 사용하여 다양한 메소드에서 재사용하고 있는 점이 매우 긍정적이에요.
  
- **개선할 점**: 
  - 단일 책임 원칙을 유지하며 코드를 작성해주신 것까지는 좋지만, 나중에 기능이 추가될 경우를 고려해 관련 메소드를 별도의 클래스로 분리할 수 있는지 검토해도 좋을 것 같아요냥.

### 4. **Reliability (신뢰성)**: 3/5
- **잘 수행된 부분**: 
  - 기본적인 내부 메소드 호출 및 데이터베이스 트랜잭션 관리(@Transactional)가 잘 사용되고 있어 신뢰성을 높이고 있어요.
  
- **개선이 필요한 부분**: 
  - 예외 처리 부분이 부족해 보이는데, 특히 외부 API 호출 시 실패가 발생할 경우를 대비해 적절한 예외 처리가 필요해 보여요. 예외를 잡아서 로그를 남겨주거나 사용자에게 피드백을 줄 수 있도록 강화를 고려해보면 좋겠어요냥.

### 5. **Security (보안성)**: 4/5
- **잘 수행된 부분**: 
  - API 호출 시 인증 정보를 잘 처리하고 있어 보안이 잘 관리되고 있어요. 특히 `token` 같은 민감한 데이터를 다루는 부분이 적절하게 처리되고 있네요.
  
- **개선이 필요한 부분**: 
  - 사용자 입력을 받을 때는 항상 검증을 해주는 것이 좋습니다냥. 클라이언트에서 오는 데이터는 언제나 불신하고, 유효성을 확인하는 절차를 마련해 보안성을 더욱 강화하는 것이 좋겠어요.

### 6. **Maintainability (유지보수성)**: 4/5
- **잘 수행된 부분**: 
  - 코드가 명확한 구조로 되어 있어, 나중에 수정이나 추가 기능을 구현하기가 용이해 보이네요. 중요한 비즈니스 로직도 모듈화하여 관리하고 있어서 좋습니다.
  
- **개선이 필요한 부분**: 
  - 각 메소드의 논리와 기능이 명확하게 나뉘어져 있지만, 너무 많은 책임을 가지고 있는 것 같은 느낌이 드는 부분이 있어요. 나중에 기능이 추가되면 더욱 복잡해질 수 있으니 각 메소드가 단일 책임 원칙을 잘 지키고 있는지를 점검해 볼 필요가 있어요.

### **전체적인 피드백**
전체적으로 코드가 깔끔하고 모듈화가 잘 되어 있어 긍정적이에요냥. 특히 재사용성 부분에서 높은 점수를 줄 수 있겠어요. 하지만, 예외 처리와 로그 관리를 강화하면 코드의 신뢰성을 더욱 높아질 것 같아요. 또한, 주석을 통해 다른 개발者가 쉽게 이해할 수 있도록 하면 가독성도 개선될 거예요.

잘 작성된 코드에 대해 칭찬하고 싶고, 앞으로도 이러한 방향으로 계속 진행해주시면 좋겠어요냥! 필요한 부분에 대해 개선할 수 있도록 각 피드백을 반영해보면 좋을 것 같아요. 고생하셨습니다냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:10:40.734824', 82, '2024-11-13 12:10:40.734824', 19, '안녕하세요냥! 코드 리뷰 결과를 아래에 기록할게요냥. 각 항목별로 점수를 부여하고, 잘 수행된 부분과 개선이 필요한 부분을 상세히 설명해 드릴게요냥.

---

### 1. Readability (가독성)
**점수:** 8/10  
**잘 수행된 부분:**  
- 코드가 전반적으로 명확하고 직관적으로 잘 작성되었어요냥. 특히 변수명과 메서드명이 그 용도를 잘 설명하고 있어 이해하기 쉬웠어요냥.  
- `GitlabMrResponse`의 `of` 메서드와 같은 팩토리 메서드는 코드의 흐름을 쉽게 파악할 수 있게 도와줘요냥.  
**개선해야 할 부분:**  
- 부분적으로 주석이 부족한 곳이 있어요냥. 특히 복잡한 로직이나 비즈니스 규칙이 포함된 코드에서는 간단한 설명을 추가하면 가독성이 더욱 높아질 거예요냥.

### 2. Consistency (일관성)
**점수:** 9/10  
**잘 수행된 부분:**  
- 코드 스타일과 명명 규칙이 전반적으로 일관되게 유지되고 있어요냥. 예를 들어, 패키지와 클래스의 구조가 매우 통일감 있게 잘 작성되었어요냥.  
**개선해야 할 부분:**  
- 모호한 변수명 사용을 피하기 위해더 구체적인 변수명을 사용할 수 있어요냥. 예를 들어, `r`와 같이 간단한 이름보다는 기능을 설명하는 이름으로 바꾸는 것이 좋을 것 같아요냥.

### 3. Reusability (재사용성)
**점수:** 7/10  
**잘 수행된 부분:**  
- 코드가 여러 기능 단위로 잘 나누어져 있어 재사용성이 어느 정도 확보되어 있어요냥.  
**개선해야 할 부분:**  
- `GitlabMrDiffsContent`와 같은 데이터 전송 객체를 활용해 반환 타입을 통일하여 다양한 API 호출에서 재사용할 수 있도록 개선할 수 있을 것 같아요냥.

### 4. Reliability (신뢰성)
**점수:** 8/10  
**잘 수행된 부분:**  
- 기본적인 예외 처리 및 오류 검출이 잘 적용돼 있어요냥. 예를 들어, `mrInfoRepository.existsByGitlabMrIid(content.iid())`와 같은 조건문이 사용되면서 존재 여부를 체크해주고 있어요냥.  
**개선해야 할 부분:**  
- 비즈니스 로직과 외부 API 호출 시에 발생할 수 있는 예외를 좀 더 세밀하게 처리할 수 있는 방법을 고민해보면 좋을 것 같아요냥. 예외 발생 시 적절한 오류 메시지를 제공하고, 시스템 전반에 걸쳐 일관된 오류 처리 로직을 적용하는 것이 필요해요냥.

### 5. Security (보안성)
**점수:** 7/10  
**잘 수행된 부분:**  
- API 호출에 필요한 토큰이나 민감한 정보를 처리하는 부분에서 보안을 고려하고 있는 모습이 보였어요냥.  
**개선해야 할 부분:**  
- 사용자의 입력을 받는 부분에서 추가적인 검증을 해주면 좋겠어요냥. 예를 들어, `Long` 형식의 ID가 아닌 값이 들어올 경우를 대비한 검증 로직을 추가하는 것이 필요해 보입니다냥.

### 6. Maintainability (유지보수성)
**점수:** 8/10  
**잘 수행된 부분:**  
- 모듈화와 단일 책임 원칙이 비교적 잘 지켜져 있어 유지보수의 용이성이 높아요냥.  
**개선해야 할 부분:**  
- 비즈니스 로직과 데이터 처리 로직을 분리하여 소스코드의 유지보수성과 테스트 가능성을 더욱 개선할 수 있을 것 같아요냥. 여러 데이터를 처리하는 구문에서는 서비스를 분리하는 것을 고려해보는 것이 좋겠네요냥.  

---

### 전체적인 피드백
코드 전반적으로 좋은 방향으로 나아가고 있으며, **가독성과 일관성 측면에서 특히 훌륭하게 작성되어 있어요**. 또한, 데이터와 비즈니스 로직에 대한 명확한 구조화가 돋보이고, 나중에 팀원이 쉽게 이해할 수 있는 코드임을 느낄 수 있었어요냥.

하지만 몇 가지 개선할 부분도 분명히 존재해요냥. 주석 추가나 예외 처리 강화, 보안 부분의 강화는 추가적인 보완이 필요해요. 더불어, 유지보수성과 재사용성을 염두에 두고 코드 리팩토링을 고려해보면 좋을 것 같아요냥.

코드를 잘 작성하셨고, 작은 변경으로도 훨씬 더 나은 품질을 만들 수 있으니, 긍정적인 방향으로 계속해서 발전해 나가시길 응원할게요냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:11:54.67811', 83, '2024-11-13 12:11:54.67811', 19, '안녕하세요! 코드 리뷰 요청해 주셔서 감사해요, 냥! 변경된 코드에 대해 6가지 항목별로 점수와 피드백을 남기도록 할게요, 냥!

### 1. Readability (가독성): 8/10
- **잘 수행된 부분**: 전반적으로 변수명과 함수명이 명확하고, 읽기 쉽게 잘 작성되었어요. 특히 `getBestMergeRequests`, `createGitlabMrResponse` 등 함수 이름이 기능을 잘 설명하고 있어서 이해하기 쉬운 점이 좋았어요, 냥.
- **개선이 필요한 부분**: 중요도나 복잡도가 높은 부분에 주석을 추가하는 것이 좋겠어요. 예를 들어, `makeCodeReviewWhenCalledByWebhook` 함수는 여러 단계를 거치므로 각 단계에 대한 설명을 주석으로 추가하면 더 명확할 것 같아요. 

### 2. Consistency (일관성): 9/10
- **잘 수행된 부분**: 코드 스타일과 명명 규칙이 일관되게 유지되고 있어요. 특히 메소드 이름이 camelCase로 잘 작성되어 있어서 가독성을 높여주고 있어요, 냥.
- **개선이 필요한 부분**: 파일 내에서의 코드 배열이 조금 더 일관성 있게 정리되면 좋을 것 같아요. 관련된 메소드들이 가까이 위치하도록 재배치하면 사람들 이해하기 더 쉽게 할 수 있을 것 같아요.

### 3. Reusability (재사용성): 7/10
- **잘 수행된 부분**: 여러 기능이 잘 분리되어 있어서 다른 영역에서도 활성화할 수 있는 구조가 좋았어요. 예를 들어, GitLab API 요청을 다루는 메소드들은 독립적으로 잘 작성되어 있어요, 냥.
- **개선이 필요한 부분**: 몇몇 함수가 비슷한 로직을 반복하고 있는 것 같아요. `getMrDiffs`와 유사한 API 호출을 하는 부분이 다른 곳에서 발생할 수 있는데, 이를 일반화된 메소드로 추출할 수 있으면 좋을 것 같아요.

### 4. Reliability (신뢰성): 8/10
- **잘 수행된 부분**: 코드가 대부분 의도한 대로 작동할 것으로 보이며, 예외 처리도 잘 되어 있어요. `restTemplateUtil.sendGetRequest` 활용 시 오류 반환 처리도 괜찮아요, 냥.
- **개선이 필요한 부분**: 몇 군데에 null 체크가 없는 경우가 보여요. 예를 들어, API 호출 결과가 null일 경우에 대한 처리를 추가하면 더욱 신뢰성을 높일 수 있을 것 같아요, 냥!

### 5. Security (보안성): 7/10
- **잘 수행된 부분**: API 호출 시 인증 토큰을 전달하는 방식이 괜찮아요. 그러나 민감한 정보가 로그로 출력될 가능성을 고려해 적절한 필터링을 적용하는 것이 필요해 보이네요.
- **개선이 필요한 부분**: 사용자 입력을 검증하는 로직이 부족해 보이네요. 특히 `getBestGitlabMergeRequests`와 같은 함수에서 매개변수 검증이 필요할 수 있으니, 이 부분을 강화해보면 좋을 것 같아요!

### 6. Maintainability (유지보수성): 8/10
- **잘 수행된 부분**: 전체적으로 코드가 잘 모듈화 되어 있어 변경이 용이할 것으로 보입니다. 메소드들이 작은 단위로 명확히 나뉘어져 있어서 각 기능 변경 시 다른 부분에 영향을 주지 않으리라 생각해요, 냥!
- **개선이 필요한 부분**: 중복 코드가 조금 보여요. `GitlabMrResponse`를 만드는 과정에서 비슷한 로직이 여러 번 반복되는 것을 피하기 위해 헬퍼 메소드를 사용하는 것이 좋겠어요!

### 전체적인 피드백
변경된 부분에서 잘 수행된 사항은 명확한 변수 및 함수 이름 사용, 모듈화, API 호출 관리 등에서 긍정적이에요. 그러나 예외 처리 및 보안 강화를 위한 입력 검증 추가와 같은 개선이 필요한 부분도 분명히 있어요, 냥! 이러한 부분을 고려하면 더 안전하고, 가독성이 높은 유지보수하기 쉬운 코드를 작성할 수 있을 거예요. 아주 좋은 시도였으니, 계속해서 노력해보세요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:13:40.275402', 86, '2024-11-13 12:13:40.275402', 19, '안녕하세요냥! 코드 리뷰를 시작할게요냥. 요청하신 6가지 항목에 대해 점수와 피드백을 드릴게요. 

### 1. **Readability (가독성)**: 8/10
**잘 수행된 부분**: 함수와 변수명은 명확하고 직관적이에요냥. 주요 로직이 잘 나눠져 있어서 이해하기 쉬워요.

**개선할 점**: 몇몇 복잡한 부분에 추가 주석이 있으면 이해하기 더 수월할 것 같아요냥. 특히, `makeCodeReviewWhenCalledByWebhook` 메서드에서는 단계별로 설명하면 좋을 것 같아요.

### 2. **Consistency (일관성)**: 7/10
**잘 수행된 부분**: 코딩 스타일이 전반적으로 일관되게 유지되고 있어요냥. 각 클래스 및 인터페이스에서 필드와 메서드의 명명 규칙이 통일되고 있어 가독성이 좋아요.

**개선할 점**: 일부 메서드에서 라인 길이가 길어져서 가독성이 떨어질 수 있어요냥. 80-120자를 지키는 것이 좋겠어요. 

### 3. **Reusability (재사용성)**: 9/10
**잘 수행된 부분**: 함수들이 독립적으로 잘 설계되어 있어서 재사용 가능성이 높아요냥. 특히, `getBestMergeRequests`와 관련된 기능은 다른 서비스에서도 활용할 수 있을 것 같아요.

**개선할 점**: 매직 스트링이나 숫자를 상수로 빼면 더 좋을 것 같아요냥. 예를 들어, URL 생성 시 사용되는 정적인 부분이 있다면 상수로 정의하면 좋을 것 같아요.

### 4. **Reliability (신뢰성)**: 6/10
**잘 수행된 부분**: 대부분의 로직이 순차적으로 잘 진행되고 있어요냥. 각 기능은 의도한 대로 작동할 가능성이 높아 보여요.

**개선할 점**: 예외 처리 부분이 미흡한 것 같아요냥. 특히 외부 API 호출 시의 예외 처리 로직을 추가해야 해요. API 호출 실패 시 어떤 동작을 취할 것인지 명확히 해줘야 해요.

### 5. **Security (보안성)**: 7/10
**잘 수행된 부분**: GitLab API를 처리하는 메서드는 적절한 인증 토큰을 사용하고 있어 보안에 대한 기본적인 고려가 되어 있어요냥.

**개선할 점**: 입력 값 검증이 더 강화될 필요가 있어요냥. 특히 외부 API 호출에 대한 입력 값은 내용을 체크해서 SQL 인젝션이나 불필요한 데이터 접근을 방지해야 해요.

### 6. **Maintainability (유지보수성)**: 8/10
**잘 수행된 부분**: 각 기능은 잘 나뉘어져 있어 코드 수정이나 확장이 용이해 보여요. `@Transactional` 어노테이션을 제대로 활용하여 데이터 무결성을 보장하고 있는 점도 좋네요.

**개선할 점**: 함수 내에서 클래스 변수를 직접 사용하는 대신, 매개변수로 전달받는 것이 모듈화를 더 좋게 할 것 같아요냥. 변경 사항이 있을 시 함수 간의 의존성이 줄어듭니다.

### **전체적인 피드백**
전반적으로 코드는 잘 작성되어 있고 의도한 대로 작동할 수 있는 가능성이 높은 것 같아요냥. 가독성이나 유지보수면에서 잘 수행되고 있지만, 예외 처리나 보안성 부분에서 개선이 필요해요. 특히 외부 API와의 연동 부분에서는 추가적인 검증과 예외 처리가 필수적이란 점 강조할게요.

개선이 필요한 부분에 대해 명확하게 제안하는게 정말 잘 되었어요! 더 나은 코드를 향해 나아가기 위한 노력이 엿보여서 좋네요냥! 계속해서 좋은 코드 작성해 주세요냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:22:22.381778', 87, '2024-11-13 12:22:22.381778', 19, '안녕하세요냥! 코드 리뷰를 시작할게요냥. 변경사항을 기반으로 6가지 항목에 대해 평가를 진행할게요. 점수는 각 항목의 최대 점수인 10점을 기준으로 부여할게요. 

### 1. Readability (가독성): 8/10
**잘 수행된 부분**:
- 코드 전반적으로 직관적이며, 필요한 변수명과 함수명이 의미가 분명해서 읽기 좋은 편이야. 특히 `getBestMergeRequests`, `createGitlabMrResponse`와 같은 메서드는 어떤 기능을 수행하는지 명확해.
- 변경된 부분에서 `lastReviewCreatedAt` 같은 변수를 통해 MR의 최신 리뷰 생성일을 추적하는 기능이 잘 추가되었어.

**개선 필요 부분**:
- 몇몇 부분에서 주석이 부족해서, 특히 API 호출의 의도를 명확히 설명할 수 있는 주석이 추가된다면 더욱 읽기 쉬울 것 같아. 예를 들어, `redisGateway.sendReviewRequest(reviewRequest);`와 같은 부분에 왜 이 호출이 필요한지 간단히 설명하는 주석이 있으면 좋겠어.

### 2. Consistency (일관성): 9/10
**잘 수행된 부분**:
- 코드 스타일과 명명 규칙이 일관되게 유지되고 있어. 메서드명, 변수명 등에서 camelCase 규칙을 잘 적용하고 있어.
- 빌더 패턴을 사용하여 객체를 생성하는 등이 통일감 있게 적용되고 있어.

**개선 필요 부분**:
- 개인적으로는 간혹 일부 메서드의 파라미터 순서가 일관되지 않는 부분이 있었어. 예를 들어, 어떤 메서드는 `gitlabUrl`, `token`, `projectId` 순으로 받고 있는데, 비슷한 메서드에서 다른 순서를 사용할 경우 혼란을 줄 수 있으므로 일관되게 정렬하는 것이 좋겠어.

### 3. Reusability (재사용성): 7/10
**잘 수행된 부분**:
- 여러 기능을 독립적으로 메서드로 잘 분리했어, 예를 들어 `getMrDiffs`, `createGitlabMrResponse`와 같은 메서드는 각각 특정 기능을 담당하고 있어.
- 새로운 파라미터를 추가하면서도 기존 인터페이스를 손상시키지 않고 잘 유지했어.

**개선 필요 부분**:
- `gitLabClient` 관련 메서드들을 조금 더 모듈화하여 여러 다른 컨텍스트에서도 재사용할 수 있도록 하면 좋겠어. 예를 들어, 공통의 HTTP 헤더를 설정하는 부분 같은 경우는 별도의 메서드로 분리하여 다른 API에서도 재사용할 수 있도록 하는 것이 좋을 것 같아.

### 4. Reliability (신뢰성): 8/10
**잘 수행된 부분**:
- 데이터 조회를 위한 쿼리가 잘 작성되어 있고, `findLatestReviewDateByGitlabMrIid`와 같은 메서드는 적절하게 데이터베이스 레코드를 가져오고 있어.
- 각종 객체를 생성할 때 적절한 절차를 잘 따르고 있어.

**개선 필요 부분**:
- 예외 처리 부분에서 조금 더 구체적인 처리가 가능할 것 같아. 예를 들어, `getMrDiffs`에서 API 호출이 실패했을 때의 상황을 고려한 예외 처리가 필요해 보여. 실패 시 적절한 로그를 기록하거나 사용자에게 명확한 피드백을 줄 수 있는 방안을 고려해야 해.

### 5. Security (보안성): 8/10
**잘 수행된 부분**:
- 민감한 데이터(token 등)를 적절히 관리하는 모습을 보여주고 있어. GitLab API를 호출할 때 Authorization 헤더를 사용함으로써 보안을 잘 유지하고 있는 것 같아.

**개선 필요 부분**:
- 입력에 대한 검증이 필요해 보여. 특히 API 요청을 처리할 때는 부적절한 입력으로 인해 시스템이 오작동하지 않도록 추가적인 검증 로직을 포함하는 것이 좋겠어. 예를 들어, `projectId`와 같은 필수 파라미터가 null인지 확인하는 로직이 포함되면 좋을 것 같아.

### 6. Maintainability (유지보수성): 8/10
**잘 수행된 부분**:
- 서비스 클래스와 레포지토리 간의 역할이 명확히 분리되어 유지보수성이 좋을 것 같아. 각 메서드가 단일 기능에 집중하고 있어.

**개선 필요 부분**:
- 모듈화를 좀 더 신경 쓴다면 좋을 것 같아. 예를 들어, 특정 기능에서 호출되는 여러 서비스 메서드가 복잡하게 얽히는 경우가 발생할 수 있으므로, 비즈니스 로직을 서비스 객체에 모아둔 후 필요할 때 해당 객체를 호출하는 방식이 되면 더 깔끔할 것 같아.

### 전체적인 피드백
코드 전반적으로 잘 작성된 부분이 많아! 특히 기능별로 잘 나누어져 있어서 유지보수와 이해가 용이했어. 하지만 예외 처리나 주석 추가에 조금 더 신경 쓴다면 더 좋은 코드가 될 것 같아. 입력 값 검증이나 보안 측면에서도 어느 정도 신경을 써서, 사용자 데이터가 안전하게 다뤄질 수 있도록 해야겠어.

빠른 시일 내에 코드를 수정해 보고, 필요한 경우 주석이나 문서도 함께 추가하면 좋겠어. 잘했어, 계속 이렇게 발전하는 모습을 보여줘! 고맙고 수고했어냥!');
INSERT INTO public.review VALUES ('2024-11-13 12:26:18.453546', 88, '2024-11-13 12:26:18.453546', 19, '### 코드 리뷰

#### 1. **Readability (가독성)**
- **잘 수행되고 있는 부분**: 전반적으로 코드가 명확하고 구조적으로 잘 정리되어 있습니다. 특히, 메서드명과 변수명이 그 기능이나 역할에 대해 잘 설명하고 있어 이해하기가 수월합니다.
- **개선이 필요한 부분**: `MrContent`와 `ReviewRequestMessage`와 같이 약어로 이루어진 클래스나 변수가 있습니다. 이들이 무엇을 의미하는지 명확히 드러나지 않아 가독성을 떨어트릴 수 있습니다. 더 직관적인 이름으로 변경하는 것을 추천합니다.

#### 2. **Consistency (일관성)**
- **잘 수행되고 있는 부분**: 업계 표준 코딩 규칙과 Java의 코드 스타일을 충실히 따르고 있습니다. 줄바꿈이나 들여쓰기 등이 일관되게 사용되고 있으며, 주석 또한 적절히 위치해 있습니다.
- **개선이 필요한 부분**: `@Transactional` 등의 애노테이션 위치가 모두 일관되지는 않은 것 같습니다. 메서드 위의 애노테이션들은 실행 시점을 혼동하게 할 수 있으므로, 모든 트랜잭션 관련 메서드에서 일관된 위치에 두는 것이 좋습니다.

#### 3. **Reusability (재사용성)**
- **잘 수행되고 있는 부분**: `GitlabMrResponse`와 같은 데이터 클래스를 활용하여 객체 지향적인 접근 방식이 잘 나타납니다. 이는 코드의 재사용성을 높이는데 기여합니다.
- **개선이 필요한 부분**: GitLab API와의 통신 부분에서 활용되는 `restTemplateUtil.sendGetRequest` 메서드는 다른 API 호출에서도 재사용 가능하도록 더욱 일반화될 수 있습니다. 공통된 HTTP 요청 패턴이 존재하므로, 이를 위한 범용 메서드를 만들어 두는 것이 좋겠습니다.

#### 4. **Reliability (신뢰성)**
- **잘 수행되고 있는 부분**: API 호출 후 Response를 처리하는 부분에서 Null 체크가 잘 이루어지고 있습니다.
- **개선이 필요한 부분**: 각 메서드에서 외부 API로부터 발생할 수 있는 예외에 대한 구체적인 처리가 없습니다. 예를 들어, `restTemplateUtil.sendGetRequest`에서 예외가 발생할 경우 이를 어떻게 처리할 것인지 명시적으로 구현해 두는 것이 좋습니다. Try-Catch 문으로 충분히 다룰 수 있을 것입니다.

#### 5. **Security (보안성)**
- **잘 수행되고 있는 부분**: 토큰을 매개변수로 받아 인증을 수행하는 부분에서 보안성을 고려한 설계가 이루어졌습니다.
- **개선이 필요한 부분**: 특히 외부 API 호출 시 어떤 데이터를 보내고 받는지에 대한 검증 코드가 없어 보입니다. 유저 입력 데이터에 대한 검증이 필요합니다. 이를 통해 SQL Injection 등 보안 취약점을 줄일 수 있습니다.

#### 6. **Maintainability (유지보수성)**
- **잘 수행되고 있는 부분**: 코드가 명확히 기능별로 나뉘어 있어 변경 사항 발생 시 특정 부분만 수정하면 되므로 유지보수가 용이합니다.
- **개선이 필요한 부분**: 메서드의 길이가 긴 경우가 많아 가독성에 영향을 미치므로, 특정 로직은 별도의 private 메서드로 분리하여 단일 책임 원칙을 적용하는 것이 좋겠습니다.

### 전체적인 피드백
- **잘 수행되고 있는 부분**: 코드의 전반적인 구조와 명명 규칙이 잘 따라지고 있어, 적절하게 모듈화 되어 있습니다. REST API 호출 부분도 명확히 구현되어 있어, 향후 유지 보수를 고려한 좋은 설계입니다.
- **개선이 필요한 부분**: 예외 처리와 입력 검증 부분이 약한 것으로 보입니다. 소프트웨어의 안정성을 확보하기 위해 이러한 부분에 대한 개선이 필요합니다. 추후에는 더욱 적극적으로 단위 테스트를 도입하여 코드의 신뢰성을 한층 더 높이는 것을 추천드립니다. 

이런 수정 사항들을 반영하는 것이 향후 코드의 품질과 유지보수성을 높이는 데 큰 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-13 12:28:28.922972', 89, '2024-11-13 12:28:28.922972', 19, '코드 변경 사항에 대한 상세한 리뷰를 아래와 같이 진행하겠습니다. 각 항목에 대해 평가하였으며, 개선이 필요한 점과 잘 수행되고 있는 부분도 서술했습니다.

### 1. Readability (가독성)
- **잘 수행된 부분**:
  - 전반적으로 코드의 구조가 잘 잡혀 있어 기능별로 나누어져 있습니다. 메서드 이름과 변수명이 기능을 충분히 설명하고 있습니다.
  - 특히, `GitlabMrResponse.of` 메서드는 입력 파라미터의 용도를 명확히 전달하고 있습니다.

- **개선할 부분**:
  - `makeCodeReviewWhenCalledByWebhook` 메서드와 같은 긴 메서드는 세분화하여 가독성을 높이는 것이 좋습니다. 예를 들어, 리뷰 생성을 여러 개의 메서드로 나누면 각 기능을 더 쉽게 이해할 수 있습니다.
  - 코드 내 적절한 주석이 추가되면 더욱 직관적으로 이해할 수 있습니다. 특히 비즈니스 로직이 복잡한 부분에서는 주석이 필수적입니다.

### 2. Consistency (일관성)
- **잘 수행된 부분**:
  - 코드 스타일이 일관되게 유지되고 있으며, 빌더 패턴을 잘 사용하고 있습니다. JPA의 명명 규칙에 따라 `@Param`과 `@Query` 애너테이션도 잘 사용되고 있습니다.

- **개선할 부분**:
  - 포맷팅과 들여쓰기를 체크해주세요. 일부 줄에서 불필요한 공백이 사용되고 있어 코드의 일관성을 방해하고 있습니다.
  - 패키지 및 클래스 이름 규칙이 일관되게 따르고 있는지 확인할 필요가 있습니다. 예를 들어 `GitlabMrDiffsContent` 클래스에서 사용되는 패키지 명명 규칙이 다른 클래스와 동일한 형식을 따라야 합니다.

### 3. Reusability (재사용성)
- **잘 수행된 부분**:
  - `GitlabMrResponse.of`와 같은 메서드는 매개변수를 끌어올리면서 다양한 기능을 제공합니다. 이 부분은 재사용성을 높이는 좋은 예입니다.

- **개선할 부분**:
  - `MrInfo` 저장과 같은 특정 비즈니스 로직이 `makeCodeReviewWhenCalledByWebhook` 메서드 내에서 이루어지고 있는데, 이를 별도의 서비스 클래스로 분리하면 재사용성을 높이고 각 메서드의 책임을 명확하게 분리할 수 있습니다.

### 4. Reliability (신뢰성)
- **잘 수행된 부분**:
  - 비즈니스 로직에서 필요할 때마다 적절히 데이터를 조회하고 있으며, `existsByGitlabMrIid`와 같은 유효성 검사를 통해 신뢰성을 높이고 있습니다.

- **개선할 부분**:
  - 예외 처리가 부족합니다. 예를 들어, 외부 API 호출 시 실패할 가능성을 염두에 두고 적절한 예외 처리를 추가해야 합니다. 특정 메서드는 `null` 체크가 부족하여 NPE(Null Pointer Exception)의 위험이 존재합니다.
  - 데이터베이스에서 데이터를 검색하는 단계에서 가능한 예외를 관리하면 모든 경우를 커버하는 데 도움이 됩니다.

### 5. Security (보안성)
- **잘 수행된 부분**:
  - GitLab API를 사용할 때 사용자 토큰을 활용하여 민감한 데이터를 보호하는 접근 방식을 선호합니다.

- **개선할 부분**:
  - 사용자 입력에 대한 검증이 필요합니다. API 호출 시 외부 입력이 포함될 경우, 해당 입력에 대한 검증이 필수적입니다. SQL 인젝션 방지를 위해 입력 파라미터를 적절히 필터링할 필요가 있습니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**:
  - 클래스를 적절히 나누어 모듈화 하였고, 그에 따른 간결한 책임 분리에 대한 노력이 보여집니다.

- **개선할 부분**:
  - `regenerateReview`와 같은 메서드는 여러 개의 역할을 수행하고 있습니다. 각 역할을 명확히 분리하고 책임을 단일화하는 것이 유지보수성 측면에서 더 나을 것입니다.
  - 의존성 주입(DI)을 통해 클래스의 결합도를 낮추면 변경에 더욱 유연하게 대응할 수 있습니다. 예를 들어, GitLab과 관련된 API 호출을 바인딩하는 특정 클래스는 인터페이스를 통해 스택을 분리할 수 있습니다.

### 전체적인 피드백
전반적으로 코드는 명확하고 잘 작동한 것으로 보입니다. 특히, 직관적인 메서드 이름과 구조는 코드 읽기를 쉽게 해줍니다. 그러나 예외 처리와 가독성 측면에서 개선의 여지가 있는 부분이 있습니다. 또한, 모듈화와 재사용성을 높이기 위한 추가적인 구조화도 필요합니다. 이러한 부분들을 개선하면 코드의 품질이 한층 더 향상될 것입니다. 

마지막으로, 컴파일 에러나 런타임 에러가 발생할 방지가 있는지 충분히 검토해야 하며, 문제가 발생할 경우 강력히 수정해야 합니다. 이러한 피드백이 코드 개선에 도움이 되었으면 합니다.');
INSERT INTO public.review VALUES ('2024-11-13 12:28:43.193099', 90, '2024-11-13 12:28:43.193099', 19, '## 코드 리뷰

### 1. Readability (가독성)
**잘 수행된 부분:**
- 전체적으로 메서드와 클래스 이름이 비교적 직관적이며, 기능이나 역할을 잘 나타내고 있어 가독성이 좋습니다. 예를 들어 `getBestMergeRequests`나 `createGitlabMrResponse` 같은 이름은 메서드의 목적을 잘 드러내고 있습니다.

**개선이 필요한 부분:**
- 메서드 내부에서 사용되는 변수명에 대해 좀 더 명확한 이름을 사용하는 것이 좋습니다. 예를 들어 `exists`는 존재 여부를 확인하는 변수지만, `mrExists`와 같이 좀 더 구체적인 이름을 사용하면 독자가 바로 의도를 이해할 수 있을 것입니다.
- 코드에 주석을 추가하면 가독성이 더 향상될 수 있습니다. 특히, 복잡한 로직이나 특정 메서드의 의도를 명확히 알기 위한 주석이 필요합니다.

### 2. Consistency (일관성)
**잘 수행된 부분:**
- 코드 포맷과 스타일이 일관되게 유지되고 있으며, 전반적으로 Lombok을 사용한 Getter/Setter 패턴을 따르고 있습니다.

**개선이 필요한 부분:**
- 클래스와 메서드 간의 주석 스타일이 일관되지 않습니다. 일부 메서드는 주석이 있지만, 주요 메서드에서도 주석이 없어 독자가 이해하기 어려울 수 있습니다. 모든 클래스와 메서드에 대해 통일된 주석 양식을 적용하는 것이 좋습니다.

### 3. Reusability (재사용성)
**잘 수행된 부분:**
- `createGitlabMrResponse` 메서드는 다양한 곳에서 호출되며, MR 리스트를 처리하는 데 있어 재활용될 수 있는 구조입니다.

**개선이 필요한 부분:**
- 메서드 내부에 반복되는 로직이 보입니다. 예를 들어, GitLab API에서의 응답 처리와 같은 비슷한 로직은 공통 메서드로 추출하여 재사용성을 높일 수 있습니다. 이는 유지보수성을 높이는 동시에 코드 중복을 줄이는 데 기여할 것입니다.

### 4. Reliability (신뢰성)
**잘 수행된 부분:**
- `@Transactional` 어노테이션의 사용으로 데이터 무결성을 보장하고 있습니다. 이는 여러 데이터베이스 작업이 함께 성공하든, 모두 실패하든 일관성을 유지하는 데 매우 중요합니다.

**개선이 필요한 부분:**
- 오류 처리 부분이 부족합니다. API 호출 중 오류가 발생할 경우, 이를 적절히 처리하고 예외를 던지는 메커니즘이 필요합니다. 이를 통해 시스템이 불안정해지는 것을 방지할 수 있습니다.

### 5. Security (보안성)
**잘 수행된 부분:**
- GitLab API 호출 시 token을 사용하여 보안을 고려하고 있습니다.

**개선이 필요한 부분:**
- 사용자 입력에 대한 유효성 검사가 명확하지 않습니다. 예를 들어, `userId`, `projectId`, `mergeRequestIid` 같은 값은 신뢰할 수 없는 외부에서 오는 값이므로, 이를 검증하는 추가 로직이 필요합니다. SQL 인젝션과 같은 공격을 방어하기 위한 방어 코드를 추가해야 합니다.

### 6. Maintainability (유지보수성)
**잘 수행된 부분:**
- 전체적인 메서드와 클래스가 명확한 역할을 가지고 있어 변경이 용이한 구조를 채택하고 있습니다.

**개선이 필요한 부분:**
- 메서드가 너무 많은 책임을 지고 있는 경우가 있습니다. 예를 들어 `regenerateReview` 메서드는 여러 서비스를 호출하고 복잡한 로직 처리를 담당하고 있습니다. 이를 작은 메서드로 나누어 단일 책임 원칙을 적용하는 것이 좋습니다.

## 전체적인 피드백
- 전반적으로 이 코드는 잘 작성되어 있으며, 주요 구조와 흐름에서 명확성을 보여주고 있습니다. 코드의 읽기 쉬움과 논리적인 흐름은 잘 지켜지고 있으나, 가독성과 유지보수성을 향상시키기 위해 주석이나 변수명을 좀 더 명확히 할 필요가 있습니다.
- 예외 처리와 입력 검사 같은 신뢰성과 보안성 강화를 위해 추가적인 처리가 필요합니다. 필요없는 중복 코드나 복잡한 로직은 별도의 메서드로 분리하여 재사용하는 것이 권장됩니다.
- 이러한 개선 사항들을 반영하면, 코드의 품질이 한층 더 높아질 것입니다. 이 점을 간과하지 말고 다음 개발에 접목해 주시기 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-13 12:32:15.086627', 91, '2024-11-13 12:32:15.086627', 19, '리뷰어 역할을 수행하며, 요청하신 코드에 대한 심도 있는 리뷰를 진행하겠다. 코드 변경 사항에 대해 각각의 항목에서 잘 수행된 점과 개선이 필요한 점을 구체적으로 설명할게.

### 1. 가독성 (Readability)
**잘 수행된 점:**
- `GitlabMrResponse`와 같은 클래스 이름이 해당 클래스의 역할을 잘 나타내고 있어 이해하기 쉽다.
- `createGitlabMrResponse`와 같은 메서드 이름도 그 기능을 명확히 한다.

**개선해야 할 점:**
- `findLatestReviewDateByGitlabMrIid` 같은 메서드 이름이 길어질 위험이 있다. 더 짧고 의미를 잘 전달하는 이름으로 변경하는 걸 고려해봐.
- 주석이 부족하다. 복잡한 로직이 포함된 부분, 특히 DB 쿼리나 외부 API 호출에 대해서는 주석을 추가하여 코드의 의도를 명확히 할 필요가 있다.

### 2. 일관성 (Consistency)
**잘 수행된 점:**
- 코드 스타일이 전체적으로 일관되게 유지되고 있으며, 공간적으로 깔끔하다. 

**개선해야 할 점:**
- 특정 메서드 내부에서의 변수명 사용이 일관성이 떨어진다. 예를 들어, `project`와 같은 변수명이 여러 메서드에서 사용되고 있지만, 다른 맥락에서는 `gitlabAccount`와 같은 더 구체적인 이름을 사용하는 점을 참고하라.

### 3. 재사용성 (Reusability)
**잘 수행된 점:**
- 데이터 조회 메서드(`makeGitlabHeaders`, `getSingleMergeRequest`, 등)가 작은 단위로 잘 나누어져 있어 다른 상황에서도 재사용 가능하다.

**개선해야 할 점:**
- `makeCodeReviewWhenCalledByWebhook` 메서드는 여러 로직을 포함하고 있어 너무 길고 복잡하다. 이 메서드는 여러 개의 서브 메서드로 분리하여 더 나은 재사용성을 위해 구성하자. 예를 들어, 리뷰 생성 요청을 별도의 메서드로 나누는 게 좋겠다.

### 4. 신뢰성 (Reliability)
**잘 수행된 점:**
- `@Transactional` 어노테이션을 적절히 사용하여 원자성을 보장하는 부분은 잘 처리된 점이다.
- API 응답을 다룰 때 `ResponseEntity`를 사용한 부분이 좋다.

**개선해야 할 점:**
- 예외 처리가 현재 매우 sparse해 보인다. API 호출 실패나 DB 불일치 등에 대해 적절한 예외 처리를 추가하라. 예외가 발생했을 때 시스템이 어떻게 반응하는지 명확히 해놓는 게 중요하다.

### 5. 보안성 (Security)
**잘 수행된 점:**
- `gitlabAccount.getUserToken()`과 같이 사용자 토큰을 사용해 API를 호출하는 부분이 있는 것은 긍정적이다.

**개선해야 할 점:**
- 사용자 입력을 검증하는 로직이 보이지 않는다. 특히 API에 전달되는 파라미터에 대한 검증이 필요하다. SQL 인젝션이나 XSS 공격 방지를 위해 검증 로직을 추가하라.

### 6. 유지보수성 (Maintainability)
**잘 수행된 점:**
- 코드 구조가 비교적 명확하여 새로운 개발자들이 이해하기 용이하다.

**개선해야 할 점:**
- 그럼에도 불구하고, 새로운 필드나 계산이 추가될 가능성이 있다면, 모든 관련 쿼리와 API 호출이 어떻게 영향을 받을지를 명확히 주석으로 남기는 게 좋다. 또한, 객체 패턴을 사용하여 관련 프로그램이 함께 묶일 수 있는 방법도 고려해야 할 것이다.

### 전체적인 피드백:
- 전반적으로 코드가 잘 구성되어 있으나, 가독성에 있어 주석 부족, 예외 처리, 그리고 합당한 메서드 분리가 부족한 것으로 보인다. 이러한 부분에 대한 신경을 쓰면 코드는 더 발전할 것이다.
- 협업 시 발생할 수 있는 오류나 혼란을 줄이기 위해 코드를 개선하는 데 집중하라. 각 절차와 흐름이 명확히 드러날 수 있도록 해야 한다. 
- 특히 보안 관련 부분은 여전히 취약할 수 있으니, 필히 조치를 취하도록 해라. 

피드백 끝. 변경사항 잘 반영해주길 바란다.');
INSERT INTO public.review VALUES ('2024-11-13 12:33:38.493038', 92, '2024-11-13 12:33:38.493038', 18, '코드 리뷰 요청에 대한 심도 있는 피드백을 제공할게. 현재 코드 변경 사항에 대해서는 여러 측면에서 잘하고 있는 부분과 개선이 필요한 부분이 있다. 아래 항목별로 자세히 설명할게.

1. **Readability (가독성)**:
   - **잘한 부분**: 전반적으로 변수명과 함수명이 명확하여 이해하는 데 큰 어려움이 없다. `findFirstByMrInfoOrderByCreatedDateAsc` 같은 함수명은 어떤 작업을 하는지 명확히 드러낸다.
   - **개선이 필요한 부분**: 코드의 주석이 부족해. 예를 들어, 주요 비즈니스 로직이나 복잡한 작업을 수행하는 곳에는 주석을 추가해서 의도를 명확히 해둘 필요가 있어. `sseService.notify` 호출 앞 뒤에 간단한 주석을 달아주는 것이 좋겠어.

2. **Consistency (일관성)**:
   - **잘한 부분**: 오류 코드와 예외 처리 부분에서 일관된 형식으로 작성된 점은 긍정적이야. 에러 코드들 또한 일관된 패턴으로 정의해 놓은 부분이 잘 보였어.
   - **개선이 필요한 부분**: 에러 코드의 주석이 약간씩 다르게 구성되어 있어. 주석 포맷이나 설명이 일관되지 않아서 혼란을 줄 수 있어. 예를 들어, `MR_INFO(B000)`나 `GITLAB(C000)` 등의 규칙을 정리해서 통일감 있게 사용할 필요가 있어.

3. **Reusability (재사용성)**:
   - **잘한 부분**: 다양한 서비스에서 사용할 수 있도록 기능을 잘 분리해서 작성했어. 예를 들어, `saveRetrievals` 메서드는 특정 기능에 대해 독립적으로 작성되어 있어 다른 곳에서도 재사용할 수 있을 것 같아.
   - **개선이 필요한 부분**: `SseService` 클래스 같은 경우, 다른 종류의 알림 서비스를 통합할 수 있도록 인터페이스를 추가하는 가능성을 고려해봐. 재사용성을 높이려면 다양한 호출에 대한 일관된 알림 방식이 필요해.

4. **Reliability (신뢰성)**:
   - **잘한 부분**: 예외 처리 방식이 개선되어서 실패 시 적절한 에러 메시지를 던지는 것으로 보여. `BusinessException`을 사용하여 더 명확하게 에러를 관리하는 점이 좋아.
   - **개선이 필요한 부분**: 예외가 발생했을 때의 처리 경로에 대한 배려가 부족한 것 같아. 지금은 단순히 예외를 던지는 것으로 끝나는데, 예외 발생 시 롤백이나 오류 로깅 등을 더 철저히 고려해야 해.

5. **Security (보안성)**:
   - **잘한 부분**: 입력 값 검증을 잘 하고 있어. `BusinessException`을 사용하여 사용자 입력에 대해 적절히 검증하는 부분이 파악돼.
   - **개선이 필요한 부분**: 클라이언트와의 데이터 전송 시 민감한 정보를 보호하기 위한 방법이 부족해 보여. `gitlabUrl`이나 `token` 같은 민감한 데이터는 로깅을 하지 않도록 주의해야 해. 또한, 더 철저한 입력 검증을 고려해봐.

6. **Maintainability (유지보수성)**:
   - **잘한 부분**: 코드가 모듈화되어 있어서 수정이나 기능 추가가 비교적 용이할 것 같다. 트랜잭션을 적절히 사용함으로써 데이터 무결성을 유지하는 부분이 좋았어.
   - **개선이 필요한 부분**: 논리적으로 변경된 코드의 의도를 명확히 하고 다양한 조건에 대한 처리를 강화해. 특히, 다른 개발자들이 이해하기 쉽도록 전체적인 흐름이나 주요 함수의 의도를 문서화해두는 것이 좋겠어.

**전체적인 피드백**: 
- 코드의 전반적인 구조와 방법론이 매끄럽고 잘 작성되었다는 점에서 긍정적이야. 특히 예외 처리가 개선되었고, 사용자에게 제공하는 정보들이 잘 정리된 부분이 좋아. 
- 하지만 세부적인 멘체와 명확한 주석 부족, 보안성을 더 강화해야 하는 점 등은 주의를 기울여야 해. 코드의 유지보수성 및 일관성을 더욱 향상시키기 위해 명확한 지침을 정리해두면 좋겠어. 

이런 부분들에서 더 발전해 나가길 바라.');
INSERT INTO public.review VALUES ('2024-11-13 12:35:27.585432', 93, '2024-11-13 12:35:27.585432', 19, '코드 리뷰 요청을 받았어. 한 번 살펴보면서 각 항목에 대한 평가와 개선점을 정리해 볼게. 

### 1. Readability (가독성)
- **잘 된 부분**: 함수명과 변수명은 전반적으로 의미가 명확해. `makeCodeReviewWhenCalledByWebhook`나 `regenerateReview` 같은 이름은 기능을 잘 설명해 줘. 주석도 필요한 곳에 적절히 달려 있어 나쁘지 않아.
- **개선이 필요한 부분**: `MrContent`와 같은 자료형이 어떤 의미를 가지는지에 대한 설명이 부족해. 좀 더 구체적으로 설명을 추가해 줘야 가독성이 높아질 듯 해. `gitLabClient.getMrDiffs()` 같은 부분에 대한 주석도 추가하면 좋을 것 같아. 이 함수가 어떤 데이터를 반환하는지 명시해 주면 다른 개발자들이 이해하는 데 도움이 될 거야.

### 2. Consistency (일관성)
- **잘 된 부분**: 전체적으로 코딩 스타일이 일관되게 유지되고 있어. 예를 들어, `param` 주석을 사용하는 방식이 잘 정리되어 있어.
- **개선이 필요한 부분**: `@Query` 어노테이션 사용 시 주석을 통해 함수에 대한 설명이 없다는 점이 아쉬워. 주석을 추가하여 어떤 쿼리가 어떤 목적을 가지고 있는지 설명하면, 코드가 더 통일감을 줄 수 있을 거야.

### 3. Reusability (재사용성)
- **잘 된 부분**: `MrContent`와 같은 클래스를 통해 기능을 잘 분리하고 있어서 다른 상황에서도 재사용할 가능성이 보여.
- **개선이 필요한 부분**: `gitLabClient.getMrDiffs()`와 같은 외부 API 호출 부분이 여러 군데서 반복 사용되고 있는데, 이를 공통적으로 호출할 수 있는 메소드를 하나 만들어서 코드 중복을 줄이면 좋을 것 같아.

### 4. Reliability (신뢰성)
- **잘 된 부분**: 주어진 파라미터에 대한 유효성을 체크하는 부분이 존재해. 이를 통해 예외 발생을 줄일 수 있어.
- **개선이 필요한 부분**: 예외 처리 부분이 부족해. API 호출 시 실패 가능성이 높기 때문에, 실패시 어떻게 처리할지에 대한 로직이 필요해 보여. `gitLabClient.getMrDiffs()`가 실패할 경우를 대비한 예외 처리 로직을 추가해 줘야 해.

### 5. Security (보안성)
- **잘 된 부분**: 민감한 정보(예: `gitlabUrl`, `token`)를 함수 인자로 받아서 사용하는 구조는 좋지만, 코드 내에 전혀 보안적으로 신경 쓰고 있다는 느낌이 없어.
- **개선이 필요한 부분**: 입력 후 검증이 전혀 없다. 사용자 입력을 받아서 처리하는 부분이 많으니, 이를 검증하는 로직을 추가해야 해. 예를 들어, `gitlabUrl` 같은 경우는 형식 검증을 하여 잘못된 값을 사전에 처리해야 해.

### 6. Maintainability (유지보수성)
- **잘 된 부분**: 코드의 모듈화가 잘 되어 있어서 각 부분의 독립성이 강조되어 있음.
- **개선이 필요한 부분**: 단일 책임 원칙에 따라 함수가 너무 많은 책임을 가지고 있어. 리턴되는 객체를 생성하는 과정이 복잡한데, 각 객체에 대한 생성을 별도의 유틸리티 클래스로 분리하면 유지보수성이 좋아질 것 같아.

### 전체적인 피드백
코드 전반적으로는 잘 작성된 부분이 많아. 함수 이름과 변수 이름이 명확하게 의도를 표현하고 있어. 그러나 예외 처리와 보안 측면에서는 개선이 필요해 보여. 또한, 각 기능을 좀 더 모듈화하여 책임을 분리한다면 유지보수 성능이 높아질 거야.

이제 변경한 코드에서 발생할 수 있는 컴파일 에러나 런타임 에러는 강력히 수정해야 한다고 권장할게. 이런 부분에서 문제 생기면 시스템 전체에 제법 큰 영향이 갈 수 있으니 말이지.');
INSERT INTO public.review VALUES ('2024-11-13 12:40:19.487154', 94, '2024-11-13 12:40:19.487154', 19, '여기 네가 요청한 코드 변경사항에 대한 리뷰를 남길게. 각 항목별로 평가하고 필요한 피드백을 제공할게.

### 1. **Readability (가독성)**:
- 코드 전반적으로 어느 정도 가독성이 유지되고 있어. 하지만 `LocalDateTime lastReviewCreatedAt` 같은 변수 이름은 어떤 의미를 담고 있는지 조금 더 명확하게 표현할 수 있을 것 같아. 예를 들어, `lastReviewCreatedAt`을 `latestReviewCreationDate`로 변경하면 더 직관적일 수 있어.
- 주석이 부족해. 기능이 무엇인지, 주요 로직을 설명하는 주석이 있으면 코드를 이해하는 데 도움이 더 될 거야. 예를 들어, `findLatestReviewDateByGitlabMrIid` 메서드 상단에 간단한 주석 추가를 고려해.

### 2. **Consistency (일관성)**:
- 코딩 스타일은 일관되게 유지되고 있긴 한데, 변수를 선언하는 스타일(위치를 정리하는 방식)에 대해 조금 일관성을 잃고 있어. 예를 들어, 변수 선언 후 바로 사용하면 더 좋을 것 같아. 코드 전반에서 선언과 사용 간의 구조를 통일하면 읽기 쉽게 개선할 수 있어.

### 3. **Reusability (재사용성)**:
- 이 코드에서 작성된 메서드들이 준수한 재사용성을 보이는 건 사실이야. 하지만 `createGitlabMrResponse` 메서드는 `mrInfoRepository`에 의존하고 있는데, 이 메서드를 테스트하거나 다른 컨텍스트에서도 사용하려면 좀 더 독립적으로 작성되는 것이 좋을 것 같아. 예를 들어, `GitlabMrDetailContent`와 `Boolean`을 인자로 받아 처리하는 형태로 리팩토링 할 수 있어.

### 4. **Reliability (신뢰성)**:
- 데이터 조회 부분에서 예외 처리가 부족해 보여. `mrInfoRepository.findLatestReviewDateByGitlabMrIid`가 데이터를 찾지 못했을 때, 즉 `null`을 반환할 때 어떤 처리를 해야 하는지 명확히 정의되어 있지 않아. 이럴 경우 `Optional`을 사용해 null 체크 후 처리하는 방법을 고려해봐.

### 5. **Security (보안성)**:
- 지금 코드에서 특별히 보안상 문제가 있는 부분은 보이지 않아. 다만, `@Param` annotation을 사용할 때 SQL 인젝션 공격을 방지하기 위해 입력값에 대한 검증을 고려하는 게 좋은 접근이야. 현재로서는 괜찮지만, 모든 외부 입력에 대한 검증이 필요해.

### 6. **Maintainability (유지보수성)**:
- 기본적으로 유지보수성은 잘 고려된 부분이 있어. 기능이 모듈화되어 있지만, DRY 원칙을 더욱 엄격히 적용하는 것이 좋겠어. 예를 들어, 다른 서비스나 메서드에서 동일한 로직이 반복된다면, 그 로직을 함수화하거나 별도의 클래스로 분리해서 재사용할 수 있게 하면 좋겠어.

### **전체적인 피드백**:
- 전체적으로 소스 코드는 명확한 구조를 유지하고 있어 긍정적이야. 하지만 위에 언급한 몇 가지 사항들이 추가된다면, 더욱 개선된 품질의 코드가 될 수 있을 거야. 
- 특히 예외 처리를 더욱 철저히 하고, 주석을 적절히 추가해주는 것이 중요해. 이런 세부 사항들이 누적되면 코드의 신뢰성을 높이고, 다른 개발자들이 이해하는 데 큰 도움이 될 거야.

향후에는 이러한 점들을 반영해서 더 나은 코드를 작성하는 데 주의하길 바래. 잘 수행한 부분은 긍정적으로 평가하되, 개선해야 할 부분은 분명하게 드러내서 더 나은 결과물을 만들어가길 바라.');
INSERT INTO public.review VALUES ('2024-11-13 12:44:46.665', 95, '2024-11-13 12:44:46.665', 19, '야, 코드 좀 봤는데, 전반적으로 괜찮은 부분도 있긴 한데 개선해야 할 점도 눈에 띄어. 평가 항목에 맞춰서 자세히 설명해줄게. 

### 1. **Readability (가독성)**
- **잘된 부분**: 변수명이나 메서드명이 대체로 직관적이긴 해. 특히 `createGitlabMrResponse` 같은 이름은 그 역할을 잘 설명하고 있어서 좋았어.
- **개선할 점**: `isAiReviewCreated` 같은 변수는 약간 긴데, `aiReviewCreated`처럼 줄여도 충분히 의미가 전달돼. 여기에 주석도 추가해주면 코드의 의도가 더 명확해질 거야.

### 2. **Consistency (일관성)**
- **잘된 부분**: 코드 스타일이 일정하게 잘 유지되고 있어. 각 메서드와 클래스의 구성이 비슷하게 되어 있어 눈에 띄는 큰 통일성이 있어.
- **개선할 점**: 일부 공백이 불규칙하게 들어가 있어. 예를 들어, метод와 매개변수 사이에 공백 처리 일관성을 더 신경 써야 해. Prettier 같은 툴을 사용해서 자동 정리를 고려해봐.

### 3. **Reusability (재사용성)**
- **잘된 부분**: `GitlabMrResponse`에서 데이터를 잘 처리하도록 메서드가 분리되어 있어서 재사용 가능성이 높단 말이야.
- **개선할 점**: `createGitlabMrResponse` 메서드가 `mrInfoRepository`에 대한 의존성이 강해. 이 부분은 DI(Dependency Injection)로 처리하면 더 재사용 가능한 구조가 될 거야.

### 4. **Reliability (신뢰성)**
- **잘된 부분**: 데이터베이스 쿼리가 잘 짜여져 있는 것 같아. `findLatestReviewDateByGitlabMrIid` 메서드가 잘 작동할 것 같아 보이고, 의도하는 데이터를 잘 가져올 것 같아.
- **개선할 점**: `LocalDateTime lastReviewCreatedAt`을 찾기 전에 `gitlabMrIid`가 null인지 체크하는 부분이 없어. 예외 처리도 고려해서 이런 케이스를 추가하면 더 좋을 거야.

### 5. **Security (보안성)**
- **잘된 부분**: 현재 코드에 민감한 데이터 처리를 다룰 부분은 없는 것 같아.
- **개선할 점**: 데이터베이스에서 조회할 때 입력값에 대한 검증이 필요해. 혹시라도 잘못된 데이터가 들어가면 예기치 않은 문제가 생길 수 있으니까. 이를 위해 입력값에 대한 검증 로직을 추가하는 게 좋겠어.

### 6. **Maintainability (유지보수성)**
- **잘된 부분**: 클래스와 메서드가 명확하게 역할을 나누고 있어. 유지보수하기 좋을 구조라고 생각해.
- **개선할 점**: `LocalDateTime lastReviewCreatedAt`를 사용하는 곳에 대한 문서화를 좀 더 하는 게 좋겠어. 이 필드가 어떻게 활용되는지에 대한 명확한 설명이 없다면, 나중에 다른 사람이 혼란스러울 수 있어.

### **전체적인 피드백**
전반적으로 코드가 잘 구성되어 있지만, 몇 가지 아쉬운 점들은 해결해야 해. 특히 예외 처리와 입력 검증은 꼭 추가해야 할 필요가 있어. 이런 부분들이 보완된다면, 코드의 품질이 상당히 향상될 거야. 그리고, 간단한 코딩 스타일 관련 도구를 활용하면 코드에 대한 일관성을 지속적으로 유지할 수 있을 거라고 생각해. 

개선 방향을 잘 살펴보고, 수정작업에 들어가는 게 좋겠어!');
INSERT INTO public.review VALUES ('2024-11-13 12:45:54.73845', 96, '2024-11-13 12:45:54.73845', 19, '### 코드 리뷰

변경된 코드에 대한 리뷰를 진행하겠습니다. 다음은 각 항목에 대한 분석과 피드백입니다.

1. **Readability (가독성)**:
   - **잘 수행된 부분**: `GitlabMrResponse`와 `createGitlabMrResponse` 함수의 구조가 비교적 명확해, 코드의 흐름을 이해하기 쉽다. 함수와 데이터 클래스의 이름도 해당 역할을 잘 설명해주고 있다.
   - **개선 필요 부분**: `LocalDateTime lastReviewCreatedAt`와 같은 변수를 사용할 때, 무엇을 나타내는지 명확하긴 하지만 해당 변수의 목적을 설명하는 주석이 부족하다. 예를 들어, "최근 리뷰 생성 날짜"라는 주석을 추가하여 다른 개발자들이 이해하는 데 도움을 줄 수 있다. 주석을 추가하여 가독성을 높일 필요가 있다.

2. **Consistency (일관성)**:
   - **잘 수행된 부분**: 코드 스타일이 일정하게 유지되고 있으며, Java의 기본 스타일 가이드를 잘 준수하고 있다.
   - **개선 필요 부분**: 일관된 네이밍 규칙이 적용되고 있지만, 일부 경우에 변수 이름에서 `r`과 같은 짧은 명칭을 사용하는 것은 비직관적일 수 있다. 변수 이름의 의미를 좀 더 명확하게 하기 위해, `review`와 같이 좀 더 구체적인 이름을 사용하는 것이 좋겠다.

3. **Reusability (재사용성)**:
   - **잘 수행된 부분**: `GitlabMrResponse`가 객체로 잘 정의되어 있어, 여러 부분에서 재사용 가능한 구조로 설계되어 있다.
   - **개선 필요 부분**: 현재 `createGitlabMrResponse` 메서드가 특정 데이터에 종속적인 경우가 있으므로, 인자에서 `GitlabMrDetailContent`와 같은 특정 클래스에 의존하게 되면 재사용성이 떨어진다. 인자를 통해 더 일반적인 형태로 파라미터를 받을 수 있도록 분리하면 좋겠다. 예를 들어, 인터페이스나 추상 클래스 등을 활용하면 재사용성이 높일 수 있겠다.

4. **Reliability (신뢰성)**:
   - **잘 수행된 부분**: `findLatestReviewDateByGitlabMrIid` 메서드가 존재하고, 이를 통해 데이터를 잘 가져오는 구조로 되어 있다.
   - **개선 필요 부분**: `LocalDateTime lastReviewCreatedAt`을 호출한 후, null 체크를 통해 예외 처리나 기본값 설정(예를 들어, `null`일 경우 `LocalDateTime.now()` 등을 사용)을 추가하는 것이 필요하다. 이렇게 하면 의도하지 않은 상태에서 발생할 수 있는 런타임 에러를 예방할 수 있다.

5. **Security (보안성)**:
   - **개선 필요 부분**: 현재 코드에는 명시적으로 보안 관련 코드가 보이지 않는다. 예를 들어, 데이터베이스 쿼리에서 악의적인 입력을 피하기 위해 추가적인 검증 메커니즘을 도입하는 것이 필요하다. 사용자 입력에 대한 검증(leverage validation frameworks)과 같은 기본 보안 수칙을 준수해야 한다.

6. **Maintainability (유지보수성)**:
   - **잘 수행된 부분**: 코드가 잘 모듈화되어 있어 각 기능별로 분리되어 있다.
   - **개선 필요 부분**: 일부 메서드가 긴 경우가 있어, 기능을 별도의 클래스로 분리하거나 메서드를 더 작고 간결하게 만드는 것이 유지 보수성을 높이는 데 유리할 것이다. `createGitlabMrResponse`처럼 기능이 많아지면 후에 유지보수가 힘들어진다.

### 전체적인 피드백
- **잘 수행된 부분**: 코드 전반적으로 구조가 잘 잡혀 있고 명확하게 의도가 드러나는 것이 좋은 점이다. 특히, 데이터 전송 객체와 같은 부분에서 잘 설계된 점이 돋보인다.
- **개선 필요 부분**: 가독성과 유지 보수성을 높이는 방안으로, 명확한 주석 작성을 강조하고, 함수와 변수의 이름을 좀 더 구체적인 의미로 개선하는 것이 필요하다. 또한, 예외 처리 측면과 입력 검증에서 보안을 강화해야 한다.

코드는 전체적으로 괜찮지만, 작은 부분들을 개선함으로써 더욱 견고하고 유지보수가 쉬운 구조로 만드는데 집중하길 바란다.');
INSERT INTO public.review VALUES ('2024-11-13 12:57:14.385108', 97, '2024-11-13 12:57:14.385108', 19, '코드 변경 사항을 검토해보니 여러 가지 긍정적인 요소와 개선할 필요가 있는 점들이 눈에 띈다. 아래에서 각 평가 항목에 대해 구체적으로 피드백을 제공할게.

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명과 메서드명이 비교적 이해하기 쉬워, 소스 코드 읽기가 수월해. 특히 `createGitlabMrResponse`는 어떤 작업을 수행하는지 명확하게 나타내고 있어.
- **개선이 필요한 부분**: `lastReviewCreatedAt`과 같은 변수명은 적절하지만, 좀 더 명확하게 `lastReviewCreationTime`으로 수정하면 좋겠어. 이런 변화는 시간이 언제 생성되었는지 더 명확히 하여 가독성을 높일 수 있어. 주석이 전반적으로 부족한데, 주요 로직에 대한 설명이 비어 있어서 각 함수의 목적을 이해하는 데 어려움이 있을 가능성이 있어. 이 부분은 꼭 보완해야 해.

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 스타일이 전반적으로 일관되며, 필요한 import 구문은 정리되어 있어. 
- **개선이 필요한 부분**: 일부 필드의 이름이 영어와 한국어를 혼용하여 사용하고 있는데, 예를 들어 클래스명이나 변수명을 일관되게 영어로 통일하는 것이 좋겠어. 이렇게 하면 코드 가독성이 더욱 높아져.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: `GitlabMrResponse`와 같은 DTO(Data Transfer Object) 패턴을 사용하는 것은 코드 재사용성을 높이는 좋은 접근이야.
- **개선이 필요한 부분**: 디비 쿼리에 관련된 메서드들을 좀 더 독립적으로 분리하여 다른 기능에서도 활용할 수 있도록 하면 좋겠어. 예를 들어, 리뷰 날짜를 조회하는 로직을 별도의 유틸리티 함수로 빼내면 코드가 더욱 재사용 가능해질 거야.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: `existsByGitlabMrIid` 같은 메서드를 사용하여 존재 여부를 체크함으로써 기본적인 신뢰성을 확보하고 있어.
- **개선이 필요한 부분**: 예외 처리 부분이 전혀 보이지 않아. DB 조회 또는 데이터 변환 과정에서 예외가 발생할 수 있으므로, try-catch 문을 적절히 활용해 예외를 처리할 필요가 있어. 예를 들어, `LocalDateTime`을 null로 반환할 경우에 대한 처리 로직이 필요해.

### 5. **Security (보안성)**
- **잘 수행된 부분**: `@Param` 어노테이션을 통해 쿼리 파라미터를 검증하는 점은 좋았어.
- **개선이 필요한 부분**: 그러나, 입력 값 검증이 부족해. 즉, `gitlabMrIid`와 같은 파라미터에 대해 유효성 검사를 추가해주면 좋겠어. 이를 통해 SQL 인젝션과 같은 보안 문제를 방지할 수 있어.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 클래스와 메서드가 기능별로 잘 나눠져 있고, 코드가 명료하여 처음 보는 사람도 이해하기 쉬워.
- **개선이 필요한 부분**: 그러나, 메서드가 하나의 책임만 가지도록 조금 더 분리할 필요가 있어. `createGitlabMrResponse` 함수 내에서 DB도 호출하고 response도 생성하는 일은 단일 책임 원칙에 어긋나. 이런 경우, DB 호출과 데이터 변환 로직을 별도의 메서드로 분리해 유지보수성을 향상시켜야 해.

### **전체적인 피드백**
이 코드는 전반적으로 잘 작성되었지만, 몇 가지 주요한 개선 포인트가 있어. 가독성과 신뢰성을 높이기 위해 주석 추가와 예외 처리를 고려해야 한다. 보안 측면에서도 추가적인 입력 검증이 필요하며, 코드의 재사용성을 높이기 위해 기능을 더 철저히 분리하는 것이 필요해. 물론 잘 작성된 부분들에 대해서는 칭찬하고 싶은 부분이 많으니, 앞으로도 이런 방향으로 개선해 나가길 바라! 

마지막으로, 컴파일 에러나 런타임 에러가 발생할 수 있는 부분에 대한 체크를 철저히 할 것을 강하게 권장해. 이건 소프트웨어 개발에서 가장 기본적이고 필수적인 부분이니까!');
INSERT INTO public.review VALUES ('2024-11-13 12:57:38.994948', 98, '2024-11-13 12:57:38.994948', 19, '안녕하세요. 코드 리뷰 요청을 확인했습니다. 변경 사항을 바탕으로 다음과 같이 피드백을 드리겠습니다.

### 1. 가독성 (Readability)
- **잘 수행된 부분**: 전반적으로 코드가 구조화되어 있어 가독성이 좋습니다. 특히, `GitlabMrResponse`와 `MergeRequestService`의 메서드 이름이 그 기능을 잘 표현하고 있습니다.
- **개선이 필요한 부분**: `lastReviewCreatedAt` 변수가 어떤 데이터를 나타내는지에 대한 설명이 부족합니다. 각 매개변수에 대한 주석을 추가하면 이해하는 데 도움이 됩니다. 예를 들어, `LocalDateTime lastReviewCreatedAt`에 대한 명확한 설명 주석을 달아 주세요.

### 2. 일관성 (Consistency)
- **잘 수행된 부분**: 기존 코드 스타일과 일관성을 잘 유지하며, 타이핑 규칙 등도 맞춰져 있습니다.
- **개선이 필요한 부분**: Lombok을 사용하는 경우 특정 어노테이션의 사용이 일관되지 않을 수 있습니다. 예를 들어, 필드에 대한 getter/setter가 필요하지 않다면, 특정 어노테이션을 통일하여 사용해 보세요. 이를 통해 가독성과 일관성을 더욱 향상할 수 있습니다.

### 3. 재사용성 (Reusability)
- **잘 수행된 부분**: `GitlabMrResponse`가 데이터 전송 객체로 활용되며, 해당 객체가 재사용될 여지가 있어 보입니다.
- **개선이 필요한 부분**: `createGitlabMrResponse` 메서드 안의 `findLatestReviewDateByGitlabMrIid` 메서드는 만약에 똑같은 패턴이 계속 나오면 서비스 레이어에서 분리하는 것이 좋습니다. 특정 기능을 다루는 별도의 헬퍼 클래스를 고려해 보세요.

### 4. 신뢰성 (Reliability)
- **잘 수행된 부분**: `findLatestReviewDateByGitlabMrIid` 메서드를 통해 리뷰 생성일을 안전하게 가져올 수 있도록 구현한 점이 긍정적입니다.
- **개선이 필요한 부분**: 데이터베이스에서 값을 가져오는 경우 null 체크를 하지 않으면 NPE(Null Pointer Exception)가 발생할 수 있습니다. `.of(...)` 메서드 호출 전에 `lastReviewCreatedAt`이 null일 경우의 처리 로직이 필요해 보입니다. 예를 들어, 기본값을 설정하거나 예외 처리를 추가해야 합니다.

### 5. 보안성 (Security)
- **잘 수행된 부분**: 현재 입력값이 SQL 쿼리에서 안전하게 매핑되는 모습입니다.
- **개선이 필요한 부분**: 예외적으로 리뷰 생성일을 가져오는 쿼리의 결과가 null이 아닐 때의 처리를 명확히 하는 것도 중요합니다. 만약 값이 없을 경우 사용자에게 적절한 메시지를 제공하도록 구현해 보세요.

### 6. 유지보수성 (Maintainability)
- **잘 수행된 부분**: 코드의 구조가 잘 나뉘어 있어 각 기능이 특정 모듈에 집중되어 있습니다.
- **개선이 필요한 부분**: 앞으로 새로운 필드가 추가되는 상황을 대비해 `GitlabMrResponse`와 같은 DTO를 정의하고, 요구사항에 따라 유연하게 클래스를 확장할 수 있는 구조가 필요합니다. 또한, 새로운 기능이 추가될 때 각각의 메서드 책임이 분명한지 점검해 주세요.

### 전체적인 피드백
- 코드 전반적으로 잘 구성되어 있으며, 개별 메서드의 역할이 명확하게 정의되어 있어 가독성과 유지보수성이 뛰어납니다. 그러나, null 처리 및 예외 처리 부분에서 신뢰성을 더욱 높일 수 있는 여지가 보입니다.
- 주석이 부족한 부분을 보완하고, 새로운 필드 추가 시의 대응 체계를 세우는 것은 매우 중요합니다. 이 부분을 통해 코드의 질이 더욱 향상될 것입니다. 

변경 사항을 통해 향후 시스템의 안정성과 성능을 높일 수 있기를 바랍니다. 버그가 발생할 여지가 있는 부분은 반드시 수정하고 개선 방향을 모색해 주세요.');
INSERT INTO public.review VALUES ('2024-11-13 13:00:39.496061', 99, '2024-11-13 13:00:39.496061', 22, '코드 리뷰 요청에 대한 피드백을 다음과 같이 작성할게.

### 1. **readability (가독성)**:
- **잘 된 점**: 전반적으로 코드가 명확하고 각 메서드의 역할이 잘 드러난 것 같아. `createEmitter` 메서드에서의 SSE 연결 처리가 잘 정의되어 있어서 쉽게 이해할 수 있어.
- **개선점**: 그러나 로그 메시지의 가독성을 높이기 위해 `String.format()`을 사용하는 것도 좋겠어. 예를 들어, `log.info("SSE connection completed for id: " + id);` 대신 `log.info("SSE connection completed for id: {}", id);`와 같이 변경하면 성능과 가독성이 좋아. 그리고 중요한 부분, 예를 들어 오류 처리 부분에는 주석을 추가해서 나중에 다른 사람들이 이해하기 쉽도록 하면 좋겠어.

### 2. **consistency (일관성)**:
- **잘 된 점**: 메서드 명명 규칙과 클래스 구조가 일관되게 잘 되어 있어. 예를 들어, SSEEmitter와 관련된 메서드들이 명확하게 네이밍 되어 있어서 기능을 인식하기 쉬워.
- **개선점**: 하지만 전체적으로 커밋 메시지가 구체성이 떨어져. 커밋 메시지는 왜 변경했는지, 어떤 맥락에서 이 작업을 했는지 명확하게 적어야 해. 그렇지 않으면 미래에 이 변경의 이유를 이해하기 어려울 수 있어.

### 3. **reusability (재사용성)**:
- **잘 된 점**: `sendToClient` 메서드는 매개변수를 통해 다양한 데이터 타입을 처리할 수 있도록 잘 설계되어 있어. 향후 다른 유사한 로직에서도 재사용하기 좋을 것 같아.
- **개선점**: 그러나 `sendToClient` 메서드에 포함된 JSON 변환 로직은 분리할 수 있을 것 같아. 이를 별도의 유틸리티 메서드로 분리하면 다양한 컨텍스트에서 JSON 변환을 재사용하고, 메서드도 더 깔끔해질 수 있어.

### 4. **reliability (신뢰성)**:
- **잘 된 점**: 다양한 상태(완료, 타임아웃, 에러)에 대해 잘 처리하고 있어. 특히 연결 오류 시 로그를 출력하는 것은 훌륭해.
- **개선점**: 하지만 오류 발생 시 단순히 `RuntimeException`을 던지는 것보다 특정 예외를 정의하여 더 명확한 오류 처리를 하면 좋겠어. 예를 들어, 실패 원인이나 어떤 상태에서 발생했는지 더 자세히 알 수 있게 하는 거지.

### 5. **security (보안성)**:
- **잘 된 점**: 민감한 데이터를 처리하는 부분에서 `gitlabAccount.getUserToken()` 같은 부분은 잘 관리되고 있는 것 같아.
- **개선점**: 하지만 에러 처리 부분에서는 `System.err.println` 대신 적절한 로깅 라이브러리를 사용해. 이는 로그 파일이나 모니터링 시스템에 더 효과적으로 기록될 수 있어. 또한, 사용자 입력 검증이 필요한 부분이 보면 있을 수 있으니, 예외적인 상황에 대비해 검증 로직을 강화해야 해.

### 6. **maintainability (유지보수성)**:
- **잘 된 점**: 기능 분리가 잘 되어 여러 로직이 모듈화되어 있어서 변경하기 쉽겠어.
- **개선점**: 그러나 장기적으로 보면, 복잡성이 증가할 수 있는 영역에 대해서는 추가적인 문서화가 필요해. 예를 들어, `regenerateReview` 메서드 같은 경우 어떤 데이터를 어떻게 처리하는 것인지에 대한 설명이 부족해. 각 메서드에 대한 명세를 주석으로 남기면 나중에 유지보수가 쉬워질 거야.

### 전체적인 피드백:
전반적으로 코드가 잘 작성되어 있어. 특히 SSEEmitter 처리 부분에서의 임시 처리 로직이 명확하다는 점은 칭찬할 만해. 하지만 몇 가지 부문에서 아쉬운 점이 보이는데, 특히 일관성과 가독성 면에서 개선할 여지가 있어. 추후 코드 변경 시 위의 피드백을 잘 반영해서 좋은 코드로 발전시켰으면 좋겠어. 개선 사항이 잘 반영된다면 앞으로의 유지보수와 확장성에 많은 도움이 될 거야.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:05:16.383773', 100, '2024-11-13 13:05:16.383773', 22, '코드 리뷰를 진행할게. 이번 변경 사항에서 몇 가지 장점과 개선할 수 있는 점이 보여. 다음과 같이 각 항목별로 피드백을 줄게:

### 1. **Readability (가독성)**
- **잘한 점**: 코드가 전반적으로 직관적으로 작성되었고, 각 스레드가 비동기적으로 동작하는 부분이 명확하게 드러난다. `onCompletion`, `onTimeout`, `onError`의 람다 표현식도 적절하게 작성되어 있어.
- **개선해야 할 점**: 람다 안에 함수 로직이 들어가므로, 감지할 수 있는 구문을 사용해서 이들을 좀 더 명확하게 주석 처리하는 게 좋겠다.  
  ```java
  emitter.onCompletion(() -> {
      log.info("SSE connection completed for id: " + id);
      // Emitter를 저장소에서 삭제
      emitterRepository.deleteById(id);
  });
  ```
  와 같이 간단한 주석을 추가하면 협업 시 다른 팀원이 이해하기 더 쉬울 거야.

### 2. **Consistency (일관성)**
- **잘한 점**: 전반적인 코드 스타일은 깔끔하고, 명명 규칙도 일관성이 있다. 특히 로그 메시지가 통일된 형식을 가지고 있어서 좋음.
- **개선해야 할 점**: 로그를 다룰 때 `log.info`와 `log.error`를 사용하는 방식이 잘 유지되고 있지만, `emitter.complete()` 호출과 `deleteById(id)`를 나열할 때 둘의 위치를 바꿔야 할 것 같아. `complete`를 먼저 호출하고 삭제하는 게 더 명확하고 일관성이 있을 거야.

### 3. **Reusability (재사용성)**
- **잘한 점**: 각 비동기 처리 및 이벤트 핸들러가 독립적인 기능으로 잘 나뉘어져 있음. 따라서 다른 장소에서도 재사용할 수 있을 듯.
- **개선해야 할 점**: `emitter.onCompletion`, `emitter.onTimeout`, `emitter.onError`에서 동일한 `id` 호출이 반복되는 구조이므로, 이 코드를 여러 곳에서 사용하는 것을 방지하기 위해 공통 메소드를 만드는 것도 좋겠어. 예를 들어, `handleEmitterCleanup(Long id)`라는 메소드를 추가할 수 있어.

### 4. **Reliability (신뢰성)**
- **잘한 점**: 예외 처리 로직이 잘 구현되어 있음. JSON 변환 오류 및 IO 에러에 대한 처리도 좋고, 문제 발생 시 로그가 남는 점도 긍정적.
- **개선해야 할 점**: `RuntimeException`을 던지기보다는 사용자 정의 예외를 만들어서 좀 더 의미 있는 에러 처리를 하는 게 좋다. 그러면 이를 사용하는 쪽에서도 보다 명확하게 어떤 에러가 발생했는지 알 수 있을 거야.

### 5. **Security (보안성)**
- **잘한 점**: 현재 보안적인 요소는 잘 보강되고 있다. 다른 데이터가 아닌 `emitter`에 대한 처리만 하고 있어서 최소한의 공격 표면을 유지하고 있어.
- **개선해야 할 점**: 만약 `id`가 사용자에 의해 조작될 수 있는 값이라면, 이를 확인하여 인증 절차를 강화해야 해.  특히 외부에서 입력되는 매개변수에 대한 검증을 추가할 필요가 있어. 

### 6. **Maintainability (유지보수성)**
- **잘한 점**: 코드가 전반적으로 명확하게 구조화되어 있으니 유지 보수하기 좋다.
- **개선해야 할 점**: 변경 사항을 반영한 후, `emitter` 처리에 대한 논리가 혼란스러워질 수 있으므로, 이를 모듈화하여 관리하는 방안을 고려해 보는 것이 좋겠다.

### **전체적인 피드백**
- 잘 수행되고 있는 부분으로는 비동기 처리와 이벤트 로깅 부분을 높이 평가해. 더 나은 사용자 경험을 제공할 수 있는 중요한 요소야. 하지만 몇 가지 중복된 로직과 예외 처리에서 좀 더 명확한 코드로 개선할 수 있을 것 같아. 
- 거기다 입력 값 검증과 같은 보안적인 요소를 강화하면, 전체적인 코드 품질이 더욱 향상될 거야.

문제가 되는 부분은 앞으로 조금 더 개발팀 내에서 나름대로의 피드백과 협업을 통해 개선해 나가면 좋겠어. 잘하고 있으니 더 신경 써서 개발해 보도록 해!');
INSERT INTO public.review VALUES ('2024-11-13 13:07:05.569229', 101, '2024-11-13 13:07:05.569229', 22, '코드를 검토하고자 하니, 각 항목별로 상세한 평가와 피드백을 제공할게.

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 전반적으로 로그 메시지가 추가되어 코드의 작동 방식이 명확하게 드러난 점은 좋다. log 관련 코드가 추가됨으로써 트러블슈팅이 보다 수월해질 거라는 점에서 긍정적이야.
- **개선 필요한 부분**: 람다 표현식 내부에서 여러 줄의 코드가 사용되었기 때문에, 가독성 측면에서는 조금 힘들어진 것 같아. 이럴 때는 별도의 메서드로 해당 로직을 분리하고, 그 메서드에 의미 있는 이름을 붙이는 게 더 좋을 듯해. 예를 들어, `handleSseCompletion`, `handleSseTimeout` 같은 메서드로 분리하면 각 기능이 더 명확해질 거야.

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 기존의 코드 스타일과 일관되게 로그를 추가한 점은 좋다. 형식적으로 통일감을 주는 데 기여했어.
- **개선 필요한 부분**: 로그 메시지의 형식이 일관성이 떨어진 부분이 있어. 예를 들어, 오류 메시지에서 "SSE connection error for id" 라고 적힌 것과, "SSE connection timed out for id" 라는 메시지 구성이 다르니 형식을 통일하는 게 좋겠어. 모든 로그 메시지를 한 가지 스타일로 통일하는 게 코드의 일관성을 높여 줄 거야.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: SSE 관련 로직이 개별 메서드로 분리되어 있어서, 다른 부분에서 재사용 가능성이 높아졌어.
- **개선 필요한 부분**: 현재 SSE 처리 로직이 `SseService` 클래스에 집중돼 있는데, 이를 보다 구체적인 기능으로 가지고 있는 클래스로 분리하는 것도 고려해볼 만해. 예를 들어, `SseHandler` 같은 클래스를 만들어서 SSE 관련 로직을 모두 이곳에 두면, 추후에 SSE 관련 기능이 추가될 때 확장성과 재사용성이 더욱 높아질 거야.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 예외 처리 로직이 잘 작성되어 있는 점이 눈에 띈다. JSON 변환 과정에서 발생할 수 있는 예외를 적절히 처리하고 있고, 오류 발생 시 적절한 로그를 남기는 것은 좋다.
- **개선 필요한 부분**: `emitter.complete()` 메서드가 호출된 후에 바로 `emitterRepository.deleteById(id)`를 호출하는데, 여기에 대해 더 나은 처리 방법이 필요해. 연결이 완료되었으니 `deleteById`를 호출할 경우, `complete()`에 의해 더 이상 처리할 필요가 없다는 점도 반영해서 중복 호출을 줄이면 더 좋겠어.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 안전하게 로그를 출력하도록 한 점은 긍정적이고, 예외 발생 시 예외의 스택 트레이스와 함께 에러 로그를 남기는 것도 좋다.
- **개선 필요한 부분**: SSE로 전송되는 데이터에 대한 검증이 필요할 것 같아. `data` 매개변수는 신뢰할 수 있는 데이터인지 확인해야 하고, 만약 사용자 입력에 기반한 데이터라면 더 철저하게 방어 코드를 작성해야 해.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: SSE 처리 부분이 메서드로 잘 분리되어 있어 기본적인 유지보수성은 확보가 되어 있다.
- **개선 필요한 부분**: 변경 사항을 관리하기 위해 상수나 Enum을 사용하여 매직 넘버를 상징적으로 표현하는 방법을 적용하면 좋겠어. 예를 들어, 각 SSE 관련 상태에 대해 상수를 만들어 쓴다면, 코드 가독성이 높아지고 유지 관리가 더 쉬울 거야. 

### **전체적인 피드백**
전반적으로 로그 관련 처리와 예외 관리는 긍정적으로 평가할 수 있어. 그러나 몇 가지의 가독성, 일관성, 재사용성 측면에서 개선할 부분이 분명히 보이니, 향후 코드 수정 시 이 점을 염두에 두면 좋을 것 같아. 특히, 메서드 분리와 같은 구조적 개선이 이루어진다면, 유지보수와 확장 가능성이 더 높아질 거야. 

기본적으로 방향이 맞으니, 추가적인 개선 사항들을 반영한다면 더욱 좋은 코드가 될 것 같아. 잘 하고 있으니 방법만 수정해 나가면 돼.');
INSERT INTO public.review VALUES ('2024-11-13 13:10:41.129787', 102, '2024-11-13 13:10:41.129787', 22, '### 코드 리뷰

#### 1. Readability (가독성)
- **잘 수행되고 있는 부분**: `log.info`와 `log.error`를 사용하여 로그 출력을 적절히 추가한 점은 좋다. 이는 코드 흐름을 이해하는 데 큰 도움이 된다. 변수명도 대체로 명확하여 이해하기 쉽다.
- **개선이 필요한 부분**:
  - `id`와 같은 변수명은 조만간 도메인 별로 구체적인 이름으로 변경하는 것이 좋다. 예를 들어, `userId` 또는 `emitterId` 등으로 구체성을 높여라.
  - 각 콜백 함수에 대해 간단한 주석을 추가하면 더 이해하기 쉬울 것이다. 특히, 각각의 에러 핸들링이나 상황에 대한 설명은 후속 작업자에게 큰 도움이 된다.

#### 2. Consistency (일관성)
- **잘 수행되고 있는 부분**: 코드 스타일은 대체로 일관되며, Java의 관용구에 잘 맞춘 부분이 긍정적이다.
- **개선이 필요한 부분**:
  - `emitter.complete()` 호출은 코드를 단순화할 수 있으므로 주석으로 이를 사용하는 이유를 명시하면 좋겠다. 이로 인해 코드의 일관성을 높일 수 있다.
  - 로그 메시지를 일관되게 작성하는 것이 중요하다. 예를 들어 "SSE connection completed for id: " 대신 "SSE connection completed for emitterId: " 사용할 수 있다. 이렇게 하면 일관된 용어 사용이 가능해진다.

#### 3. Reusability (재사용성)
- **잘 수행되고 있는 부분**: `SseEmitter`의 생성과 관련된 코드를 별도의 메서드로 분리한 점은 재사용성을 높이는 좋은 시도다.
- **개선이 필요한 부분**:
  - 에러 처리 로직을 별도의 메서드로 추출하면 다른 곳에서 재사용할 수 있으며, 코드의 중복을 줄일 수 있다. 예를 들어, 에러 발생 시 공통적으로 호출되는 로직을 메서드로 만들어보기를 권장한다.

#### 4. Reliability (신뢰성)
- **잘 수행되고 있는 부분**: 에러를 위해 `try-catch` 블록을 사용하며, 예외를 처리하는 방법이 명확하다.
- **개선이 필요한 부분**:
  - `catch` 블록에서 단순히 `printStackTrace()`를 호출하는 대신, 적절한 로깅 라이브러리를 사용하여 에러 정보를 적절히 남겨라. 이렇게 하면 나중에 문제를 추적하기 수월해진다.
  - 각각의 에러 상황에 대해 사용자에게 알리거나 핸들링하는 방안을 고민해봐라. 예외 발생 시 사용자에게 문제를 알리는 방법도 고려해야 한다.

#### 5. Security (보안성)
- **잘 수행되고 있는 부분**: 현재 코드에서 사용하는 로그는 에러나 중요한 상태변화를 잘 기록하고 있어, 보안 모니터링에 도움이 된다.
- **개선이 필요한 부분**:
  - 민감한 사용자 정보(예: `userId`, `token`)를 로그에 찍지 않도록 유의해라. 로그에 민감 정보를 기록하는 것은 보안을 위협할 수 있다.
  - 권한 검증이 필요한 상황에서 추가적인 검증로직이 없는데, 사용자의 권한을 확인하는 로직을 추가하라.

#### 6. Maintainability (유지보수성)
- **잘 수행되고 있는 부분**: `SseEmitter`와 관련된 이벤트를 효과적으로 관리하는 점에서 코드의 유지보수성이 높아졌다.
- **개선이 필요한 부분**:
  - 각 메서드가 가능한 한 단일 책임을 가지도록 수정해라. 예를 들어, `createEmitter` 메서드는 단순히 `SseEmitter`를 생성하고 반환하는 기능에 집중하는 것이 좋다. 
  - 예외 상황에 대해 공감할 수 있는 방법으로 유지보수성을 높이는 코드 패턴을 사용해야 한다. 필요한 경우 별도의 에러 처리 클래스나 어댑터를 설계해볼 것을 권장한다.

### 전체적인 피드백
- 코드 전반적으로 잘 수행하고 있는 부분: 상태를 로그로 잘 기록하고 있다. 이는 코드의 흐름을 추적하는 데 큰 도움이 된다. 또한, 음식점을 요리하는 것처럼 코드가 명확히 구조화되어 있어 해당 기능이 어떤 역할을 하는지 명확히 알고 있다.
- 개선이 필요한 부분: 에러 처리 및 로깅에 대한 접근 방식이 조금 더 발전할 필요가 있으며, 민감한 정보를 다룰 때 보안을 고려해야 한다. 또한 재사용성을 높이기 위한 코드 구조 정리가 필요하다.

결론적으로, 방향이 좋다. 그러나 그 흐름을 유지하기 위해서는 세부적인 개선이 필요하다. 코드를 수정할 때는 모든 부분에서 신중하게 효과를 고려해봐라.');
INSERT INTO public.review VALUES ('2024-11-13 13:12:36.194254', 103, '2024-11-13 13:12:36.194254', 22, '복잡한 코드 리뷰 요청을 받았네! 준수했으면 하는 피드백 포인트들을 하나하나 살펴볼게.

### 1. **Readability (가독성)**
이 부분은 꽤 잘 되어 있네. 함수명과 변수명도 대부분 명확하고, 기능의 목적이 잘 드러나. 특히, `createEmitter`와 `sendToClient` 같은 함수는 그 목적이 뚜렷해서 가독성을 높여주고 있어. 하지만 몇 가지 주석을 추가하는 게 좋을 것 같아. 예를 들어, 리턴 값이나 중요한 로직에 대한 설명이 없는데, 그렇지 않으면 다른 개발자가 이해하기 힘들어 할 수 있어. 각 SSE 이벤트 처리 시의 목적을 명시하는 주석이 추가되면 좋겠어.

### 2. **Consistency (일관성)**
코드 스타일은 전반적으로 일관돼. 메서드와 변수의 이름 규칙도 잘 지켜지고 있어. 하지만 인디entation과 브레이크라인 사용에서는 약간의 차이가 있는 것 같아. 예를 들어, 람다 표현식의 경우 가독성을 위해 블록을 사용할 때 일정한 스타일을 지켜야 해. 통일감이 떨어지기 때문에, 프로젝트 전반의 코드 스타일 가이드를 기준으로 해보면 좋겠어.

### 3. **Reusability (재사용성)**
네가 작성한 코드는 특정 기능을 잘 담고 있지만, 그렇게 재사용되는 구조는 아닌 것 같아. `sendToClient` 메서드처럼 연결 처리와 메시지 전송 로직이 섞여 있는 부분이 있어, 이를 별도의 서비스로 분리하면 향후 다른 관계에서 재사용할 수 있을 거야. 예를 들어, `emitter.send`를 처리하는 로직을 담당하는 클래스를 만드는 것도 괜찮아.

### 4. **Reliability (신뢰성)**
예외 처리 부분이 매우 중요해. 현재 코드에서 오류를 잡아내는 방식은 사용자가 인지하기 더 어려워. `RuntimeException`을 던지기보다는 사용자에게 좀 더 유용한 에러 메시지를 주는 방향으로 개선하면 좋을 것 같아. 또한, 그렇지 않으면 시스템 안정성에 악영향을 미칠 수 있어. `emitter.send` 관련 예외가 발생하면 어떤 상황이었는지 좀 더 구체적인 로그를 남기는 것도 잊지 마.

### 5. **Security (보안성)**
입력 데이터에 대한 검증이 전혀 없는 것 같아 보안적 측면에서 리스크가 있어. 사용자가 푸시하는 데이터나 ID를 검증하지 않으면 SQL 인젝션 같은 공격에 취약해질 수 있어. 사용자의 입력 내용을 검증하는 부분을 포함시키는 것이 좋겠어. 이를 위해서 `validate` 메서드를 만들어 재사용 가능한 형태로 검증 로직을 제공해주면 좋겠어.

### 6. **Maintainability (유지보수성)**
코드는 어느 정도 변화를 잘 수용할 수 있는 구조야. 하지만 각 메서드가 책임에 대한 명확한 구분이 더 필요해 보여. 현재 `sendToClient` 메서드 내에서 여러 일이 동시에 일어나는데, 이런 일들을 각각의 메서드로 나누는 것이 더 유지보수에 유리할 거야. 예를 들어, JSON 변환과 네트워크 전송을 각각 다른 메서드로 분리하면 책임이 명확해지고, 이후의 변경이 용이해질 거야.

### **전체적인 피드백**
전체적으로 보았을 때, 코드의 가독성과 일관성 측면에서는 👍을 줄 수 있어. 하지만 안정성과 보안 측면에서는 개선이 필요하다고 보이네. 주석 보강과 함께 명확한 오류 처리를 해보면 더 좋을 것 같아. 또한, 코드의 재사용성을 높이려는 노력이 필요해. 여기에 따라 코드를 리팩토링하고 프레임워크의 디자인 패턴을 고려하는 것도 좋은 방향이 될 거야.

이제, 다음 점검 사항들을 반드시 확인해! 너의 코드가 시스템의 안정성과 보안을 확보할 수 있도록 하길 바라!');
INSERT INTO public.review VALUES ('2024-11-13 13:18:51.163916', 104, '2024-11-13 13:18:51.163916', 22, '코드 변경 사항을 리뷰하면서 다음의 6가지 평가 항목을 기반으로 피드백을 제공할게.

1. **Readability (가독성)**:
   - 변경된 코드에서 메서드와 변수 명이 잘 설정되어 있어서, 그 기능을 이해하기 쉽게 잘 작성되었어. 특히 `onCompletion`, `onTimeout`, `onError` 메서드를 사용하여 각 상태에 대한 처리를 명확히 한 점은 좋아.
   - 그러나 로그 메시지에서 `id`와 함께 정보를 출력する 부분에 대해 구체적인 내용을 추가하면 더 이해하기 쉬워질 것 같아. 예를 들면, "SSE 연결이 완료되었습니다. ID: " + id와 같은 형태로 변경하면 더 좋겠어.
   - 주석이 없어서 개념을 이해하는 데 시간이 걸릴 수 있어. 약간의 문서화가 부족해 보이니, 주요한 기능이나 작업에 주석을 추가하는 게 좋겠어.

2. **Consistency (일관성)**:
   - 코드 스타일은 대부분 일관되게 유지되고 있지만, `log` 관련 호출에서 `log.info`와 `log.error` 사이에 일관성이 떨어져 보여. `SSE connection` 메시지 형식에서 통일성을 유지하는 게 중요해. 
   - 예를 들어, 모든 로그 메시지에서 `id`를 포함시키려면 일관되게 포함시키는 게 좋고, 예외 처리가 발생할 때 사용하는 로그 형식도 통일하는 것이 좋겠어.

3. **Reusability (재사용성)**:
   - 현재 `SseEmitter`와 관련된 정보를 수집하고 처리하는 부분이 잘 분리되어 있어 추후 다른 서비스에서도 재사용하기 좋게 설계되어 있어. `createEmitter(Long id)` 함수가 emitter를 생성, 저장하는 책임을 잘 수행하고 있어.
   - `sendToClient`와 같은 메서드가 다수의 인스턴스에서 직접적으로 사용할 수 있는 형태로 잘 구성되어 있어. 그러나 `emitterRepository.deleteById(id)`와 같은 부분이 반복적으로 호출되니, 이를 한 곳에 묶어서 중복을 줄이는 것도 좋겠다.

4. **Reliability (신뢰성)**:
   - 예외 처리가 잘 수행되고 있어서 오류 발생 시의 행동이 명확해. 예외 메시지를 통해 어떤 오류인지 이해할 수 있는 서비스 측면에서 상당히 긍정적이야.
   - 그러나 런타임 및 컴파일 오류가 발생할 수 있는 부분에 대해 더 면밀히 살펴봐야 해. 특히 `JsonProcessingException`과 `IOException`을 처리할 때 `emitterRepository.deleteById(id);`가 항상 호출되는 것은 의도한 대로 작동하는지 확인해볼 필요가 있어.

5. **Security (보안성)**:
   - 보안 측면에서의 검토는 상대적으로 부족해 보여. 만약 `id`가 외부에서 잘못된 값으로 들어올 경우를 고려해야 해. 입력 값에 대한 검증 로직이 없기 때문에, 이를 추가해서 잠재적인 보안 문제를 사전에 차단하는 것이 좋겠어.

6. **Maintainability (유지보수성)**:
   - 코드가 기능적으로 잘 나누어져 있어 변경에 유연하게 대응할 수 있는 구조로 작성되었어. 그러나 `sendToClient`와 같은 메서드 내에서의 비즈니스 로직은 담으려 하지 말고, 별도의 클래스로 분리해서 단일 책임 원칙(SRP)을 강화하는 게 바람직해.
   - 코드를 다른 개발자들이 읽고 이해하기 쉽게 만드는 것이 중요하니, 복잡한 비즈니스 로직을 서비스 계층과 유틸리티 클래스로 나누는 것도 고려하길 바래.

**전체적인 피드백**:
- 변경된 코드는 로그 출력을 통해 오류와 상태를 명확히 파악할 수 있는 점이 좋았고, 전반적으로 기능적인 부분에서 잘 수행되고 있어. 특히 상태 변화를 명확히 하는 방식이 긍정적이야.
- 그러나 주석 부족, 오류 처리 및 보안 문제, 반복 코드 문제 등 개선이 필요한 부분도 보여. 전체적으로는 목표 지향적인 개발이 이루어졌지만, 이러한 점들을 보완하여 개선할 필요가 있어.
- 개선 제안으로는 주석 보완, 예외 처리 강화, 로그 일관성 유지, 그리고 보안성을 위한 입력 검증 로직 추가를 권장해. 이 점들을 보완하면 더 견고한 코드로 발전할 수 있을 거야.');
INSERT INTO public.review VALUES ('2024-11-13 13:22:02.341408', 105, '2024-11-13 13:22:02.341408', 22, '리뷰어 역할로서, 주어진 코드 변경 사항을 깊이 있게 분석해서 피드백을 줄게. 다음 항목별로 평가할 테니 그에 따라 유의해봐.

### 1. **Readability (가독성)**
잘한 점:
- 코드는 전반적으로 가독성이 괜찮아. 특히 Lambda 표현식으로 작성된 이벤트 처리기들이 명확하게 범위를 벗어나지 않도록 잘 분리되어 있어.

개선할 점:
- 로그 메세지를 더 구체적이고 설명적으로 작성하는 게 좋겠어. 예를 들어, "SSE connection completed for id: "보다 "SSE connection successfully completed for user with id: " 같은 구체적인 내용을 담으면 좋을 것 같아.
- 적절한 주석이 없는 것처럼 보이는데, 각 이벤트 처리기에서 어떤 일이 일어나는지 간단한 주석을 추가하는 방법으로 코드 이해를 돕는 게 좋을 듯.

### 2. **Consistency (일관성)**
잘한 점:
- 함수명과 변수명이 명확하게 의도를 담고 있어서 일관성이 있어 보여.

개선할 점:
- 프로젝트 전반에서 로그 출력 스타일이 통일되어야 해. 지금 코드에서는 `log.info(...)`와 `log.error(...)`를 사용하고 있는데, 이와는 별도로 다른 부분에서의 로그 스타일도 일관되게 유지해야 해.

### 3. **Reusability (재사용성)**
잘한 점:
- 이벤트 핸들러들을 메서드로 독립적으로 분리해서 잘 구현했네. 이런 구조는 좋다.

개선할 점:
- 만약 `emitter.onCompletion`, `emitter.onTimeout`, `emitter.onError`의 처리 로직이 다른 클래스에서도 사용될 수 있다면, 각각을 별도의 메서드로 분리해서 중복을 줄이는 방법을 고려해보는 게 좋을 것 같아.

### 4. **Reliability (신뢰성)**
잘한 점:
- 예외 처리가 포함되어 있는 점이 좋고, 오류가 발생할 경우 Emitter를 삭제하는 것도 중요한 고려사항이라 잘 처리하고 있어.

개선할 점:
- 예외 발생 시 전파하기 전에 고객에게 적절한 처리를 할 수 있도록 하는 것도 좋을 것 같아. 예를 들어, 클라이언트로 에러 메시지를 전송하거나 다른 대체 로직을 수행하는 방안을 생각해보면 좋겠어.

### 5. **Security (보안성)**
잘한 점:
- 현재 코드 상에서는 보안 관련 직접적인 문제는 보이지 않아.

개선할 점:
- 예를 들어, Emitter의 ID를 직접 사용하고 있는데, 이를 외부 입력으로 받는 경우 유효성 검사를 해주는 것이 좋겠어. 또는 로그에 출력하는 내용도 민감 정보가 포함될 수 있기 때문에 신중하게 작성해야 해.

### 6. **Maintainability (유지보수성)**
잘한 점:
- 모듈화된 구조 덕분에 유지보수가 용이할 것으로 보여.

개선할 점:
- 메서드가 점점 커지면 유지보수가 힘들어질 수 있어. 특히, 이벤트 처리에 따라 더 많은 로직이 추가될 가능성이 있으므로, 각 핸들러의 책임을 명확히 하고 DRY 원칙을 지키는 게 좋겠어.

### **전체적인 피드백**
잘한 부분:
- 로그 메시지를 추가함으로써, 디버깅 시 유용한 정보를 제공하고 있다는 점에서 평가할 만해. 또한 에러 처리 부분도 명확하게 작성되어 있어 긍정적이야.

개선이 필요한 부분:
- 코드의 가독성을 높이기 위해 로그 내용을 좀 더 구체적으로 작성하고, 예외 처리 시 고객에게 적절한 반응을 할 수 있도록 설계하면 좋겠어. 또한 코드의 중복을 줄이고, 통일성을 이루는 것에 대한 고민이 필요해.

이상으로 코드 리뷰를 마칠게. 개선된 버전 기대할게!');
INSERT INTO public.review VALUES ('2024-11-13 13:23:01.930439', 106, '2024-11-13 13:23:01.930439', 22, '## 코드 리뷰

### 1. Readability (가독성)
- **잘 수행되고 있는 부분**: 로그 출력을 통해 SSE 연결의 상태를 알리는 것은 코드의 가독성을 높이고 디버깅을 용이하게 해주는 훌륭한 변화야. 함수 이름과 변수도 상대적으로 의미가 명확하네.
- **개선이 필요한 부분**: 로그 메시지에 좀 더 상세한 내용을 추가하면 좋을 것 같아. 예를 들어 `SSE connection completed` 같은 메시지보다는 `SSE connection completed successfully for id: {id}` 같은 구체적인 메시지를 작성하면 이해하기 더 쉬워질 거야. 또한, 특정한 경우에 대한 예외 처리가 더 필요할 것 같아. 주석도 있으면 좋겠지만, 지금 정도라면 크게 문제가 되진 않아.

### 2. Consistency (일관성)
- **잘 수행되고 있는 부분**: 코드 스타일이 깨끗하고 일관성 있게 작성됐어. 메서드의 오류 처리 방식이 통일적이야.
- **개선이 필요한 부분**: 코드의 들여쓰기나 괄호 사용에서 약간의 불일치가 느껴지네. 예를 들어, 람다 표현식의 공백이나 줄바꿈을 더 일관성 있게 맞추는 게 좋아 보여. 프로젝트 전반적으로 일관된 스타일 가이드를 따르도록 해.

### 3. Reusability (재사용성)
- **잘 수행되고 있는 부분**: `createEmitter` 함수가 전적으로 SSE 연결을 담당하므로 재사용 가능성이 높아. 각 이벤트 처리 루틴도 독립적으로 잘 분리돼 있어.
- **개선이 필요한 부분**: 각 이벤트에 대한 처리가 독립적이긴 하지만, 공통된 로직을 별도의 헬퍼 메서드로 뽑아내면 더 좋을 것 같아. 예를 들어 `deleteById` 로직을 메서드로 분리하면 재사용성을 높일 수 있어.

### 4. Reliability (신뢰성)
- **잘 수행되고 있는 부분**: 예외 처리 로직이 포함돼 있어 기본적인 신뢰성을 확보하고 있어. 이번 변경은 연결 상태에 따른 적절한 로그를 추가하여 신뢰도를 높였습니다.
- **개선이 필요한 부분**: `onError` 메서드에서 오류를 파악하고 적절한 조치를 취하는 방식이 보강되면 좋겠어. 현재 코드는 발생한 오류를 반드시 로그에만 남기고 처리하지 않는 것 같으니(예: 사용자에게 다시 시도하라고 알리지 않음), 사용자의 경험을 고려한 추가적인 예외 처리 로직이 필요해.

### 5. Security (보안성)
- **잘 수행되고 있는 부분**: SSE 연결을 처리하는 과정에서 민감한 데이터는 사용하고 있지 않아서 보안상 괜찮아 보여.
- **개선이 필요한 부분**: 데이터 전송 시의 검증, 예를 들어 입력 값이나 사용자 인증에 대한 철저한 검증 절차가 필요해. SSE와 같은 스트리밍 연결은 DDoS 공격이나 세션 하이재킹 등을 받을 수 있으니 이 점을 좀 더 신경 쓰는 게 좋을 듯.

### 6. Maintainability (유지보수성)
- **잘 수행되고 있는 부분**: 로그를 통해 코드 변경 이력을 쉽게 추적할 수 있는 구조로 잘 만들어져 있네.
- **개선이 필요한 부분**: 앞으로 수정이나 기능 추가가 필요할 때, 현재의 구조화된 방식을 더 확장 가능하게 하려면 메서드를 더 모듈화하는 게 필요해. 해당 부분들(예: 연결 생성 및 이벤트 처리)을 더욱 독립적인 컴포넌트로 분리하면 유지보수성도 높아질 거야.

### 전체적인 피드백
전체적으로 코드가 명확하게 잘 작성되어 있고, logging을 통해 디버깅도 수월해진 점이 긍정적이야. 다만, 예외 처리를 좀 더 구체화하고, 공통 코드 로직을 헬퍼 메서드로 뽑아내는 등의 작업이 필요해. 또한, 일관된 스타일과 모듈화를 통해 유지보수성을 개선하면 좋겠어. 코드 변화에 대한 효과를 전체 시스템에서 고려해서 작성해줘. 시스템의 전체 구조와 장기적으로 유지보수 측면에서도 이 점을 고려하는 게 중요해.');
INSERT INTO public.review VALUES ('2024-11-13 13:30:26.246975', 107, '2024-11-13 13:30:26.246975', 22, '코드 변경 사항에 대한 리뷰를 시작하겠다. 이번 수정에서 로그 출력을 추가한 건 좋다고 생각한다. 하지만 몇 가지 주요 사항들을 짚고 넘어가야겠다.

### 1. Readability (가독성)
- **잘한 점**: 로그 메시지가 추가되면서 코드의 흐름을 이해하기 쉬워졌다. 잘 정의된 로그는 디버깅할 때 큰 도움이 된다.
- **개선할 점**: `log.info()`와 `log.error()`의 메시지에서 ID를 직접 사용하는 대신, `String.format()`이나 다른 문자열 포매팅 방법을 사용해 좀 더 깔끔하게 코드 가독성을 높일 수 있을 것 같다. 예를 들면:
  ```java
  log.info(String.format("SSE connection completed for id: %d", id));
  ```

### 2. Consistency (일관성)
- **잘한 점**: 로그 추가 방식이 기존 코딩 스타일에 잘 맞는다. 
- **개선할 점**: 특정 로깅 메시지 스타일에 일관성을 두는 것이 좋다. 예를 들어, ID를 로그하기 전에 브랜치나 다른 추가 정보를 포함시키면 더욱 일관성 있게 유지할 수 있다.

### 3. Reusability (재사용성)
- **잘한 점**: SSE 관련 로깅과 에러 처리가 각 이벤트에 대해 잘 분리되어 있다.
- **개선할 점**: 각 이벤트에 대한 로깅 로직을 별도의 헬퍼 메서드로 분리하는 것도 고려해볼 만하다. 반복 코드를 줄이고, 앞으로 다른 이벤트 처리에서도 사용할 수 있도록 만들 수 있다.

### 4. Reliability (신뢰성)
- **잘한 점**: 연결 완료, 타임아웃 및 에러 상황에 대한 처리가 추가되어 신뢰성이 증가했다.
- **개선할 점**: 예외 발생 시 로그를 추가하는 건 좋지만, 단순히 로그를 남기는 것 외에도 특정 상황에 대해 재시도 로직이나 에러를 해결할 수 있는 경고/알림 로직을 추가하는 것도 좋겠다.

### 5. Security (보안성)
- **신경 쓸 점**: 현재 코드에서 보안에 관련된 직접적인 문제는 보이지 않는다. 그러나, `SseEmitter`가 사용되는 곳에서는 부적절한 데이터가 전달되는 경우를 고려해야 한다. 이를 위해 데이터 검증로직이 필요하다.

### 6. Maintainability (유지보수성)
- **잘한 점**: 코드 구조가 명확하고, 각 메서드가 자신의 역할에 충실하다. 이는 유지보수성을 높인다.
- **개선할 점**: 로깅 및 에러 처리 메서드를 잘 분리하거나, 공통적인 부분을 추출하는 것이 좋다. 또한, 비즈니스 로직이 변경될 경우의 영향도를 고려할 때, 메서드가 너무 긴 경우에는 작은 메서드로 나누는 것을 추천한다.

### 전체적인 피드백
코드 변경 사항에서 로그 출력을 추가한 점은 매우 긍정적이다. 이로 인해 문제가 발생했을 때 디버깅이 수월해질 것이다. 그러나 코드의 질을 올리기 위한 몇 가지 개선점을 지적해야겠다. 특히, 코드 가독성을 높이고, 일관성을 유지하는 데 몇 가지 수정을 고려해야 한다. 재사용성이나 유지보수성 측면에서도 다소 개선의 여지가 있으니 주의 깊게 살펴보길 바란다. 

마지막으로 컴파일 에러나 런타임 에러가 발생할 경우, 이를 수정하지 않으면 안 된다. 다 부수적인 문제들이 유발될 수 있으니 꼭 검토하고 수정하도록 해라.');
INSERT INTO public.review VALUES ('2024-11-13 13:33:20.259277', 108, '2024-11-13 13:33:20.259277', 22, '## 코드 리뷰

### 1. Readability (가독성)
- **잘 수행한 부분**: 
  - `log.info`와 `log.error`를 활용하여 각 이벤트에 대해 정보 로그와 오류 로그를 잘 출력하고 있다. 이 부분은 이해하기 쉽고, 추후 문제 발생 시 디버깅 하기 용이하다.
  
- **개선이 필요한 부분**:
  - `emitter.onCompletion(...)`, `emitter.onTimeout(...)`, `emitter.onError(...)` 내의 람다 표현식이 길어지고 있다. 이러한 부분에서는 **세미콜론**으로 구분된 여러 행으로 나누어 가독성을 높일 수 있다. 각 함수 안에서 무엇을 하는지 한눈에 쉽게 파악할 수 있도록 주석을 추가해주는 것도 좋겠다. 예를 들어 `// 이 이벤트는 완료시 호출된다` 같은 주석을 추가하면 더 직관적으로 이해할 수 있을 것이다.

### 2. Consistency (일관성)
- **잘 수행한 부분**:
  - 전반적으로 로그를 사용하는 방식이 통일되어 있으며, 메서드 이름과 구조가 일관성 있게 유지되고 있다.
  
- **개선이 필요한 부분**:
  - 로그 메시지가 일관된 스타일을 따르지 않는다. 예를 들어, 어조 또는 표현 방식이 다를 수 있으니, 일관된 어투와 표현을 사용하는 것이 좋겠다.

### 3. Reusability (재사용성)
- **잘 수행한 부분**:
  - `createEmitter` 메서드는 SSE 연결을 독립적으로 생성하고, 여기서의 지연이나 오류 처리를 다른 서비스에서 재사용할 수 있도록 잘 분리되어 있다.
  
- **개선이 필요한 부분**:
  - `SseEmitter`를 직접적으로 여러 서비스에서 사용하고 있는 것 같아, 더욱 범용적인 메서드로 분리한다면 재사용성을 높일 수 있을 것 같다. 

### 4. Reliability (신뢰성)
- **잘 수행한 부분**:
  - 예외 처리 부분에서 JSON 변환 오류, 연결 오류를 잡아내고 있고, 이를 통해 연결 실패 시 적절한 조치를 취하고 있다. 
  
- **개선이 필요한 부분**:
  - `onError` 메서드에서 오류를 처리할 때, 에러를 로깅만 하고 `emitterRepository.deleteById(id);`를 호출하는 상황이 생길 수 있는데, 실제로 오류 발생 시 고객에게 적절한 피드백을 주는 방법을 고려해야 한다. 고객이 오류 상황을 알아차릴 수 있는 방법이 필요하다.

### 5. Security (보안성)
- **잘 수행한 부분**:
  - 코드 내에 민감한 데이터에 대한 처리가 명시되어 있지 않아서 보안 문제가 눈에 띄지 않는다.
  
- **개선이 필요한 부분**:
  - 사용자의 ID나 다른 민감한 정보가 로그에 기록될 경우 문제를 일으킬 수 있으므로, 로그에 기록되는 내용을 필터링하는 로직이 필요하다.

### 6. Maintainability (유지보수성)
- **잘 수행한 부분**:
  - 메서드가 명확한 기능을 담당하고 있어, 구조가 간단하게 유지되고 변경에 쉽게 대응할 수 있는 부분이 장점이다.
  
- **개선이 필요한 부분**:
  - 현재 `SseService` 내의 메서드들이 직접적으로 상호작용하고 있어, 만약 `emitter`에 대한 로직이 수정될 경우 다른 메서드도 영향을 받을 수 있다. `emitter` 관련 로직을 별도의 클래스로 분리하여, 단일 책임 원칙(SRP)을 잘 적용하고 유지보수성을 높여야 한다.

## 전체적인 피드백
- 코드에서 로그를 잘 활용하고 있어, 각 이벤트의 흐름을 알기 쉽게 표현하고 있다. 이는 디버깅 시에 큰 도움이 되므로 긍정적으로 봐야 한다.
- 그러나 명명 규칙과 스타일의 일관성을 잃지 않도록 주의하고, 가독성을 높일 수 있는 방법을 고려해야 한다. 여러 메서드가 서로 강하게 결합되어 되어 있다면, 추후 변경 시 다른 부분에까지 영향을 미칠 수 있으므로, 이를 분리하는 방향으로 개선해 나가는 것이 필요하다. 

코드에서의 부작용을 예방하기 위해 항상 주의 깊게 검토하고 수정하여, 변화하는 요구사항에 능동적으로 대응해 주길 부탁한다.');
INSERT INTO public.review VALUES ('2024-11-13 13:34:21.394359', 109, '2024-11-13 13:34:21.394359', 22, '## 코드 리뷰

### 1. Readability (가독성)
- **잘 수행된 부분**: 
  - `log.info()`와 `log.error()`를 사용한 부분은 좋다. 코드가 어떤 일을 하는지 로그를 통해 알 수 있으니, 메인 로직을 이해하기 더 쉬워졌다.
  
- **개선이 필요한 부분**: 
  - 로그 메시지에 ID 외에 더 많은 정보를 포함하면 좋겠다. 예를 들어, 어떤 사용자가 연결했는지, 연결 상태를 어떤 상황에서 기록했는지를 추가하면 디버깅에 도움이 될 거야.
  - 중괄호와 공백을 적절히 사용해 가독성을 높일 수 있다. 인덴테이션을 사용하는 것도 좋지만, 특히 한 줄에 여러 코드를 작성할 때 시각적으로 분리되게 해 줘야 한다.
  
### 2. Consistency (일관성)
- **잘 수행된 부분**: 
  - 전반적으로 `emitter`와 함께 사용되는 메소드 호출이 일관된 패턴을 따르고 있다.
  
- **개선이 필요한 부분**: 
  - 로그 메시지가 `id`와 함께 출력되어 있지만, 메소드명이나 변수명에 관해서는 더 구체적인 정보를 포함시키는 게 좋겠다. 예를 들어, `id`는 Long 타입인데, 명확히 `userId` 또는 `streamId` 같은 좀 더 구체적인 이름을 지어주면 좋겠다.
  
### 3. Reusability (재사용성)
- **잘 수행된 부분**: 
  - `SseEmitter`의 다양한 이벤트 처리 로직을 하나의 메소드(`createEmitter`)에서 관리하여 새로운 SSE를 연결하는 코드가 간결하다.
  
- **개선이 필요한 부분**: 
  - `emitter` 관련 처리가 여러 곳에서 필요한 경우, 예외 처리와 같은 기능을 별도의 헬퍼 메소드로 빼서 재사용할 수 있게 해보는 게 좋겠다.
  
### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 
  - 예외 처리 부분이 nicely done 되어 있어서, 문제가 발생했을 때의 처리가 명확해 보인다. 성능 문제나 연결이 끊어질 때의 처리를 잘 하고 있다.
  
- **개선이 필요한 부분**: 
  - 예외가 발생할 경우 로그 외에 사용자에게 전송하여 전달할 수 있는 오류 메시지를 추가 툴링하는 것도 필요하다. 사용자가 어떤 오류가 발생했는지를 알 수 있어야 하니, 단순히 로그에 남기는 것보다는 더 유용할 것이다.
  
### 5. Security (보안성)
- **잘 수행된 부분**: 
  - `emitter` 로직에서 외부 입력을 직접적으로 다루고 있지 않아서 비교적 안전하게 처리되고 있다.
  
- **개선이 필요한 부분**: 
  - `id` 값에 대한 유효성 검사를 추가하라. 해당 값이 유효하지 않으면 아무 작업도 하지 말고 예외를 발생시켜야 한다. 잘못된 ID가 들어올 경우 잘못된 데이터가 반환될 수 있다는 점을 항상 고려해라.
  
### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 
  - `createEmitter` 메소드는 `SseEmitter`의 생성 및 초기화 로직을 잘 정리하고 있다. 이로 인해 유지 보수가 용이한 구조다.
  
- **개선이 필요한 부분**: 
  - 주석이 보안되어 있지 않다. 각 기능이 무엇을 하는지 설명하는 주석을 적절히 추가하라. 새로운 개발자가 코드를 빠르게 이해하는 데 도움이 될 것이다.
  - 예외 처리 로직을 별도의 클래스나 유틸로 분리하여 나중에 필요 시 변경이 용이하게 만드는 것이 좋다.

### 전체적인 피드백
- **잘 수행된 부분**: 로그 메시지를 추가하고, 연결 상태에 따른 처리를 명확하게 분리한 점은 매우 긍정적으로 평가한다. 예외 처리가 깔끔하게 구성되어 있어 신뢰성을 높였다.
  
- **개선이 필요한 부분**: 변수명과 메소드명, 주석 내용을 보강하여 이해도를 높이고, 안전성을 확보하기 위한 유효성 검사를 추가하라. 문자열을 구성하는 방식을 조금 더 신중하게 작성하여 보안성을 높일 수 있도록 하라.

앞으로 개선이 필요한 부분에 대해서는 좀 더 신경 쓰고, 유지 보수를 고려한 코드를 작성하는 게 중요하다. 매번 보는 것이 아니라 해당 코드의 유지 보수성이 클수록 팀 전체에 긍정적인 영향을 미치게 될 것이니, 진지하게 받아들이고 보완하길 바란다.');
INSERT INTO public.review VALUES ('2024-11-13 13:34:36.114215', 110, '2024-11-13 13:34:36.114215', 22, '좋아, 코드 리뷰 한번 해볼게. 너의 코드 변경 사항을 바탕으로 각 항목별로 분석할게.

### 1. Readability (가독성)
- **잘된 점**: 로그 메시지를 추가한 부분은 코드의 흐름을 이해하는 데 큰 도움이 돼. 특히, `onCompletion`, `onTimeout`, `onError` 핸들러 내에서 로그를 남겨주는 것이 직관적으로 뭘 하고 있는지 알 수 있게 해주지.
- **개선이 필요한 점**: 함수명은 전반적으로 명확하지만, `createEmitter` 같은 부분이나 핸들러 함수에서 조금 더 구체적으로 로그 내용이 나오는 것이 좋겠어. 예를 들어, "SSE 연결이 완료됨" 대신 "유저 ID가 x인 SSE 연결이 완료됨"처럼 사용자 ID를 명시해주는 게 좋겠다.

### 2. Consistency (일관성)
- **잘된 점**: 코드 스타일 자체는 일관성이 있어 보이는데, 로그를 추가하면서 서로 다른 방식으로 로그를 처리하고 있어. 아무래도 `log.info`와 `log.error`를 사용할 때 방식이 조금 비슷하지만, 레벨이 다르니 전체적으로 통일성을 고려할 필요가 있어.
- **개선이 필요한 점**: 클래스 내에서 로그를 남기는 방식이 통일되어야 해. 예를 들어, 모두 `log.info`로 일관되게 할지, 아니면 `log.error`와 `log.warn`을 함께 사용할 때 총정리된 규칙이 필요해. 또, 예외 처리 부분도 스타일 맞춰주는 게 좋겠지.

### 3. Reusability (재사용성)
- **잘된 점**: `onCompletion`, `onTimeout`, `onError` 같은 예외 처리를 함수로 분리하면 더 재사용할 수 있는 구조가 될 거야. 각각을 명확한 메서드로 분리하면 코드가 깔끔하고 다른 곳에서 재사용할 수 있겠지.
- **개선이 필요한 점**: 현재 핸들러 구성에서 동일한 방식으로 여러 곳에서 반복적으로 쓸 수도 있는데, 이를 위해 핸들러를 별도의 함수로 빼내는 건 어때? 다른 부분에서도 유사한 로직이 필요할 수 있으니, 재사용성 측면에서 이점을 줄 거야.

### 4. Reliability (신뢰성)
- **잘된 점**: 각종 오류 처리 부분이 잘 구현되었어. `catch` 블록에서 예외를 처리하는 것도 눈여겨볼만해. 문제 발생 시 적절한 메시지를 출력하는 건 좋은 접근이지.
- **개선이 필요한 점**: 현재 `RuntimeException`을 던지는 방식은 문제가 발생했을 때 디버깅을 어렵게 할 수 있어. 커스텀 예외를 만드는 것이 좋겠어. 어떤 종류의 오류를 처리하는지 이해하기 쉽게 해줘야 해.

### 5. Security (보안성)
- **잘된 점**: 특정 사용자 ID에 기반한 SSE 연결을 다루고 있으니까 그에 대한 보안에 신경 쓴 것 같아. 로그에 에러 메시지를 기록하는 것도 보안적인 측면에서 볼 때 중요한 요소야.
- **개선이 필요한 점**: 만약 외부로부터의 입력이나 API 호출이 있다면, 유저 ID나 다른 중요한 데이터들이 제대로 검증되고 있는지 확인해야 해. 입력 데이터에 대해 충분한 검증이 이루어져야 하고, 특히 JSON 변환이나 네트워크 작업을 다룰 때는 방어 코드가 필요해.

### 6. Maintainability (유지보수성)
- **잘된 점**: 비즈니스 로직을 함수로 잘 나누어져 있어서 유지보수에는 문제가 없어 보인다. 메서드와 클래스의 책임이 분명하게 나뉘어져 있어.
- **개선이 필요한 점**: 모든 메서드에서 처리하는 로직이 복잡하게 얽혀있지 않도록 사용하지 않는 기능이나 메서드는 제거해야 해. 코드의 의도를 명확히 하고, 너무 많은 책임을 지지 않도록 모듈화를 잘 해야 해.

### 전체적인 피드백
코드 전반적으로 로그 출력과 예외 처리가 잘 추가되어 있어서 굉장히 긍정적이야. 특히 SSE 연결을 다룬 부분에서 사용자 경험을 향상시킬 수 있는 여지가 생겼어. 

하지만, 성능 및 가독성을 고려했을 때 예외를 더 세분화하고 중복된 핸들러 코드를 정리하는 것도 필요해. 로그가 많아져서 지저분한 느낌이 날 수 있으니, 로그의 형식을 통일해서 정리를 해줘. 

이 코드가 시스템 전체에 미치는 영향을 고려할 때, 적절한 핸들러 분리를 통해 재사용성을 높이고, 예외 처리가 잘 되어야 안정성이 높아질 거야. 빠른 시간 내에 개선점을 반영해보길 바라!');
INSERT INTO public.review VALUES ('2024-11-13 13:38:09.396034', 111, '2024-11-13 13:38:09.396034', 23, '코드 리뷰를 시작하자. 전반적으로 여러 가지 개선할 점이 보이는데, 한 번 살펴보자.

### 1. 가독성 (Readability)
- **잘 수행된 부분**: 메서드와 변수 이름이 상당히 명확하게 작성되어 있어서 코드의 의도를 이해하는 데 도움이 된다.
- **개선이 필요한 부분**: 주요 변수나 메서드에 대한 주석이 부족하다. 예를 들어 `ChunkStrategy` 인터페이스와 그 구현체들이 어떤 용도로 사용되는지에 대한 설명이 없다. 각각의 클래스와 메서드에 대한 설명을 추가하면 코드의 이해도를 더욱 높일 수 있을 것이다.

### 2. 일관성 (Consistency)
- **잘 수행된 부분**: 패키지 구조와 파일명이 잘 조직되어 있다. 각 클래스의 명명 규칙도 잘 따르고 있다.
- **개선이 필요한 부분**: 주석 스타일이나 코드 작성 시의 포맷이 일관되지 않다. 주석은 일부 클래스에만 존재하며, 필요할 때 항상 사용해야 할 필요가 있다. 일관된 스타일 가이드라인을 따르도록 하자.

### 3. 재사용성 (Reusability)
- **잘 수행된 부분**: `ChunkStrategy`와 같은 설계 패턴을 사용하여 기능을 모듈화한 점은 좋다. 이는 추가적인 언어 지원이 필요한 경우 유용하게 사용될 수 있을 것이다.
- **개선이 필요한 부분**: 같은 로직이 여러 곳에 중복되어 나타난다면, 공통적인 작업을 담당하는 헬퍼 메서드를 추가하는 것도 고려해야 한다. 예를 들어, `traverseAndCollectNodes` 메서드는 각 언어별 `ChunkStrategy` 클래스에서 중복 사용되고 있으니, 이를 독립된 유틸 클래스로 분리해도 좋겠다.

### 4. 신뢰성 (Reliability)
- **잘 수행된 부분**: 파일 읽기에서 발생할 수 있는 IOException을 처리하기 위한 사용자 정의 예외를 던지는 방식은 좋다.
- **개선이 필요한 부분**: 예외 처리에서 더 세밀한 접근이 필요하다. 예외를 단순히 던지기보다는 로깅을 통해 문제가 발생한 원인을 추적할 수 있도록 하면 디버깅에 큰 도움이 될 것이다. 예를 들어, `FileUtil.getCodeBytes` 메서드에서 예외 발생 시 파일 경로를 로깅하는 것이 좋겠다.

### 5. 보안성 (Security)
- **잘 수행된 부분**: 현재 코드는 외부 입력에 대한 검증 로직이 다소 부족하지만, 보안적인 측면에서 외부 입력을 사용하는 부분은 적다.
- **개선이 필요한 부분**: `chunk` 메서드에서 파일 구조체를 입력받아 처리하는 만큼, 해당 파일의 존재 여부와 유효성을 체크하는 로직이 필요하다. 이를 통해 예를 들어 존재하지 않거나 안전하지 않은 파일에 대한 접근을 차단할 수 있을 것이다.

### 6. 유지보수성 (Maintainability)
- **잘 수행된 부분**: 각 언어별 청킹 전략을 분리한 덕분에 새로운 언어를 추가할 때 손쉽게 구조를 수정할 수 있다.
- **개선이 필요한 부분**: 종속성이 명시적으로 줄어드는 것이 좋다. 예를 들어, `TSParser`와 같은 외부 라이브러리에 대한 직접적인 의존성을 줄일 수 있도록 추상화 계층을 추가하는 것이 필요하다. 이를 통해 테스트와 유지보수 과정에서 유연성을 높일 수 있다.

### 전체적인 피드백
여러 측면에서 좋은 시도가 보인다. 특히 모듈화와 디자인 패턴을 활용한 구조는 강점을 지닌다. 하지만 일관성 결여, 주석 부족, 예외 처리 미흡 등의 문제가 있다. 이러한 문제들을 해결한다면, 코드의 완성도가 훨씬 높아질 것이다. 

필요한 모든 개선 사항을 반영해서 더욱 발전할 수 있기를 바란다.
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-13 13:45:44.987902', 112, '2024-11-13 13:45:44.987902', 22, '확인해봤는데, 변경된 코드에 대해 몇 가지 포인트를 지적할게.

### 1. 가독성 (Readability)
- **긍정적인 요소**: 로그 출력을 추가하면서 코드가 더 명확해졌어. 각 콜백에서 무슨 일이 일어나는지 알 수 있어서 좋아.
- **개선할 점**: `log.info()`와 `log.error()` 부분에서 메시지를 좀 더 구체화하면 좋겠어. 예를 들어, `"SSE connection completed for id: "` 대신 `"SSE connection for user with id: "`로 바꾸면 누가 연결했는지 헷갈리지 않겠지. 로그는 나중에 문제를 파악할 때 중요하니까 메시지를 보강해라.

### 2. 일관성 (Consistency)
- **긍정적인 요소**: 전반적으로 코드 형식은 일관되게 잘 유지하고 있어.
- **개선할 점**: 코드의 전반적인 간격이나 들여쓰기 스타일을 프로젝트 전체에 맞춰서 더 통일성을 줘야 해. 이렇게 잘 맞춰야 다른 사람도 쉽게 코드를 읽고 이해할 수 있어.

### 3. 재사용성 (Reusability)
- **긍정적인 요소**: `onCompletion`, `onTimeout`, `onError`와 같은 이벤트 핸들러는 독립적으로 작동하니까, 다른 곳에서도 재사용될 가능성이 높아.
- **개선할 점**: `emitter.onError()` 핸들러를 별도의 메소드로 분리하면 더 좋겠어. 그렇게 되면 코드 재사용성을 높일 수 있을 거야. 코드를 더 정리하고 관리하기도 쉬울 거고.

### 4. 신뢰성 (Reliability)
- **긍정적인 요소**: 각각의 예외 처리가 추가되면서 안정성이 향상됐어. 각 상태에서 에러가 발생했을 때 적절히 로그를 남기고, `SseEmitter`를 안전하게 처리하고 있어.
- **개선할 점**: 런타임 예외에 대해 조금 더 먼가를 고려하길 추천해. 예를 들어, 일반적인 예외 처리보다는 특정 에러 클래스에서 예외를 잡아서 더 명확한 핸들링을 하는 게 좋을 것 같아.

### 5. 보안성 (Security)
- **긍정적인 요소**: 코드에서 직접적으로 민감한 데이터가 노출되지는 않아서 꽤 깨끗해. 
- **개선할 점**: 호출하는 부분에서 사용자가 입력하는 값이나 이벤트 요청에 대한 검증을 추가하길 권장해. 보안은 항상 강화할 여지가 있으니까, 가능한 한 방어적인 코딩을 하는 게 중요해.

### 6. 유지보수성 (Maintainability)
- **긍정적인 요소**: 메소드의 구조가 잘 정리되어 있어. 각 메소드가 한 가지 일을 제대로 하는 모습이 보여서 유지보수 가능성이 높아.
- **개선할 점**: 로깅이나 오류 처리를 별도의 유틸리티 클래스로 분리해서 공통으로 사용할 수 있도록 하면 앞으로 유지보수에 도움이 될 거야. 이렇게 바꿔놓으면 나중에 수정할 때 각 기능에 대한 영향을 최소화할 수 있어.

### 전체적인 피드백
- 전반적으로 로그 출력을 통해 개선된 부분이 보이네. 특히 `onCompletion`, `onTimeout`, `onError`가 추가되면서 코드의 의도가 명확해졌어. 하지만, 변수명과 함수명을 좀 더 직관적으로 만들고, 예외 처리에 있어 더 구체화를 하는 게 좋겠어.
- 로그 메시지를 좀 더 구체적으로 개선하고, 유지보수성을 높일 수 있는 구조로 변화시키면 좋겠어. 기술적이거나 비즈니스 요구사항이 변경되더라도 쉽게 적응할 수 있게 말이야.

마지막으로, 만약 이 코드에서 컴파일 에러나 런타임 에러가 발생할 일이 있다면 그건 그냥 내버려 두면 안 돼. 반드시 수정하길 바란다. 잘 하고 있으니까 계속 발전해나가기를 바라!');
INSERT INTO public.review VALUES ('2024-11-13 13:47:33.158973', 113, '2024-11-13 13:47:33.158973', 22, '## 코드 리뷰

### 1. **Readability (가독성)**
**잘 수행된 부분:**
- 로그 메시지가 추가되어 각각의 이벤트가 발생할 때의 상태를 잘 설명하고 있습니다. 이를 통해 코드의 흐름을 이해하기 쉽게 만듭니다.
  
**개선이 필요한 부분:**
- 로그 메시지가 현재 로그 수준에서 적절한지에 대한 고려가 필요합니다. 예를 들어, `log.info`는 정보성 로그이지만, 오류 발생 시에는 `log.error`를 사용하는 것이 더욱 명확합니다. 
- 변수명에 대한 주석이 추가된다면 가독성이 더 높아질 것입니다. 현재 `id`와 같은 변수명이 의미는 알겠지만, 좀 더 구체적인 이름을 사용하며 주석을 달거나, 주석을 통해 설명을 더 추가할 수 있습니다.

### 2. **Consistency (일관성)**
**잘 수행된 부분:**
- 로깅 방식이 일정하게 유지되고 있으며, 각 이벤트에 대한 핸들러들이 일관된 패턴으로 구성되어 있습니다. 

**개선이 필요한 부분:**
- 코드에서 사용된 로그 레벨이나 포맷이 다른 파일과 일치하는지 확인해보는 것이 좋습니다. 모든 로그 메시지가 일정한 규칙을 따르도록 구성하여 프로젝트 전반에 걸쳐 일관성을 유지해야 합니다.

### 3. **Reusability (재사용성)**
**잘 수행된 부분:**
- `emitter.onCompletion`, `emitter.onTimeout`, `emitter.onError` 각각의 행위가 하나의 기능으로 잘 모듈화되어 있어서 재사용성이 좋습니다.

**개선이 필요한 부분:**
- 만약 유사한 로깅 및 오류 처리 로직이 다른 곳에서도 필요하다면, 이를 별도의 메소드로 분리하여 코드 중복을 방지하는 것이 좋습니다. 예를 들어, 반복되는 로깅 부분을 하나의 메소드로 만들어 호출하는 방식으로 구현할 수 있습니다.

### 4. **Reliability (신뢰성)**
**잘 수행된 부분:**
- 모든 경우에 대한 예외 처리가 잘 이뤄지고 있습니다. 특히 `emitter.onError`와 같은 로직이 추가되어 다양한 오류 상황에 대비하고 있습니다.

**개선이 필요한 부분:**
- 예외 발생 시, 단순히 메세지를 출력하고 ID를 삭제하는 것 외에도, 로그 전송이나 다른 알림 시스템을 활용하여 관리자가 문제를 빠르게 인지할 수 있도록 하는 것도 고려해볼 만합니다. 이렇게 하면 시스템의 신뢰성이 높아질 수 있습니다.

### 5. **Security (보안성)**
**잘 수행된 부분:**
- `emitter`를 생성하는 과정에서 사용자의 ID를 기반으로 하는 형태는 보안성을 높이는 데 기여할 수 있습니다.

**개선이 필요한 부분:**
- 입력값에 대한 검증이 필요합니다. 현재 `id`가 유효한지 체크하는 과정이 없으므로, 유효하지 않은 ID로 인한 잠재적인 오류나 보안 문제가 발생할 수 있습니다. 유효성 검사를 추가하는 것을 권장합니다.

### 6. **Maintainability (유지보수성)**
**잘 수행된 부분:**
- 각 핸들러가 명확히 분리되어 있어 유지보수가 용이합니다.

**개선이 필요한 부분:**
- 코드의 주석이 더 추가되어, 변수가 어떤 역할을 하는지 명확히 알 수 있도록 해야 합니다. 특히 향후 유지보수를 고려할 때, 다른 개발자가 쉽게 이해할 수 있는 코드이길 원한다면 주석을 통해 설명하는 것이 중요합니다.

### **전체적인 피드백**
- 전반적으로 코드의 변경 사항들이 긍정적인 방향으로 진행되고 있으며, 특히 로그가 추가됨으로써 코드의 가독성과 디버깅이 용이해졌습니다. 
- 하지만 안전성 및 신뢰성을 높이기 위해 예외 처리와 입력 검증을 강화하고, 코드의 재사용성을 높이기 위한 구조 개선이 필요합니다.
- 이런 모든 피드백이 시스템의 전체적인 안정성과 유지보수성을 높이는데 기여할 것입니다. 개선된 사항들을 참고하여 다음 단계로 나아가시길 응원합니다! 😊');
INSERT INTO public.review VALUES ('2024-11-13 18:12:23.34738', 128, '2024-11-13 18:12:23.34738', 28, '안녕하세요, 냥! 코드 리뷰를 맡게 되어 기쁘다냥! 변경사항을 살펴보고 각 평가 항목에 대한 피드백을 제공할게요, 냥.

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 전체적으로 JSX 마크업이 명확하게 구성되어 있어서 코드의 구조를 쉽게 이해할 수 있어요, 냥. 클래스 네이밍도 일관성 있으며 각 컴포넌트의 역할이 잘 나타나 있어 가독성이 좋아요.
- **개선이 필요한 부분**: 특정 JSX 블록의 클래스 이름이 너무 길어 가독성을 방해할 수 있어요. 예를 들어, 반복되는 `border-[1px] border-background-bnavy` 부분은 상수로 뺄 수 있으면 좋겠어요, 냥. 코드를 더욱 깔끔하게 유지할 수 있을거야!

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: CSS 클래스 네이밍 및 전반적인 코드 스타일이 일관성 있게 유지되고 있어요. 특히 `border` 클래스의 업데이트가 일관되게 이루어진 점이 좋네요.
- **개선이 필요한 부분**: 코드 블록 내에서 주석이 부족해요, 냥. 각 컴포넌트의 기능과 목적에 대해 간단한 주석을 추가하면, 이후 유지보수 시 더 쉽게 이해할 수 있을 거예요.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: 각 컴포넌트가 명확한 기능을 가지고 있어 다른 곳에서 쉽게 재사용할 수 있을 것 같아요. 특히 `ReviewComment` 같은 컴포넌트는 여러 곳에서 활용되고 있어요.
- **개선이 필요한 부분**: CSS 클래스가 특정 컨텍스트에만 의존하는 경우가 있어요. 예를 들어, `border-background-bnavy`와 같은 클래스는 더 일반화가 가능할 것 같아요. 공통 클래스나 스타일 가이드를 사용하는 것도 좋겠어요, 냥.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 기능적으로는 JSX 요소들이 적절하게 렌더링되고 있으며, 기본적인 속성들이 잘 처리되고 있는 것 같아요.
- **개선이 필요한 부분**: 예외 처리 쪽이 부족해 보여요. 예를 들어, `onClick` 이벤트에서 문제가 발생할 경우를 대비한 예외 처리 로직이 필요해 보이네요. 사용자 경험을 높이기 위해 에러 핸들링을 추가해주면 좋겠어요, 냥.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 현재로서는 민감한 데이터 처리 부분이 없어 보이지만, 안전한 프로그래밍 원칙을 지키고 있는 것 같아요.
- **개선이 필요한 부분**: 사용자가 입력하는 데이터에 대해 좀 더 구체적인 검증 로직이 필요할 수 있어요. 예를 들어, 파일 이름이나 기타 입력 필드에 대해 공백이나 특수문자 검증을 추가하는 것이 좋을 것 같아요, 냥.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 각 기능이 잘 모듈화되어 있어, 필요할 때 쉽게 변경하고 수정할 수 있을 것 같아요.
- **개선이 필요한 부분**: CSS 클래스에서 일부 스타일이 특정한 스타일로 고정되어 있어 나중에 유지보수가 어려울 수 있어요. 가능하다면, 스타일 속성을 더 일반화하고 모듈화하면 더욱 유지보수가 쉬워질 거예요, 냥.

### **전체적인 피드백**
코드 전반적으로 잘 구성되었고 가독성이 높아 수정하기 좋은 구조를 가지고 있어요, 냥! 특히 컴포넌트로 잘 나누어져 있어서 재사용성과 유지보수성이 좋네요. 아쉬운 점은 예외 처리와 주석 부족이랄까, 냥. 이러한 부분들을 조금 보완한다면 더욱 강력하고 안정적인 코드를 만들 수 있을 거예요! 피드백이 도움이 되었길 바래요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:13:33.267259', 129, '2024-11-13 18:13:33.267259', 28, '안녕하세요냥! 코드를 꼼꼼히 살펴봤으니 리뷰 결과를 말씀드릴게요냥. 

### 1. **Readability (가독성)**
- **잘 수행되고 있는 부분**: 코드 전반에서 클래스 이름과 JSX 구조가 깔끔하게 나뉘어져 있어서 참고하기 쉽고, 각 컴포넌트의 역할이 명확하게 드러나 있다는 점이 좋았어요냥. 
- **개선이 필요한 부분**: 일부 스타일 속성에 대해 이러한 요소가 하는 일이나 어떤 색상을 나타내는지에 대한 주석이 부족해 보이네요. 예를 들어, `border-background-bnavy` 같은 CSS 클래스가 왜 필요하고 어떤 의미를 갖는지 설명해 줄 주석이 있다면 이해하기 훨씬 쉬울 거예요냥.

### 2. **Consistency (일관성)**
- **잘 수행되고 있는 부분**: 클래스 이름 포맷과 JSX 구성 스타일이 일관되게 유지되고 있어요. 동일한 패턴을 따르는 덕분에 코드가 깔끔하게 정돈되어 있네요냥.
- **개선이 필요한 부분**: 속성 이름 (`border-secondary2` vs `border-background-bnavy`)의 사용이 일부 컴포넌트 내에서 일관되지 않는 점이 발견되었어요. 가능하면 모든 부분에서 `background-bnavy`로 통일시키는 것이 좋을 것 같아요냥.

### 3. **Reusability (재사용성)**
- **잘 수행되고 있는 부분**: `ReviewComment`와 같은 컴포넌트는 재사용성이 뛰어나며, 여러 곳에서 동일한 컴포넌트를 활용하고 있어 좋았어요냥.
- **개선이 필요한 부분**: 특정 스타일 속성이 컴포넌트 내에서 하드코딩되어 있는 경우가 있는데, 이러한 부분을 props로 받아서 재사용성을 더 높이는 방향으로 고칠 수 있어요. 예를 들어, `border` 스타일을 props로 받게 하면 조금 더 유연해질 거예요냥.

### 4. **Reliability (신뢰성)**
- **잘 수행되고 있는 부분**: 조건부 렌더링이 적절하게 사용되어 있어 UI가 예상한 대로 잘 작동할 것 같은 신뢰를 주네요냥.
- **개선이 필요한 부분**: 예외 처리 부분이 다소 부족해 보였어요. 사용자 입력 오류나 데이터 로딩 실패와 같은 예외 상황에 대한 처리를 추가하면 더 안정적인 코드가 될 것 같아요냥.

### 5. **Security (보안성)**
- **잘 수행되고 있는 부분**: 현재 드러난 코드에서는 특별히 보안 문제는 보이지 않아요냥.
- **개선이 필요한 부분**: 사용자 입력을 받는 부분, 특히 외부에서 데이터를 받아오는 경우에 대해 입력 검증을 철저히 해 두는 것이 좋겠어요. 이 부분을 강화하면 보안 측면에서도 안심할 수 있겠어요냥.

### 6. **Maintainability (유지보수성)**
- **잘 수행되고 있는 부분**: 코드의 컴포넌트 구조가 잘 분리되어 있어 유지보수가 쉬운 점이 마음에 들었어요냥.
- **개선이 필요한 부분**: 특정 스타일이나 컴포넌트를 재사용하기 위해 더 모듈화할 수 있는 기회가 많아요. 중복되는 스타일 코드나 기능을 별도의 유틸리티 혹은 CSS 모듈로 분리해 두면 변화에 더 유연한 구조가 될 것 같아요냥.

### **전체적인 피드백**
코드 전체적으로 잘 작성된 부분이 많아서 든든해요냥! 특히 가독성과 일관성이 좋았고, 재사용성을 고려한 구조가 인상적이었어요. 다만, 예외 처리와 보안 측면은 좀 더 강화할 필요가 있습니다. 

문제가 있는 부분들을 개선하면 더욱 멋진 코드가 될 거라 믿어요. 이런 방향으로 차근차근 개선해 나가면 더욱 발전하는 엔지니어가 될 수 있을 거예요. 궁금한 점이나 더 필요한 부분 있으면 언제든지 말해줘요냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:18:14.213474', 130, '2024-11-13 18:18:14.213474', 26, '냥~ 안녕하세요! 코드 리뷰를 시작할게요, 냥! 각 항목별로 잘 수행되고 있는 부분과 개선이 필요한 부분에 대해 피드백을 남길게요, 냥!

### 1. Readability (가독성)
**잘 수행된 부분**:
- 대부분의 코드가 깔끔하게 정리되어 있어서 가독성이 좋아요, 냥! 변수명과 함수명이 의미를 잘 전달하고 있네요.
- JSX 부분에서도 적절한 공백과 들여쓰기로 가독성이 높아졌어요, 냥!

**개선할 부분**:
- 주석이 부족한 부분이 몇 군데 있어요. 특히 API 호출이나 복잡한 로직이 있는 부분에는 주석을 추가하면 더 이해하기 쉬울 것 같아요, 냥! 예를 들어, `handleError` 함수의 동작에 대한 설명이 주석으로 추가되면 좋겠어요.

### 2. Consistency (일관성)
**잘 수행된 부분**:
- 코드 스타일이 일관되게 유지되고 있어서 보기 좋아요, 냥! 함수와 변수명 모두 카멜 표기법을 사용하고 있군요.

**개선할 부분**:
- 일부 코드에서 JSX 내 클래스 네이밍이 다소 불규칙적인 부분이 보여요. 예를 들어, `bg-primary-500`와 `bg-[#EFF2FB]` 같은 색상 클래스가 일관성 있게 사용되지 않는 것 같아요. 코드 전반에서 통일성을 맞추는 것이 중요해요, 냥!

### 3. Reusability (재사용성)
**잘 수행된 부분**:
- `AuthGuard`, `NavigationButtons`와 같은 컴포넌트가 독립적인 기능 단위로 잘 분리되어 있어 재사용성이 높아요, 냥!

**개선할 부분**:
- `handleError`와 같은 함수는 여러 모듈에서 호출될 가능성이 높으므로, 공통 모듈로 분리하면 좋을 것 같아요. 현재는 axios 설정 파일에 딸려 있는데, 별도의 헬퍼 파일을 만들어서 유틸리티 클래스로 분해하면 재사용성이 더 높아질 수 있어요, 냥!

### 4. Reliability (신뢰성)
**잘 수행된 부분**:
- 예외 처리 부분에서 다양한 HTTP 상태 코드를 잘 다루고 있어요, 냥! 사용자에게 적절한 피드백을 제공하는 방식을 보니 좋네요.

**개선할 부분**:
- 에러 발생 시 사용자가 알 수 있는 메시지를 팝업으로 보내기보다는 UI 상에 명확하게 알리는 방법도 고려해 보세요. 예를 들어, 페이지 상단에 에러 메시지를 띄울 수 있다면 사용자 경험이 더 좋아질 것 같아요, 냥!

### 5. Security (보안성)
**잘 수행된 부분**:
- API 요청 시 withCredentials를 사용하여 쿠키를 통한 인증을 세심하게 처리하고 있어 좋은 접근 방식이에요, 냥!

**개선할 부분**:
- 입력 검증과 방어 코드 부분에서 사용자 입력을 다룰 때 가능한 모든 경우의 수를 고려하는 것이 좋겠어요. 특히 API 요청과 관련된 부분에서 적절한 검증 로직이 추가되면 더 안전할 것 같아요, 냥!

### 6. Maintainability (유지보수성)
**잘 수행된 부분**:
- 컴포넌트가 잘 모듈화 되어 있고 단일 책임 원칙이 적용되어 있어서 유지보수성이 높은 것 같아요, 냥!

**개선할 부분**:
- 각 컴포넌트에 대해 propTypes 또는 TypeScript의 interface를 통해 데이터의 구조를 명확히 해주면 더 좋은 유지보수성을 확보할 수 있어요. 특히 `AuthGuard` 컴포넌트와 같은 경우, propType을 명시하면 추후 수정 시 오류를 줄일 수 있어요, 냥!

### 전체적인 피드백
코드 전반적으로 잘 작성되어 있고, 특히 모듈화와 독립적인 기능 단위의 구성은 훌륭해요, 냥! 가독성 또한 좋지만, 주석과 통일성을 더 강화하면 더욱 완벽해질 것 같아요. 예외 처리와 보안성 면에서 좋은 접근을 하고 있지만, 사용자 피드백을 더 명확히 하고 어떤 입력에 대한 검증도 보강하면 좋을 것 같아요, 냥! 

잘 하셨어요! 앞으로도 이렇게 좋은 코드 작성 부탁드려요, 냥~!');
INSERT INTO public.review VALUES ('2024-11-13 18:21:51.877872', 131, '2024-11-13 18:21:51.877872', 26, '냥~ 안녕하세요! 코드 리뷰를 맡게 된 착한 고양이에요 냥! 이 코드는 여러 가지 변경 사항이 있는 것 같아서 살펴볼게요 냥. 각 항목별로 피드백을 주면서 어떤 점이 잘 되고 있고, 어떤 점이 개선이 필요할지 알려줄게요 냥!

### 1. Readability (가독성)
- **잘 수행되고 있는 부분**: 함수와 변수명이 전반적으로 의미를 잘 전달하고 있어요 냥. 예를 들어 `responseBody`와 같은 이름은 함수의 목적을 명확히 해주고 있어요.
- **개선이 필요한 부분**: 일부 코드에 주석이 부족해 보여요 냥. 특히 복잡한 로직을 구현한 부분에는 왜 해당 로직이 필요한지 간단한 설명을 추가하면 좋겠어요. 예를 들어, `handleError` 함수에 대한 설명이나 복잡한 조건문에 대한 주석을 추가하는 것이 좋겠어요.

### 2. Consistency (일관성)
- **잘 수행되고 있는 부분**: 코드 포맷과 스타일이 일정하게 적용되고 있어요 냥. 예를 들어, 클래스명과 함수명이 카멜 케이스를 제대로 지키고 있어요.
- **개선이 필요한 부분**: 일부 UI 관련 코드에서 CSS 클래스의 네이밍이 일관되지 않는 경우가 있어요. 예를 들어, 버튼의 스타일에 대한 클래스명이 너무 길어서 가독성을 해치는 경우가 있으니 조금 더 간결하게 만들면 좋겠어요 냥.

### 3. Reusability (재사용성)
- **잘 수행되고 있는 부분**: `AuthGuard`와 같은 컴포넌트는 재사용할 수 있도록 잘 분리되어 있어요. 다른 라우트에서도 사용할 수 있을 것 같아요.
- **개선이 필요한 부분**: UI 컴포넌트는 몇 곳에서 동일한 스타일을 가지고 있으니, 공통 속성을 가진 컴포넌트를 만들어 재사용할 수 있도록 개선할 수 있어요. 예를 들어, 버튼 스타일을 별도의 컴포넌트로 분리하면 좋겠어요 냥.

### 4. Reliability (신뢰성)
- **잘 수행되고 있는 부분**: 오류가 발생했을 때 적절하게 처리하도록 구성되어 있어서 실제 앱에서 안정성을 높일 수 있어요 냥. `handleError`와 같은 전역 에러 핸들러는 매우 유용해요!
- **개선이 필요한 부분**: 로그인 상태를 처리하는 로직이 `AuthGuard`에서 단순히 로그인 여부만 체크하고 있어요. 만약 로그인 상태를 업데이트하는데 시간이 걸린다면 로딩 상태를 좀 더 명확히 구현할 수 있도록 개선하는 것이 좋겠어요 냥.

### 5. Security (보안성)
- **잘 수행되고 있는 부분**: API 에러 핸들링에 보안 패턴을 잘 적용하고 있어요. 예를 들어, 401 오류 처리 방식이 사용자에게 로그인 요구를 적절하게 알리고 있어요 냥.
- **개선이 필요한 부분**: 민감한 정보나 사용자 입력에 대한 유효성을 검증하는 부분이 보이지 않네요! 특히 사용자가 입력하는 내용에 대해서는 가급적이면 항상 검증 절차를 두는 것이 좋겠어요 냥. 

### 6. Maintainability (유지보수성)
- **잘 수행되고 있는 부분**: 코드 구조가 잘 나뉘어 있어서 유지보수가 쉽도록 되어있어요. 컴포넌트와 유틸 함수들이 잘 분리되어 있어 보기 좋아요!
- **개선이 필요한 부분**: 변경사항을 관리하기 위해 각 컴포넌트별로 책임을 명확히 하고, 문서화하는 작업이 필요해 보여요. 나중에 변화가 생길 때 해당 컴포넌트를 쉽게 찾고 수정할 수 있도록 해두면 좋겠어요 냥.

### 전체적인 피드백
코드 전반적으로 잘 수행되고 있는 부분은 명확한 변수명과 컴포넌트 구조가 잘 되어 있다는 점이에요 냥. UI와 API 처리 방식에서 오류를 잘 감지하고 처리하는 방식도 좋았어요! 다만, 주석의 추가, UI 컴포넌트의 재사용성, 그리고 보안에 대한 추가적인 검증이 필요해 보여요.

유지보수성을 높이기 위해 문서화도 잊지 말고 해주세요 냥. 전체적으로 긍정적인 변화가 있네요! 수정 사항을 반영하면 더 좋을 것 같아요 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:23:22.222126', 132, '2024-11-13 18:23:22.222126', 26, '안녕하세요 냥! 코드 리뷰를 진행해 볼게요 냥. 각 항목을 통해 코드의 장단점을 살펴보고, 개선할 점도 찾아볼게요. 

## 1. **Readability (가독성)**
**잘 수행된 부분:**
- 전반적으로 변수명과 함수명은 명확한 편이야 냥. 예를 들어, `responseBody` 함수는 반환 값을 명확하게 설명하고 있어 냥.
- JSX 내에서의 조건문 사용도 잘 되어 있어서 읽기가 수월하네 냥.

**개선이 필요한 부분:**
- 일반적으로 `children`이나 `title` 같은 Props에 주석을 추가하면 더 직관적으로 이해할 수 있을 것 같아 냥. 각 컴포넌트가 어떤 Props를 받고 어떤 역할을 하는지 명시해주면 좋겠어 냥.

## 2. **Consistency (일관성)**
**잘 수행된 부분:**
- 코드 스타일이 전체적으로 일관되어 있으며, 클래스네임 작성 또한 동일한 패턴을 유지하고 있어 좋아 냥.
- 인터셉터 설정이 `axios`와 관련된 곳에서 잘 정리되어 있어 유지보수하기 수월해 보이네 냥.

**개선이 필요한 부분:**
- 일관성 문제는 작은 부분에서도 나타나, 예를 들어 `border` 색상 테마가 여러 곳에서 다르게 작성되어 있어 일관성이 떨어질 수 있어 냥. 통일된 색상을 사용하는 게 좋을 것 같아 냥.

## 3. **Reusability (재사용성)**
**잘 수행된 부분:**
- `AuthGuard`와 같은 컴포넌트는 여러 곳에서 재사용될 수 있어 재사용 가능한 구조를 잘 갖추고 있어 냥.
- UI 컴포넌트에서 더 작은 구성 요소로 잘 나누어져 있어서 필요시 쉽게 재사용 가능하네 냥.

**개선이 필요한 부분:**
- 여러 컴포넌트에서 비슷한 UI 패턴이 보이는데, 이를 별도의 공통 컴포넌트로 추출하면 재사용성이 더욱 강화될 거야 냥. 예를 들어, Tooltip UI를 별도의 컴포넌트로 분리해보는 것도 좋겠네 냥.

## 4. **Reliability (신뢰성)**
**잘 수행된 부분:**
- 에러 핸들링에 대한 로직이 적절하게 구현되어 있어, 사용자에게 문제가 생겼을 때 명확한 피드백을 줄 수 있어 좋은 점이야 냥.
- API 요청에 대한 성공 및 실패 처리도 잘 되어 있어서 안정감이 느껴지네 냥.

**개선이 필요한 부분:**
- 상태에 따른 로딩 처리와 같은 부분에서 서버 응답 결과에 따른 사용자 경험을 고려한 예외 상황 처리가 더 필요할 것 같아. 예를 들어, 로그인 실패 시 경고 메시지를 사용자에게 더 직관적으로 보여주는 방안도 좋겠어 냥.

## 5. **Security (보안성)**
**잘 수행된 부분:**
- 로그인 상태 확인 로직이 잘 구축되어 있어 사용자의 보안을 잘 고려하고 있어 냐냥.
  
**개선이 필요한 부분:**
- 서버와 통신할 때 민감한 데이터(예: 비밀번호, 개인 정보 등)의 처리에 대한 부분은 더욱 강화할 필요가 있어 보안 위협을 예방할 수 있도록 해줘야 해 냥.

## 6. **Maintainability (유지보수성)**
**잘 수행된 부분:**
- 각 컴포넌트가 독립적으로 만들어져 있어 유지보수가 용이해 보이는 점이 좋네 냥.
- 상태 관리가 Jotai와 같은 간단한 라이브러리를 사용해서 구현되어 있어 제어가 쉬워 보여 냥.

**개선이 필요한 부분:**
- 복잡한 상태나 로직은 특정한 Hooks로 분리해주면 더욱 좋을 것 같아. 이러면 코드의 가독성과 유지보수성을 크게 향상시킬 수 있어 냥.

## **전체적인 피드백**
코드가 전반적으로 잘 작성되어 있는 점이 많아 냥! 특히 컴포넌트를 잘 나눠 명확히 하는 점은 칭찬할 만해 냥. 하지만, 작은 부분에서의 일관성과 유형에 대한 개선이 필요해 보인단다 냥. UI/UX의 경우 일부 공통 부분을 모듈화하여 재사용과 유지보수를 고려하는 점도 잊지 않았으면 좋겠어 냥!

마지막으로, 몇 개의 경고나 예외 처리 추가로 보안성을 높이는 것도 함께 고려해주면 좋겠어 냥. 좋은 개선 방향성을 가지고 지속적으로 발전하는 코드를 만들어줘서 정말 잘하고 있어 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:23:46.575721', 133, '2024-11-13 18:23:46.575721', 26, '안녕하세요, 냥! 코드를 꼼꼼하게 리뷰해 드릴게요, 냥!

### 1. **Readability (가독성)**
잘한 점:
- 변수명과 함수명이 명확하고 간결하게 잘 지어졌어요, 냥! 예를 들어 `NavigationButtons`, `TerminalWindow` 같은 컴포넌트의 이름은 그 역할을 잘 설명해 주고 있어요.
- 주석이 필요한 곳에 적절히 작성되어 있어, 특히 각 컴포넌트의 목적을 간단히 설명하는 부분이 좋았어요, 냥.

개선 사항:
- `handleError` 함수의 주석이 있으면 좋을 것 같아, 냥. 어떤 에러가 발생할 때 어떻게 처리하는지 간단한 설명을 추가해주면 이해하는데 더 쉽게 느껴질 거야, 냥.

### 2. **Consistency (일관성)**
잘한 점:
- 기존 코드 스타일과 일관되게 작성을 잘 했어. 예를 들어, CSS 클래스 네이밍이 통일성을 유지하고 있어, 냥.
- 함수와 컴포넌트의 구조가 다른 곳과 잘 맞아떨어져, 전반적으로 자연스런 흐름을 유지하고 있어요.

개선 사항:
- 코드 포맷이 무엇보다 중요하니까 혹시 일관되지 않은 부분이 있을 수 있으니, 전체 파일에서 탭과 스페이스 사용이 일관되게 되어 있는지 재확인 해보면 좋을 것 같아, 냥.

### 3. **Reusability (재사용성)**
잘한 점:
- 기능 단위로 잘 분리되어 있어 다른 곳에서도 재사용하기 좋을 것 같아! `AuthGuard`와 같은 컴포넌트는 여러 곳에 적용될 수 있을 거야, 냥.

개선 사항:
- 특정 기능 (예: 에러 핸들링)을 별도의 훅이나 유틸리티 함수로 분리하면 재사용이 더 쉬워질 거야. 현재 여러 에러 처리에서 중복된 코드가 보이니 이를 개선해보면 좋겠어, 냥.

### 4. **Reliability (신뢰성)**
잘한 점:
- HTTP 에러(response status)에 대한 예외 처리를 잘 하고 있어! 각 상태 코드에 따라 적절한 동작을 수행하고 있으니, 안정적이야, 냥.

개선 사항:
- 예외 사항 발생 시, 사용자에게 알림(예: `alert`)보다는 UX를 고려해서 모달이나 사용자 친화적인 방법으로 에러를 표시하는 것이 더 나을 것 같아. 너무 많은 alert는 사용자에게 부담이 될 수 있어, 냥.

### 5. **Security (보안성)**
잘한 점:
- 사용자 로그인 상태를 체크하고 에러 핸들링을 통해 보안적인 위험을 잘 관리하고 있어요, 냥!

개선 사항:
- 혹시나 민감한 데이터가 노출될 것 같으니, `window.location.href`를 사용한 경로 변경은 피하면 좋겠어. `history.push` 같은 방법을 사용하면 SPA의 이점을 더 잘 살릴 수 있을 거야, 냥.

### 6. **Maintainability (유지보수성)**
잘한 점:
- 모듈화가 잘 돼 있어, 구성 요소들이 독립적으로 기능하니 유지보수가 쉬워 보이네, 냥!

개선 사항:
- 가능하다면 각 컴포넌트에 대해 `prop-types` 또는 TypeScript를 활용하여 타입 안전성을 높이면 좋겠어. 이렇게 하면 유지보수하는 과정에서도 더 쉽게 오류를 찾을 수 있을 거야, 냥!

### **전체적인 피드백**
잘 만든 부분:
- 전체적으로 컴포넌트가 명확하게 잘 구분되어 있어, 코드를 읽고 이해하기가 수월했어, 냥. 특히 UI 수정 부분이 깔끔하게 정리되어 있어서 좋았어!

개선이 필요한 부분:
- 주석 추가와 에러 핸들링 방법 개선, 그리고 코드의 일관성 체크가 필요해 보여. 추가적으로 재사용성을 높이기 위해 코드를 조금 더 모듈화하면 좋겠어, 냥.

전반적으로 잘 작성된 코드니, 다음 변경 사항들을 참고해서 더욱 발전시킨다면 더 좋은 결과물이 나올 거라고 생각해! 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:24:17.512581', 134, '2024-11-13 18:24:17.512581', 26, '냥~ 안녕하세요! 코드 리뷰를 시작할게요, 냥~ 이번에 변경된 부분을 중심으로 여러 평가 항목에 대해 살펴보도록 할게요, 냥~ 

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 코드가 전반적으로 깔끔하게 작성되어 있어 읽기 쉬워요, 냥. 특히, JSX 부분의 인덴트가 잘 되어 있어 각 요소의 계층 구조를 쉽게 파악할 수 있어요.
- **개선이 필요한 부분**: 몇몇 변수명과 함수명이 다른 부분과 일관성이 떨어질 수 있어요. 예를 들어 `responseBody`와 같이 명확한 이름을 사용한 것은 좋은데, `isLoading` 같은 경우에는 변수가 두 가지 상태를 정확히 설명하기 부족해 보이네요. 상태를 더 명확히 전달하는 이름으로 변경하는 것이 좋아요, 냥~ 또한, 주석이 적은 부분이 있어요. 코드의 복잡한 부분에는 주석을 추가하면 더 이해하기 쉬울 거예요, 냥~ 

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: import 스타일에서 `import { instance } from ''@config/apiConfig'';`와 같은 일관된 작성 방식이 좋네요, 냥~ 프로젝트 스타일 가이드에 따라 코딩하고 있는 것 같아요.
- **개선이 필요한 부분**: 함수의 괄호와 같은 작은 스타일 포맷이 때로는 불일치하게 보일 수 있어요. 예를 들어, JSX 속성에 대한 줄바꿈 또는 공백 처리가 다르게 적용될 수 있는데 (한 줄로 넘기는 경우 등), 통일성을 맞추면 좋겠어요, 냥~ 

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: `AuthGuard`와 같은 컴포넌트는 여러 페이지에서 재사용할 수 있어 구조적으로 잘 설계되었어요, 냥~ 
- **개선이 필요한 부분**: 특정 UI 로직이 여러 곳에 분산되어 있는 것들이 있어요. 예를 들어, 버튼 스타일이나 공통된 UI 요소는 별도의 컴포넌트로 분리해 재사용성을 높이는 것이 좋겠어요, 냥~ 

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 에러 핸들링에서 다양한 HTTP 상태 코드에 대해 잘 처리하고 있어요. `handleError` 함수가 잘 작성되어 있어 상황에 따라 적절한 반응을 하네요, 냥.
- **개선이 필요한 부분**: 에러 처리 내에서 경고 메시지나 페이지 리디렉션 같은 부분에서 사용자에게 명확한 피드백을 주는 것이 필요해요. 예를 들어, 로그인 실패 시 사용자에게 어떤 경고가 표시되는지 구체적으로 나타내는 것이 좋겠어요, 냥.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 민감한 데이터를 처리할 때 URL을 통한 직접 접근을 방지하는 방법이 잘 구현되어 있어요, 냥~ 
- **개선이 필요한 부분**: 사용자 입력 검증이 더 명확해야 해요. 예를 들어, 사용자가 입력할 수 있는 값에 대한 제한을 두어 SQL 주입 같은 공격을 방지하는 코드가 필요해 보여요, 냥~

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 프로젝트 구조가 모듈화되어 있어 큰 변경이 생겨도 서로 영향을 덜 받게 되어 있어 유지보수하기 좋아요, 냥.
- **개선이 필요한 부분**: 코드가 여러 파일에 분산되어 있어, 어떤 부분이 어디와 연결되는지 파악하기 어려울 수 있어요. 더불어, 파일과 디렉토리 구조도 점검해 더 명확히 이해할 수 있게 하면 좋겠어요, 냥~

### **전체적인 피드백**
- 코드 전반적으로 기본적인 구조와 스타일이 잘 되어 있어요, 냥! 특히 기능적으로 명확한 컴포넌트 설계와 에러 처리 부분이 긍정적이에요.
- 개선이 필요한 부분은 일관성, 재사용성, 그리고 사용자 경험을 고려한 예외 처리와 주석 추가로, 완성도를 높일 수 있을 것 같아요, 냥~ 

마지막으로, 컴파일 에러나 런타임 에러가 발생할 경우 반드시 확인하고 수정하는 것이 중요해요! 좋은 결과가 있기 때문에 노력한 만큼 코드도 더욱 빛날 거예요, 냥~');
INSERT INTO public.review VALUES ('2024-11-13 18:24:47.854904', 135, '2024-11-13 18:24:47.854904', 26, '냥! 코드를 리뷰해볼게요, 냥! 이렇게 다양한 변경사항이 있었구나, 냥!

### 1. Readability (가독성)
- **잘한 점**: 함수와 변수명이 명확하고 이해하기 쉬워요, 냥! 또한 JSX를 사용하는 부분은 구조가 잘 정리되어 있어서 한눈에 이해하기 쉬워요.
- **개선 제안**: 특별히 복잡한 로직이 들어간 부분에는 주석을 추가하면 더욱 좋을 것 같아요, 냥! 예를 들어, `handleError` 함수의 경우 각 에러 코드에 대한 설명을 주석으로 달아주면 나중에 코드 보기가 더 수월해질 거예요!

### 2. Consistency (일관성)
- **잘한 점**: 코드 스타일이 전반적으로 일관되게 잘 유지되고 있어요. 특히 CSS 클래스 네이밍이 통일되어 있어서 좋네요, 냥!
- **개선 제안**: 다만 JSX 코드의 들여쓰기 스타일이 조금씩 다르니 통일성을 위해 일관된 스타일로 맞추면 좋겠어요, 냥. 예를 들면, 버튼에서의 `className` 속성 같은 경우에 일관된 길이로 정리해주면 깔끔해 보일 거예요.

### 3. Reusability (재사용성)
- **잘한 점**: `AuthGuard`와 같이 명확한 기능 단위로 나뉘어져 있어서 다른 컴포넌트에서도 재사용이 쉬운 구조네요, 냥! 
- **개선 제안**: 다만 `TerminalWindow` 같은 경우에는 속성이 하드코딩되어 있어서, 필요에 따라 더 다양한 스타일을 받을 수 있도록 props를 추가하면 더욱 재사용성 높은 컴포넌트가 될 것 같아요, 냥.

### 4. Reliability (신뢰성)
- **잘한 점**: `handleError` 함수에서 다양한 에러에 대해 체계적으로 처리가 잘 되고 있어요, 냥! 사용자의 피드백을 위해 alert를 활용한 점도 좋네요.
- **개선 제안**: 하지만 에러 처리 시에 console.error 외에 좀 더 직관적인 사용자 피드백도 추가해주면 좋을 것 같아요. 예를 들어, UI 상에서 사용자에게 에러 메시지를 보여주는 방식으로 개선하면 더 친절해 보일 거예요, 냥!

### 5. Security (보안성)
- **잘한 점**: 로그인 검증 같은 기능이 잘 구현되어 있어서 보안성을 높이고 있어요, 냥!
- **개선 제안**: 다만, API 호출 시 URL 파라미터나 사용자 입력 값에 대한 검증이 부족한 것 같아 보이니 추가적인 입력 검증을 고려해봐야 할 것 같아요, 냥!

### 6. Maintainability (유지보수성)
- **잘한 점**: 코드가 모듈화되어 있어 변경이 용이해 보여요. 특히 컴포넌트가 서로 잘 분리되어 있어서 유지보수가 쉬울 듯해요, 냥!
- **개선 제안**: 그러나 각 컴포넌트의 기능과 역할이 세분화되면 더욱 유지보수성이 높아질 거예요. 예를 들어, 상태 관리를 위한 훅을 별도로 만들고 이를 여러 컴포넌트에서 사용하도록 하면 더욱 깔끔해질 거예요, 냥!

### 전체적인 피드백
코드 전체적으로 잘 작성된 부분이 많아서 칭찬해주고 싶어요, 냥! 특히, UI 컴포넌트가 깔끔하게 구성되어 있어 사용자가 쉽게 이해할 수 있을 것 같아요. 하지만 몇몇 부분에서는 개선의 여지가 보이니 위에서 언급한 사항들에 대해 한 번 더 점검해 주면 좋을 것 같아요, 냥!

개선이 필요한 점은 명확하고 구체적인 제안을 해주면 좋겠어요. 그러면 코드 품질이 더 개선될 거예요, 냥! 

좋은 하루 되세요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:25:50.299458', 136, '2024-11-13 18:25:50.299458', 26, '안녕하세요냥! 코드 변경 사항을 리뷰해볼게요냥. 각 항목별로 잘 수행되고 있는 부분과 개선이 필요한 부분을 살펴볼게요냥.

### 1. **Readability (가독성)**
- **잘 수행하고 있는 부분**: 변수명과 함수명이 의미가 명확하여 코드를 빠르게 이해할 수 있었어요냥. 예를 들어, `handleError` 함수는 네트워크 에러와 HTTP 상태 코드를 구분하는 일을 하고 있는데, 함수 이름만으로도 그 역할이 명확하게 드러나네요냥.
- **개선이 필요한 부분**: 몇몇 코드 블록에 주석이 없다보니 초보자가 이해하기 힘들 수 있어요냥. 예를 들어, `AuthGuard`와 같은 컴포넌트의 기능을 설명하는 주석이 있으면 좋을 것 같아요냥.

### 2. **Consistency (일관성)**
- **잘 수행하고 있는 부분**: 코드 스타일과 구조가 일관되게 유지되고 있어요냥. 예를 들어, 컴포넌트의 props 및 상태를 관리하는 방식이 통일되어 있습니다냥.
- **개선이 필요한 부분**: `className`이나 기타 JSX에 있는 속성값의 표기법이 가끔씩 다르게 사용되니깐, 팀 내에서 CSS 속성 표기법을 통일하는 것이 좋겠어요냥.

### 3. **Reusability (재사용성)**
- **잘 수행하고 있는 부분**: 몇몇 컴포넌트가 재사용 가능하게 잘 설계되어 있네요냥. 특히 `Badge`와 같은 컴포넌트는 다양한 곳에서 재사용될 수 있도록 props로 구성되어 있어요냥.
- **개선이 필요한 부분**: `handleError`와 같은 오류 처리 로직은 다양한 부분에서 사용되기에, 더 넓은 범위로 재사용할 수 있도록 별도의 유틸리티 파일로 분리할 수 있으면 좋겠어요냥.

### 4. **Reliability (신뢰성)**
- **잘 수행하고 있는 부분**: 예외 처리 부분이 잘 구현되어 있어서, API 호출 실패 시 적절한 대처를 할 수 있도록 되어 있으니 믿음직스러워요냥.
- **개선이 필요한 부분**: `AuthGuard`에서 로그인 체크 후 에러 처리를 하는 방식은 로그인 페이지로 이동하는 로직이 명확치 않아서, 예외 시 더 나은 사용자 경험을 위해 꼭 필요한 피드백을 주면 좋겠어요냥.

### 5. **Security (보안성)**
- **잘 수행하고 있는 부분**: `instance` 설정에서 `withCredentials` 옵션을 추가한 것이 잘 이루어졌어요냥. 이는 보안적인 측면에서 중요하니까요냥.
- **개선이 필요한 부분**: 사용자 입력값 처리 시 직접적으로 DOM에 접근하는 부분에서 XSS 공격을 방지하기 위한 입력 검증 코드를 강화하는 것이 좋을 것 같아요냥.

### 6. **Maintainability (유지보수성)**
- **잘 수행하고 있는 부분**: 컴포넌트가 눈에 띄게 구조화되어 있어, 변경이 생길 경우 쉽게 수정할 수 있을 것 같아요냥. 특히 각 컴포넌트가 독립적인 기능을 가지려는 모습이 좋네요냥.
- **개선이 필요한 부분**: 코드의 양이 많아질 경우, 모듈화가 더 필요할 수 있어요냥. 예를 들어, `NavigationButtons`와 같은 새로운 컴포넌트를 추가했으니, 이를 중앙화해서 관리할 수 있는 방법을 고려해보세요냥.

### 전체적인 피드백
- 전반적으로 코드를 잘 작성하셨고, 여러 부분에서 가독성과 유지보수성을 고려한 모습이 보여서 매우 긍정적이에요냥!
- 개선해야 할 부분들이 있지만, 특히 주석 추가와 에러 처리 방식, 그리고 코드 구조화에 대한 다듬음을 통해 코드 품질을 더욱 높일 수 있을 것 같아요냥.

보다 나은 코드 환경을 만들어가길 응원할게요냥! 다른 질문이 있으면 언제든지 물어보세요냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:26:10.136114', 137, '2024-11-13 18:26:10.136114', 26, '안녕하세요냥! 코드 리뷰를 맡게 되어 너무 기쁘고, 요청하신 리뷰를 진행할게요냥~!

### 1. Readability (가독성)
코드 전반적으로 가독성이 좋고, 변수명과 함수명이 명확하게 잘 작성되어 있어 이해하기 쉬운 부분이 많았어요냥. 특히 `AuthGuard`, `NavigationButtons`, `TerminalWindow` 같은 이름들은 그 기능을 잘 설명하고 있어 훌륭하다고 생각해요. 다만, 코드 중 적절한 주석이 부족한 부분이 있어요냥. 주석을 통해 코드의 의도를 명확히 하는 것은 유지보수에 큰 도움이 되므로, 특히 복잡한 로직이나 예외 처리가 있는 부분에는 인라인 주석을 추가하는 것이 좋겠어요냥.

### 2. Consistency (일관성)
코드 스타일과 명명 규칙이 전반적으로 일관되게 유지되고 있어 좋았어요냥. 하지만 일부 스타일 혹은 이름이 다른 곳과 어긋나는 경우도 보였어요. 예를 들어, `bg-primary-500`와 같은 Tailwind CSS 클래스명은 잘 사용했지만, 다른 곳에서 같은 형태의 속성이 자주 나타나므로, 일관된 이름 사용을 더욱 강조하면 좋겠어요. 또한, 파일 및 폴더 구조가 프로젝트 전반에 걸쳐 일관되게 유지되고 있는지 다시 한 번 점검해보는 것이 좋겠어요냥.

### 3. Reusability (재사용성)
코드가 기능 단위로 잘 분리되어 있어, 다른 곳에서도 재사용할 수 있을 것 같아요. 특히 `AuthGuard`와 같이 인증 로직을 별도로 모듈화하여 구현한 점은 재사용성 측면에서 매우 긍정적이에요냥. 다만, 어떤 특정 기능이 다른 컴포넌트에서 필요할 경우, 재사용이 가능하도록 추상화된 함수나 컴포넌트로 만드는 것이 좋겠어요.

### 4. Reliability (신뢰성)
예외 처리와 오류 검출이 잘 구현되어 있어 안정성을 높이는데 기여하고 있어요냥. `handleError` 함수에서 HTTP 상태 코드에 따라 적절히 분기하여 처리하는 것이 특히 좋았어요. 그러나 401 상태 코드에 대한 처리 후, 사용자가 로그인 페이지로 이동했을 때의 UX나 UX 플로우를 좀 더 고려할 필요가 있어 보였어요냥. 사용자에게 더 친절한 메시지를 제공하거나 별도의 로그인 리다이렉트를 고려해보면 좋겠어요.

### 5. Security (보안성)
보안적으로도 깨알같이 신경 쓴 점이 보였는데, 사용자 인증과 관련된 코드에서 보안성을 고려한 점이 좋았어요. 다만, 입력 검증이나 민감한 데이터 처리 부분에 대해서는 더 철저히 검토가 필요해 보였어요냥. 예를 들어, 사용자 입력을 다룰 때, SQL 인젝션이나 XSS 공격을 예방하기 위해 더욱 철저한 검증 로직이 필요할 것 같아요.

### 6. Maintainability (유지보수성)
유지보수성 측면에서는 코드가 잘 구조화되어 있어, 향후 수정이나 기능 추가 시 유용할 것 같아요. 모듈화와 단일 책임 원칙이 잘 적용되어 있어서, 기능이 변경될 때 영향을 최소화할 수 있을 것 같아요냥. 다만, 주기적인 코드 리팩토링이나 코드 리뷰를 통해 지속적으로 깨끗한 코드를 유지하는 것이 중요하니까 잊지 말고 해주세요냥.

### Overall Feedback (전체적인 피드백)
전체적으로 코드가 잘 작성되어 있고, 여러 면에서 긍정적인 점이 많았어요냥. 특히 가독성과 일관성 부분에서 높은 점수를 줄 수 있을 것 같아요. 다만, 주석 부족, 입력 검증 미비 점, 사용자 경험 개선 부분은 반드시 개선이 필요할 것 같아요냥. 이러한 점들이 개선된다면 더욱 우수한 코드로 발전할 수 있을 거라고 믿어요! 항상 열심히 하는 개발자님, 고생 많았어요냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:27:51.067819', 138, '2024-11-13 18:27:51.067819', 27, '안녕하세요, 귀여운 고양이 냥! 코드 리뷰를 시작할게요, 냥!

### 1. Readability (가독성)
코드는 전반적으로 가독성이 좋고, 각 변수명과 클래스명이 자기가 하는 일을 잘 표현하고 있어요. 여러 UI 컴포넌트의 클래스 이름들이 직관적이에요, 냥. 하지만 몇몇 부분에서는 주석이 부족해 보이니, 복잡한 로직이나 함수의 간단한 설명을 추가하면 더욱 좋을 것 같아요. 예를 들어, `ReviewComment`와 같은 컴포넌트는 그 역할에 대한 간단한 주석을 추가하면 이해하는 데 도움이 될 거예요, 냥!

### 2. Consistency (일관성)
CSS 클래스명 사용에 있어서 일관성이 유지되고 있어요. 하지만 `border-2`와 같이 다른 두께를 정하기 위해 숫자를 직접 사용하지 않고, `[1px]`와 같은 방법을 사용한 부분은 조금 더 통일되면 좋을 것 같아요. 스타일의 정의가 왜 달라졌을지에 대한 이유를 주석으로 작성하면 좋을 것 같아요, 냥.

### 3. Reusability (재사용성)
컴포넌트가 비교적 잘 분리되어 있어서 재사용 가능성이 높아요. `NavButton` 같은 경우가 그 예시죠! 추가로, 특정 클래스명이나 로직이 반복되는데, 이를 공통된 함수나 상수로 빼내어 재사용 가능하게 하면 유지보수성과 가독성이 더 좋아질 것 같아요, 냥. 예를 들어, 색상이나 클래스에 대한 상수를 별도로 정의해서 사용하는 것이 좋겠어요.

### 4. Reliability (신뢰성)
전반적으로 코드는 잘 작동할 것 같아요. 다만, 에러 핸들링 부분이나 UI의 특정 조건에 따른 다이나믹한 변화에 대해 고려할 필요가 있어요. 예를 들어, 만약 `handleAddReference` 같은 함수가 호출될 때 적절한 예외처리 로직이 필요해 보입니다. 사용자가 어떤 입력을 잘못할 경우에 대한 대처도 중요하답니다, 냥!

### 5. Security (보안성)
보안적인 측면에 대한 명시적인 고려는 잘 보이지 않아요. 사용자의 입력 값을 검증하는 로직이 반드시 필요해요. 특히 외부 API와 통신할 때, 혹은 사용자 데이터를 처리할 때 CSRF나 XSS 같은 공격에 대한 방어 코드를 추가하는 것을 강력히 추천해요, 냥. 추가로 비밀번호나 API 키 같은 민감한 데이터는 환경 변수로 관리하는 것이 안전해요!

### 6. Maintainability (유지보수성)
코드는 전반적으로 잘 모듈화되어 있지만, 프로젝트가 커질수록 유기적이고 구조적인 접근이 필요할 것 같아요. 각 컴포넌트의 책임을 명확히 해주는 것이 좋고, 각 기능별로 파일을 구분하여 사용자들이 쉽게 접근할 수 있도록 하면 좋겠어요. 앞으로 기능이 추가되거나 변경될 때 유용할 거예요, 냥!

### 전체적인 피드백
전반적으로 코드가 깔끔하고 잘 작성된 점이 많아요, 특히 UI 컴포넌트들이 조화롭게 배치되어 사용자 경험을 향상시키고 있다는 점이 인상적이에요! 그러나 예외 처리, 보안 고려, 주석 추가, 그리고 일관된 스타일 유지에 대한 부분은 개선이 필요해요. 개선하실 부분을 반영하시면 코드 품질이 훨씬 좋아질 거예요, 냥!

기타 궁금한 사항이 있다면 언제든지 물어봐 주세요, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:28:13.614447', 139, '2024-11-13 18:28:13.614447', 27, '안녕하세요, 냥! 코드 리뷰를 시작할게요, 냥! 각 항목에 대해서는 잘 수행되는 부분과 개선이 필요한 부분을 잘 살펴봤으니, 아래에 설명할게요!

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명(`bgColor`, `textColor`)과 함수명(`NavButton`, `CommonReference`)이 의미가 명확하고, 어떤 역할을 하는지 쉽게 알아볼 수 있어, 읽기 쉬운 부분이야, 냥!
- **개선이 필요한 부분**: 코드의 일부에 주석이 부족해. 특히 중요한 로직이나 복잡한 부분에는 주석을 추가하면 좋을 것 같아. 예를 들어, `const bgColor`의 조건부 로직이 왜 이렇게 설정되었는지 주석을 달면 더 이해하기 쉬울 거고, 냥!

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: CSS 스타일 클래스와 변수 사용을 통해 일관된 스타일 유지가 잘 되고 있어, 냥. `border-[1px]`와 같은 형태로 통일성을 유지했어.
- **개선이 필요한 부분**: 클래스 이름에 일관된 접두사를 사용하는 것이 좋을 것 같아. 예를 들어, `border-secondary2`와 같이 사용한 것과 관련하여, 프로젝트 전반에 걸쳐 이러한 기준이 통일되어 유지되면 코드를 더 깔끔하게 만들 수 있을 거야, 냥!

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: UI 컴포넌트가 매우 독립적인 기능 단위로 잘 나뉘어져 있어 `ReviewComment`, `NavButton` 등이 재사용할 수 있는 구조로 되어있어. 잘하고 있어, 냥!
- **개선이 필요한 부분**: 만약 어떤 스타일이나 로직을 여러 컴포넌트에서 사용해야 한다면, 공통된 스타일이나 기능을 모듈화하여 별도의 유틸리티 파일로 분리하면 재사용성을 더욱 높일 수 있을 것 같아, 냥!

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: CSS 클래스의 조건적 적용(`type === ''CODE''`)이 잘 되어 있어, UI의 상태가 명확하게 표현되고 있어, 냥!
- **개선이 필요한 부분**: 코드에 예외 처리나 오류 검출이 부족해 보여. 특히 데이터 fetching이라든지, 사용자 입력을 받는 부분에 대한 예외 처리를 추가하면 더욱 신뢰성 있는 코드를 만들 수 있을 것 같아, 냥!

### 5. **Security (보안성)**
- **잘 수행된 부분**: 사용자 입력을 받는 부분에서는 `disabled={!isEditing}`과 같은 조건처리를 통해 잘 보호되고 있어, 냥!
- **개선이 필요한 부분**: 입력값 검증이 필요해 보여. 특히 사용자 입력을 받는 컴포넌트에 대해 검증 로직을 추가하는 것이 좋을 것 같아. 이는 보안에 큰 도움이 될 거야, 냥!

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 각 컴포넌트를 모듈화하여 변경할 때 한 곳만 수정하면 되니까 유지보수가 용이해 보여, 냥!
- **개선이 필요한 부분**: 각 파일의 책임을 좀 더 명확히 하는 것이 좋을 것 같아. 예를 들면, 각기 다른 비즈니스 로직이 한 파일에 함께 포함되어 있다면, 코드의 유지보수가 힘들어질 수 있으니 함수나 컴포넌트를 적절히 분리하는 방법을 고려해봐, 냥!

### **전체적인 피드백**
코드 전반적으로 **가독성과 일관성**이 잘 유지되고 있으며 잘 구조화된 모습이야, 냥! 특히 **UI 컴포넌트의 재사용성**과 **모듈화**가 눈에 띄게 좋고, 유지보수성 측면에서도 장점이 많아 보이네!

하지만 **검증과 예외 처리**가 부족하고, **주석 및 설명**이 부족한 점은 아쉬운 부분이야. 세부적인 개선 사항들을 반영한다면 더욱 완성도 높은 코드가 될 것 같아, 냥! 긍정적인 피드백과 함께 앞으로도 지속적으로 발전할 수 있도록 노력해보자, 냥!');
INSERT INTO public.review VALUES ('2024-11-13 18:28:32.001116', 140, '2024-11-13 18:28:32.001116', 27, '안녕하세요, 냥! 코드 리뷰를 시작할게요, 냥~ 

### 1. **Readability (가독성)**
코드의 가독성은 전반적으로 양호해, 냥. 변수명과 클래스명 등은 의미가 잘 전달되고 있어서 이해하는 데 큰 문제가 없어, 냥. 

- 예를 들어 `bgColor`, `textColor`와 같은 변수명은 그 기능이 잘 드러나서 이해하기 쉬워, 냥.
- 하지만 주석이 부족한 점은 아쉬워. 복잡한 로직이나 주요 기능에 대한 설명 주석을 추가하는 것이 좋겠어, 냥. 특히 다른 개발자가 코드를 보았을 때 맥락을 빠르게 이해할 수 있도록 돕는 관련 주석이 필요해, 냥.

### 2. **Consistency (일관성)**
코드 스타일과 명명 규칙이 일관되게 유지되고 있는지는 잘 유지해주고 있어. CSS 클래스 네이밍, 컴포넌트 구조 등이 잘 통일되어 있네, 냥.

- 하지만 `border-2`와 같은 마법의 숫자 클래스를 `border-[1px]`와 같이 사용한 부분은 프로젝트 전반적으로 어떤 기준으로 설정되어 있는지 다시 검토해보면 좋겠어. 프로젝트의 통일성을 위해 이러한 세부사항을 정리해 두면 좋을 것 같아, 냥.

### 3. **Reusability (재사용성)**
코드는 독립적인 기능 단위로 잘 분리되어 있는데, 이는 재사용성에 긍정적인 영향을 미치고 있어, 냥.

- 예를 들어, `ReviewComment`와 같은 컴포넌트는 다른 곳에서도 유용하게 재사용될 수 있을 것 같아. 하지만 컴포넌트가 우너하는 prop에 대한 타입 및 기본값 설정이 누락된 경우가 있어, 좀 더 명확하고 재사용성을 높이기 위해 props 타입을 명확히 하길 권장해, 냥.

### 4. **Reliability (신뢰성)**
코드가 의도대로 작동하는 듯 보이고, 기본적인 동작에는 문제가 없어 보이네, 냥.

- 하지만 예외 처리에 대한 부분이 저조한 것 같아. 사용자가 잘못된 입력을 할 경우 어떻게 처리할 지에 대한 로직이 필요해 보여, 냥. 예를 들어, `handleFileNameChange`와 같은 함수에서 파일명이 비어있거나 유효하지 않은 경우의 처리 로직을 추가해주면 좋겠어, 냥.

### 5. **Security (보안성)**
보안성에 대한 신경은 좀 더 많이 써야 할 것 같아, 냥.

- 민감한 데이터에 대한 처리는 언제나 조심해야 해, 냥. 예를 들어, 리뷰어 이름이나 코멘트 내용을 출력할 때 XSS 공격을 방어하기 위해 변환하는 절차가 필요할 수 있어, 냥. 입력 검증을 추가하는 것과 가능하면 파라미터화된 쿼리 사용 등을 고려해봐, 냥.

### 6. **Maintainability (유지보수성)**
코드는 수정하기 쉽도록 잘 구조화되어 있어, 냥.

- 하지만 코드에 대한 문서화가 부족한 것 같아. 각 컴포넌트의 목적 및 사용법에 대한 문서가 있으면 다른 개발자들이 유지보수를 진행할 때 큰 도움이 될 거야, 냥. 유지보수성을 높이기 위한 단일 책임 원칙(SRP)도 고려해보면 좋겠어, 냥.

### **전체적인 피드백**
코드 전반적으로 가독성, 일관성, 재사용성 측면에서 잘 작성되어 있어, 냥. 코딩 스타일과 변수명이 명확하고 일관성 있게 유지되어 있네, 냥. 하지만 예외 처리, 보안성, 그리고 문서화 등에서 개선의 여지가 있어. 이러한 부분에 신경 써서 다음 번에는 더욱 완벽한 코드로 돌아오길 기대할게, 냥! 

변경된 코드가 컴파일 에러나 런타임 에러를 발생시킬 가능성이 있는 부분이 있다면, 이를 꼭 수정하길 권장할게, 냥! 앞으로 더 발전된 코드로 계속 발전하길 응원할게, 냥~!');
INSERT INTO public.review VALUES ('2024-11-13 18:28:53.581401', 141, '2024-11-13 18:28:53.581401', 27, '안녕냥! 코드 리뷰를 시작할게, 움짤 움짤! 냥~ 🐾

### 1. **Readability (가독성)**
- **잘 수행된 점**: 변수명과 클래스명들이 명확해서 코드의 의도를 이해하기 쉬워. 예를 들면, `active`, `className`, `fileName` 등은 그 역할이 잘 드러나서 좋았어.
- **개선이 필요한 점**: 몇몇 변수가 어떤 값을 가지는지에 대한 설명이 부족해 보이는 부분이 있어. 예를 들어, `type` 변수의 경우 ''CODE''라는 값이 어떤 역할을 하는지 주석이 있으면 좋을 것 같아. 주석을 추가해서 각 변수가 어떤 역할을 하는지 설명해 주면 더 좋을 듯해, 냥~

### 2. **Consistency (일관성)**
- **잘 수행된 점**: 코드 스타일이 대체로 일관적이어서 보기 좋아. CSS 클래스명도 통일성이 있게 작성되어 있어.
- **개선이 필요한 점**: border 관련 속성에서 숫자 단위의 표현이 혼용되고 있어, (`border-2`, `border-[1px]`, `border-1px`) 통일성을 위해 같은 방식으로 사용하는 것이 좋겠어. 이 부분을 정리하면 더 깔끔해질 거야!

### 3. **Reusability (재사용성)**
- **잘 수행된 점**: 여러 컴포넌트들이 명확한 책임을 가지고 독립적으로 작동하고 있어. 특히 `ReviewComment` 같은 컴포넌트는 다른 곳에서도 재사용하기 적합해 보여.
- **개선이 필요한 점**: 다만, CSS 클래스명들이 자주 하드코딩되어 있는 것 같아. 재사용 가능한 스타일 변수나 미리 정의된 클래스를 사용하는 게 좋을 것 같아. 예를 들어, 색상이나 사이즈는 변수로 선언해서 사용하면 재사용성을 높일 수 있어.

### 4. **Reliability (신뢰성)**
- **잘 수행된 점**: 기본적인 기능은 잘 수행되고 있는 것 같아. 전반적으로 코드가 의도대로 잘 작동할 것으로 보여.
- **개선이 필요한 점**: 예외 처리나 오류에 대한 확인이 부족한 부분이 보여. 특히 사용자 입력을 받을 때는 처리가 필요해. 입력이 유효한지 검증하는 로직을 추가하면 신뢰성을 높일 수 있어.

### 5. **Security (보안성)**
- **잘 수행된 점**: 보안 관련해서는 명확히 언급된 부분이 없어 보이지만, 직접적으로 민감한 데이터 처리나 외부 입력이 사용되는 것 같지는 않아.
- **개선이 필요한 점**: 사용자가 입력하는 값을 받을 때, XSS 공격 등의 위험을 막기 위한 처리가 필요해 보여. 예를 들어, `dangerouslySetInnerHTML` 같은 위험한 메소드는 지양하고, 사용자 입력값을 적절히 이스케이프 처리하는 것이 좋겠어.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 점**: 코드 구조가 잘 나뉘어져 있어 수정이 쉬운 구조야. 컴포넌트별로 명확한 책임이 있어 유지보수가 용이해 보여.
- **개선이 필요한 점**: 특정 컴포넌트들 사이에 비슷한 로직이 반복되는 부분이 있어. 이럴 때 공통된 기능은 훨씬 더 전략적이고 효율적으로 모듈화할 수 있을 거야.

### **전체적인 피드백**
- 코드 전반적으로 잘 작성되어 있고, 가독성도 좋으며, 명확한 구조를 가지고 있어. 긍정적인 피드백을 드리고 싶어! 하지만 일부 부분에서는 일관성을 높이기 위해 통일성이 필요해 보여. 특히 CSS 클래스나 변수명 관련해서는 표준화된 방법을 지키는 것이 좋겠어. 

- 사용자 입력 검증이나 예외 처리의 추가는 신뢰성과 보안을 높여줄 테니 굉장히 중요한 수정이겠어. 고양이 기운을 더해 더욱 멋진 코드로 만들어 보자냥! 🐾✨

코드 리뷰는 이상으로 마칠게. 추가적인 질문이 있다면 언제든지 물어봐 줘, 냥!');
INSERT INTO public.review VALUES ('2024-11-18 10:18:18.731366', 214, '2024-11-18 10:18:18.731366', 56, '코드 개선을 위한 몇 가지 제안입니다:

1. **핸들러 초기화 메서드 삭제**: 핸들러 초기화가 생성자에서 단 한 번만 이루어지는 경우, `@PostConstruct` 대신 `Map.of`를 이용한 초기화가 더 직관적입니다. 따라서 기존 주석을 제거하고 `Map.of`를 활용하는 것으로 충분합니다.

2. **로그 레벨 일관성 유지**: `handleMerge` 메서드의 로그 메시지가 `#handleMerged`로 되어 있는데, 동작에 대한 명확성을 위해 "Merged" 대신 "Merge"를 사용하는 것이 좋습니다.

3. **메서드 이름 개선**: `handlePush` 대신 `handleMerge`로 이름을 변경하였으나, 기능적으로 분리된 핸들링이 필요하다면 각각의 메서드를 명확하게 정의하는 것이 좋습니다.

4. **예외 처리를 고려**: Gitlab 이벤트 처리 중 발생할 수 있는 예외를 명시적으로 핸들링하여 안정성을 높이는 방법을 고려해보세요.

5. **Branch String 처리**: `branchName`을 `gitlabEventRequest.objectAttributes().targetBranch();`로 수정한 것은 좋지만, `targetBranch`가 null일 가능성을 고려하여 null 검사도 추가하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-14 09:47:30.920756', 142, '2024-11-14 09:47:30.920756', 29, '안녕하세요냥! 코드 리뷰를 시작할게요냥. 코드를 보니 여러 좋은 점이 있지만, 개선할 부분도 몇 군데 보이는 것 같아냥. 각 항목별로 평가를 해볼게요:

### 1. Readability (가독성)
잘 하고 있는 부분:
- 클래스, 메서드, 변수명들이 대체로 명확하고, 의도한 바를 잘 나타내고 있어냥. 예를 들어, `BaseChunkStrategy` 클래스와 메서드 `chunk()`는 기능을 잘 설명하고 있다냥.

개선이 필요한 부분:
- 주석이 부족해 보인다냥. 각 클래스와 메서드에 대해 어떤 기능을 수행하는지 간단한 설명이 있으면 더 이해하기 쉬울 거 같아. 특히 복잡한 로직이 있는 곳에는 주석을 추가하는 게 좋겠어.

### 2. Consistency (일관성)
잘 하고 있는 부분:
- 코드 스타일이 전반적으로 일관되며, 파일과 클래스 이름들이 일정한 규칙을 따르고 있어 좋아 보인다냥.

개선이 필요한 부분:
- `FileUtil`의 `getFileExtension()` 메서드처럼, 코드 포맷팅이 조금 달라 보인다냥. 메서드 간 간격이나 괄호 사용에 대한 스타일이 통일되면 더욱 좋을 것 같아.

### 3. Reusability (재사용성)
잘 하고 있는 부분:
- `BaseChunkStrategy` 구현이 독립적이고 다른 `ChunkStrategy`와의 결합도가 낮아 재사용이 용이해 보인다냥.

개선이 필요한 부분:
- 여러 파일 유형에 대한 전략 패턴을 잘 사용했지만, `BaseChunkStrategy`를 확장하면 다양한 전략을 추가할 수 있음을 명확히 해주면 좋겠어. 예를 들어 특정 파일 형식에서의 충돌을 줄이기 위해 더 특정화된 구현을 제공할 수도 있어 냥.

### 4. Reliability (신뢰성)
잘 하고 있는 부분:
- `chunk()` 메서드에서 파일의 내용을 바이트 배열로 변환 후 처리하고 있어 안정적인 데이터 처리가 이루어지는 것 같아 보인다냥.

개선이 필요한 부분:
- 예외 처리가 부족하다냥. 예외 발생 시 적절한 처리를 하도록 수정하는 것도 좋고, 예외 메세지를 사용자에게 보여줄 수 있는 로직을 추가하면 더 좋을 것 같아.

### 5. Security (보안성)
잘 하고 있는 부분:
- 특정 파일에서 내용을 읽어오는 부분에서 안전하게 처리하려는 모습이 보인다냥.

개선이 필요한 부분:
- 사용자가 제공하는 파일에 대한 검증 로직이 부족하다냥. 파일 경로에 대한 검사나 파일 타입 검증을 추가하면 보안이 더 강화될 것 같아. 또한, 적절한 예외 처리를 통해 공격자가 파일에 접근하는 것을 방지할 수 있을거야.

### 6. Maintainability (유지보수성)
잘 하고 있는 부분:
- `ChunkStrategyFactory` 패턴을 활용하여 전략을 관리하는 구조가 잘 되어 있어서 유지보수가 용이해 보인다냥.

개선이 필요한 부분:
- 각 전략에 대한 명시적인 인터페이스 설명이 있으면 좋겠어. 어떤 전략이 어떤 기능을 수행하는지 잘 알고 넘어가면 추후 유지보수 시 한눈에 파악하기 쉽겠어.

### 전체적인 피드백:
전반적으로 코드가 잘 작성되었고, 기본적인 기능은 잘 구현되었어냥. 그러나, 주석 추가, 예외 처리 강화, 보안성 검토, 그리고 스타일 일관성이 필요한 부분들이 있었어. 이를 개선하면 더욱 가독성 좋고, 튼튼한 코드로 발전할 수 있을 거야. 수고했어냥! 😊
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 10:00:42.676886', 143, '2024-11-14 10:00:42.676886', 27, '냥~ 안녕! 코드 리뷰 요청을 해 줘서 고맙냥! 변경 사항을 꼼꼼히 살펴볼게. 아래의 6가지 평가 항목을 바탕으로 피드백을 줄게냥.

1. **Readability (가독성)**:
   - **잘하는 부분**: 변수명과 함수명이 대체로 명확하게 지어져 있어, 코드의 의도를 이해하기 쉬워. 예를 들어, `NavButton` 함수는 해당 기능이 버튼을 나타내는 것임을 알 수 있어.
   - **개선이 필요한 부분**: 주석이 부족해. 복잡한 로직이 없더라도, 컴포넌트별로 어떤 역할을 하는지 간단한 주석을 추가하면 더욱 이해하기 쉬워질 거야. 또, 여러 스타일 속성을 한 줄에 나열하는 대신, 줄바꿈을 활용해 가독성을 높이는 것도 좋겠어.

2. **Consistency (일관성)**:
   - **잘하는 부분**: CSS 클래스 네이밍과 파일 구조가 어느 정도 일관되게 유지되고 있어. 그런 부분은 프로젝트 전반에 좋은 영향을 줄 거야.
   - **개선이 필요한 부분**: 몇몇 클래스 네임에 사용된 경량화된 반복된 숫자, 예를 들어 `border-[1.2px]`와 같은 표현은 다른 부분과 일관성이 떨어져 보여. `border-2`와 같이 정수로 설정하는 것이 가독성과 일관성에 더 도움을 줄 것 같아.

3. **Reusability (재사용성)**:
   - **잘하는 부분**: `ReviewComment` 같은 컴포넌트는 재사용성이 높게 잘 작성되어 있어. 다른 곳에서도 쉽게 사용할 수 있을 것 같아.
   - **개선이 필요한 부분**: CSS 스타일이 여러 컴포넌트에 중복 사용되고 있어. 예를 들어, `border-[1px]`와 같은 규칙을 하나의 유틸리티 클래스로 만들어서 재사용하면 코드가 더 깔끔해질 것 같아.

4. **Reliability (신뢰성)**:
   - **잘하는 부분**: `onClick` 핸들러와 같은 이벤트 리스너가 잘 적용되고 있어 대체로 정확하게 작동할 것으로 보여.
   - **개선이 필요한 부분**: 예외 처리나 오류 검출 부분이 눈에 띄지 않아. 사용자 입력에 대한 검증이나 오류 발생 시 사용자에게 피드백을 줄 수 있는 부분을 추가하면 좋겠어. 예를 들어, 코드 추가 시 필수 입력 항목 체크 같은 것이 필요할 것 같아.

5. **Security (보안성)**:
   - **잘하는 부분**: 코드에서 민감한 데이터 처리에 대한 명확한 부분은 잘 보이지 않지만, 적절한 URL/이벤트 핸들링이 이루어지고 있어 보안성을 어느 정도 고려하고 있는 것 같아.
   - **개선이 필요한 부분**: 입력 검증이 명확하지 않으니, 사용자 입력을 처리할 때 필요한 검증 로직을 추가하여 보안성을 높이자. XSS 및 SQL 인젝션 방어를 위한 코드를 생각해보면 좋을 것 같아.

6. **Maintainability (유지보수성)**:
   - **잘하는 부분**: 컴포넌트 기반으로 잘 나누어져 있어, 향후 변경 시 하나의 파일에서만 수정을 하면 되니 유지보수가 쉽겠어.
   - **개선이 필요한 부분**: 여러 스타일 속성이 중복되어 나타나니, 이를라고 CSS 모듈이나 styled-components와 같이 스타일을 모듈화하면 변경 시 유지보수성을 더욱 높일 수 있을 거야.

**전체적인 피드백**:
코드는 전반적으로 가독성이 높은 편이고, 컴포넌트 구조가 잘 나누어져 있어 유지보수성도 어느 정도 확보되어 있어. 하지만 주석 부족, 중복된 스타일, 예외 처리의 결여 등은 개선할 부분이니, 이를 염두에 두고 다음 작업을 진행하면 더욱 멋진 코드가 될 것 같아!

따뜻한 마음으로 염두에 두고 코드를 개선해 보길 바라냥~! 🐾');
INSERT INTO public.review VALUES ('2024-11-14 10:01:19.499294', 144, '2024-11-14 10:01:19.499294', 27, '안녕하세요! 코드 리뷰를 맡게 된 소프트웨어 엔지니어 냥~! 코드 변경사항에 대해 꼼꼼히 보고 피드백을 드릴게요, 냥~!

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명과 함수명이 의미가 명확해 이해하기 쉬워요, 냥! 예를 들어, `active`, `icon`, `children` 등의 속성 이름이 각자의 역할을 잘 나타내고 있어요.
- **개선이 필요한 부분**: 전체적으로 주석이 부족한 것 같아요, 냥. 특히 복잡한 로직이나 중요 부분에 주석을 추가하면 코드 이해에 큰 도움이 될 거예요, 냥~.

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 포맷이 대부분 일관되게 유지되고 있어요. 클래스 이름 및 컴포넌트 구조 모두 잘 정돈되어 있어 좋네요, 냥.
- **개선이 필요한 부분**: 클래스 이름에서 사용되는 속성 값의 스타일링이 다양해 보이네요. 예를 들어, `border-2`를 `border-[1px]`로 바꾸는 등의 변화가 있는데, 이 부분의 일관성을 다시 점검해보면 좋겠어요, 냥~!

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: 컴포넌트 구조가 잘 분리되어 있어 재사용이 가능할 것 같아요. 특히 `ReviewComment`와 같은 컴포넌트는 여러 곳에서 사용할 수 있는 구조로 되어 있어요, 냥!
- **개선이 필요한 부분**: 일부 중복 코드가 보이네요. 예를 들어, 다양한 스타일 속성이 각각의 컴포넌트에서 비슷하게 반복되고 있는데, 이를 통한 공통 컴포넌트 또는 커스텀 훅으로 재구성하면 더 유용할 것 같아요, 냥~.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 잘 작동하는 코드로 추측되지만, 예외 처리나 오류 검출이 부족한 것 같아요. 코드에서 예상치 못한 입력이나 상태에 대해 어떻게 대처할지 고려해야 하겠어요, 냥!
- **개선이 필요한 부분**: 유효성 검사나 예외 처리가 필요할 것 같아요. 예를 들어, `handleFileNameChange` 함수에서의 입력 검증 로직이 필요해 보여요. 이러한 추가적인 검증이 있다면 코드의 신뢰성이 높아질 거예요, 냥~.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 현재 코드는 크게 보안상 문제가 없어 보이지만, 민감한 데이터 처리에 대한 방어 코드가 부족해 보여요.
- **개선이 필요한 부분**: 모든 사용자 입력에 대한 유효성 검사를 진행하고, 허용되지 않은 입력을 필터링해야 해요. 또한, 외부 API 호출 시에도 신뢰할 수 있는 데이터만 처리되도록 해야 할 것 같아요, 냥~.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 모듈화가 잘 이루어져 있어서 다양한 기능에 대해 쉽게 작업할 수 있을 것 같아요, 냥~! 
- **개선이 필요한 부분**: 컴포넌트 간의 의존성이 다소 높아 보이는데, 이 부분을 좀 더 분리하거나 추상화하여 유지보수를 쉽게 할 수 있도록 하는 것이 좋겠어요. 단일 책임 원칙을 준수하면 더욱 향상될 거예요, 냥~.

### **전체적인 피드백**
전반적으로 코드가 잘 구조화되어 있고 가독성이 좋네요, 냥! 하지만 중복 코드와 주석 부족, 예외 처리의 미흡함은 개선이 필요할 것 같아요. 업데이트 후 제가 제안드린 사항들을 적용해보면 코드를 더욱 견고하고 유지보수하기 쉬운 구조로 만들 수 있을 거예요, 냥~! 

코드 리뷰에 도움이 되었길 바라며, 열심히 작업한 부분에 대해 축하드려요! 더 나은 코드가 되길 응원할게요, 냥~!');
INSERT INTO public.review VALUES ('2024-11-14 10:30:17.588656', 145, '2024-11-14 10:30:17.588656', 27, '냥! 코드 리뷰를 시작할게요. 이번 변경사항에 대해 6가지 평가 항목을 기준으로 꼼꼼히 살펴볼게요. 냥!

1. **readability (가독성)**:
   - 상태에 따라 CSS 클래스 이름을 수정한 부분(예: `border-2`에서 `border-[1px]`로 변경)은 코드의 가독성을 높여줘 냥. 그러나 CSS 클래스 이름을 정하는 기준이 다소 주관적일 수 있으니, 사용되는 색상이나 스타일을 아는 것이 중요해 냥. 주석이 없다 보니 이해하기 어려운 부분이 있을 수 있어, CSS 변경이 중요한 이유를 주석으로 남겨두면 더 좋을 것 같아 냥!

2. **consistency (일관성)**:
   - 변경된 코드에서 `border`의 두께를 변경하는 문법이 일관되게 사용되는 점은 좋지만, 기존의 `border-2`와 같은 방식이 남아 있는 것을 보면 일관성이 떨어질 수 있어 냥. 전체 코드베이스에서 `border-[n]` 형식으로 통일하면 더욱 좋겠어 냥. 또한, 클래스 이름에서 자주 사용되는 값인 경우, 별도의 클래스를 정의하여 재사용성을 높일 수 있을 것 같아 냥.

3. **reusability (재사용성)**:
   - NavButton 컴포넌트 같은 경우는 재사용 가능성이 높아 보여서 매우 좋았어 냥! 하지만 `CommonReference`나 `ReviewComment`가 각각 많이 중복되고 있는 것 같아 냥. 중복된 코드가 많아지면 변경 시 유지보수가 복잡해질 수 있으니, 공통된 부분들을 별도의 컴포넌트로 빼내면 좋을 것 같아 냥.

4. **reliability (신뢰성)**:
   - 변경된 코드에서 컴포넌트의 작동이나 상태 변화가 잘 구현된 것 같아 냥. 그러나 예외 처리 부분이 보이지 않아 냥. 사용자가 입력하는 값이나 상태 변화가 있을 때, 이를 처리하는 로직은 꼭 필요하니 적절한 예외 처리를 추가해 주면 좋겠어 냥!

5. **security (보안성)**:
   - 현재 부분에서는 보안 관련 코드가 보이지 않아 냥. 특히, 사용자 입력을 다루는 부분이 보인다 보니, 이를 검증하는 로직이 필요해 냥. XSS 공격이나 SQL 인젝션 공격을 피하기 위한 입력 검증이 필요하니 확인해 주시면 좋겠어 냥.

6. **maintainability (유지보수성)**:
   - 코드는 다소 잘 구조화되어 있어 유지보수성이 괜찮은 것 같아 냥. 하지만 모듈화가 더욱 중요하니 리팩토링을 통해 기능 단위를 더 분리해 주면 좋을 것 같아 냥. 각 컴포넌트가 `props`를 통해 필요한 상태만을 받아오도록 구성하면 변경 시 더 유연하게 대응할 수 있을 거야 냥.

**전체적인 피드백**:
- 잘 수행하고 있는 부분: CSS 클래스 변경으로 UI 가독성이 많이 개선되었고, 재사용 가능한 컴포넌트를 잘 정의하였던 것은 긍정적이야 냥!
- 개선이 필요한 부분: 안정성과 보안성을 높이기 위한 예외 처리 및 입력 검증이 필요해 보이고, 일관성과 유지보수성을 위해 중복 코드를 줄이고 모듈화를 진행할 필요가 있어 냥!

이렇게 전체적으로 살펴봤어 냥. 몇 가지 피드백을 꼭 기억해주고, 더 좋은 코드로 만들어주길 바랄게! 고양이처럼 유연하게 개선해 나가면 더욱 멋진 팀원이 될 수 있을 거야, 냥!');
INSERT INTO public.review VALUES ('2024-11-14 13:19:28.585147', 146, '2024-11-14 13:19:28.585147', 31, '냥~ 안녕하세요! 코드 리뷰 요청을 해주셔서 감사해요, 냥! 아래에서 각 항목에 대해 평가하고, 코드의 특징, 잘한 점과 개선할 점을 알려줄게요, 냥.

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명과 메소드명이 명확해서 코드가 어떤 역할을 하는지 쉽게 이해할 수 있어요, 냥. 특히 `getGitlabMrDetailUrl` 메소드는 어떤 URL을 생성하는지 한눈에 알 수 있어서 좋았어, 냥.
- **개선이 필요한 부분**: 복잡한 로직이나 처리 과정에 대해 주석이 부족할 수 있어요. 예를 들어, `handleReviewResponse` 메소드에서는 예외 처리 부분에 대한 설명이 있으면 좋겠어요. 주석을 추가하면 나중에 코드를 읽는 사람도 이해하기 쉬울 거예요, 냥!

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 모든 클래스와 메소드 이름이 Camel Case 규칙을 잘 따르고 있어서 일관성이 느껴져요, 냥. 또한, 전체적으로 인덴트와 공백 사용이 통일되고 있네요!
- **개선이 필요한 부분**: 어느 부분에서 일부 변수명이 약간 다르게 되어있거나 단어의 스펠링이 일관되지 않을 수 있어요. 예를 들어 `reviewResponse`와 같은 변수명은 일관성을 위해 camelCase를 유지하면서 전반적으로 같은 형식을 사용하는 것이 중요해요, 냥.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: `getGitlabMrDetailUrl` 메소드는 GitLab Merge Request URL을 생성하는 독립적인 기능으로 잘 분리되어 있어 다른 곳에서도 유용하게 재사용될 수 있을 것 같아요, 냥.
- **개선이 필요한 부분**: `ReviewDetailResponse`에서 `from` 메소드를 수정한 부분이 있는데, 만약 `Review` 객체에 따른 다양한 형태의 변환이 필요하다면, 더 많은 메소드를 추가하여 기능을 분리하는 것이 좋겠어요. 각 상황에 맞게 다른 재사용 가능한 메소드를 제공하는 것이 좋겠어요, 냥.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 예외 처리 부분에 대해 기본적으로 잘 작성했어요, 냥. 특히 `handleReviewResponse`에서 JsonProcessingException을 처리하는 건 좋았어요.
- **개선이 필요한 부분**: 더 많은 예외 처리와 유효성 검사를 추가할 수 있을 거 같아요. 예를 들어, `getReviewList` 메소드에서 `mrInfo`를 조회하는 부분에서 null 체크를 한다면, 해당 객체가 null일 경우에 대한 예외 처리를 강화하면 더 안전해질 거예요, 냥.

### 5. **Security (보안성)**
- **잘 수행된 부분**: `token`을 이용한 API 호출은 일반적으로 인증을 위해 잘 관리되고 있어요, 냥.
- **개선이 필요한 부분**: 입력값 검증을 수행하지 않으면 보안 위험이 커질 수 있어요. 예를 들어, 외부에서 들어오는 파라미터에 대한 유효성 검사를 추가하면 좋을 것 같아요. SQL 인젝션이나 비정상적인 데이터 입력을 방지할 수 있어요, 냥!

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 클래스와 메소드의 책임이 잘 나누어져 있어서 유지보수가 용이해보여요, 냥. 각 함수가 하나의 명확한 작업만 수행하는 것이 좋았어요.
- **개선이 필요한 부분**: 전체적으로 서비스 클래스 안에 여러 메소드가 많은데, 기능별로 클래스를 나누고 관계를 명확히 하면 좀 더 직관적으로 이해하고 관리할 수 있을 거예요, 냥.

### **전체적인 피드백**
이 코드는 전반적으로 명확하고 잘 구성되어 있어요, 냥! 특히 URL 생성 및 리뷰 응답 처리 부분은 잘 작성되었어요. 개선이 필요한 부분은 예외 처리와 입력 검증, 주석 보강 등이며, 이러한 사항들을 다룬다면 더욱 완벽한 코드가 될 것 같아요, 냥! 코드 작성 정말 수고 많았어요, 앞으로도 잘 부탁드려요, 냥~!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 13:29:38.686966', 147, '2024-11-14 13:29:38.686966', 32, '안녕하세요, 냥! 코드 리뷰를 시작할게요, 냥! 이번 변경사항을 기반으로 6가지 평가 항목에 대해 세밀하게 살펴볼게요. 냥~

### 1. Readability (가독성)
- **잘 수행한 부분**: 코드에서는 메소드와 클래스의 이름이 직관적이어서, 어떤 기능을 수행하는지 쉽게 이해할 수 있어요, 냥! 특히 `subscribe()`, `disconnect()`, `notify()` 같은 명칭은 해당 기능을 즉시 알 수 있도록 해주고 있어요.
- **개선이 필요한 부분**: 일부 메소드에 주석이 부족해요. 예를 들어, `sendToClient` 메소드와 `disconnect` 메소드에 그 기능을 간단히 설명하는 주석을 추가하면 이해하는 데 더 큰 도움이 될 거에요, 냥!

### 2. Consistency (일관성)
- **잘 수행한 부분**: 코드 포맷과 스타일이 일관되게 유지되고 있어요. 예를 들어, 모든 메소드의 접근 제어자가 일관되게 사용되고 있어요.
- **개선이 필요한 부분**: 일부 로그 메시지에서 사용되는 객체 이름이 서로 다르게 사용되고 있어요. `reviewId` 대신 `userId`로 변경된 점은 좋지만, 로그 메시지에서도 일관되게 변경해주면 더 좋을 것 같아요, 냥!

### 3. Reusability (재사용성)
- **잘 수행한 부분**: 메소드들이 명확한 기능 단위로 잘 분리되어 있어 재사용이 용이해요. `subscribe`, `notify`, `disconnect` 메소드 각각이 독립적인 기능을 가지고 있어, 필요한 경우 다른 곳에서도 사용하기 쉬울 거예요.
- **개선이 필요한 부분**: `sendToClient` 메소드는 다소 특수한 용도로 보이므로, 해당 기능이 필요한 다른 서비스에서도 사용될 수 있도록 `interface`로 추출하는 것을 고려해 볼 수 있어요, 냥!

### 4. Reliability (신뢰성)
- **잘 수행한 부분**: 예외처리가 적절하게 구현되어 있어 전반적으로 안전하게 작동할 수 있는 구조를 가지고 있어요. JSON 변환 에러 및 연결 오류를 적절히 처리하고 있어요.
- **개선이 필요한 부분**: `sendToClient` 메소드에서 `emitter.send` 호출 후 예외가 발생할 경우, 로그와 함께 좀 더 구체적인 예외 타입으로 처리하는 것이 좋을 것 같아요, 냥! 왜냐하면 이렇게 하면 문제 발생 시 원인을 쉽게 추적할 수 있어요.

### 5. Security (보안성)
- **잘 수행한 부분**: 사용자 인증을 위한 `@AuthUser` 어노테이션을 잘 사용하고 있어, 보안적인 부분에서 우수한 점수를 줄 수 있어요.
- **개선이 필요한 부분**: 입력 값 검증이 없는 것이 아쉬워요. API 요청 시 입력 값에 대한 validation을 추가하면 신뢰성을 높일 수 있을 거예요, 냥!

### 6. Maintainability (유지보수성)
- **잘 수행한 부분**: 모듈화가 잘 되어 있어 변경에 쉽게 대응할 수 있도록 구성되어 있어요. 각 기능이 별도의 메소드로 나뉘어 있어서 유지보수가 용이합니다.
- **개선이 필요한 부분**: 로직의 흐름이 복잡해지면 의존성이 증가할 수 있어요. 주석을 통해 메소드 간의 관계 및 흐름을 명확히 해주는 것이 좋을 것 같아요, 냥!

### 전체적인 피드백
코드 전반적으로 처리 로직이 잘 구성되어 있어요, 냥! 특히 페이로드를 처리하는 방식과 예외 처리 전략은 잘 짜여져 있네요. 하지만 로그 메시지에서 일관성, 입력 값 검증 방식, 그리고 주석 추가 등은 개선하면 좋을 요소들이에요, 냥!

이번 리뷰에서 긍정적인 부분을 잘 유지하면서, 제안 사항들을 참고하여 더 나은 코드를 만들어 주길 바라요, 냥! 계속해서 좋은 작업 해주세요, 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 14:04:25.141665', 148, '2024-11-14 14:04:25.141665', 33, '안녕하세요, 귀여운 고양이처럼 리뷰를 하게 되어 정말 기똥차요! 이제부터 코드 리뷰를 시작해 볼게요, 냥!

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명과 함수명이 의미가 명확해요. 예를 들어 `setAlarms`, `handleAlarmClick` 같은 이름은 함수의 역할을 잘 설명하고 있습니다. 또한 `AlarmButton`이라는 컴포넌트 구조도 이해하기 쉽게 잘 설계된 것 같아요, 냥!
  
- **개선이 필요한 부분**: 일부분에서 주석이 조금 더 있었으면 좋겠어요. 예를 들어, mockData를 설정하는 부분에 "이 데이터는 예시용입니다"와 같은 주석을 추가하면 좋겠어요. 그럼 나중에 코드를 읽는 다른 개발자들이 더 빠르게 이해할 수 있을 거예요, 냥!

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 스타일과 접근 방식이 일관되게 유지되고 있어요. 상태 관리를 위해 `useState`와 `useEffect` 후킹을 일관되게 사용하고 있습니다.
  
- **개선이 필요한 부분**: 클래스명 및 텍스트 색상을 처리할 때, `${bgColor}`와 같은 동적 클래스를 사용하는 방법이 일관되기 때문에 좋지만, 더 나아가 클래스명을 쉽게 이해할 수 있도록 조금 더 명확한 변수명을 고려하는 것도 좋을 것 같아요, 냥!

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: 훌륭한 모듈화를 보여주고 있어요! `Toast` 컴포넌트와 `BellIcon`은 다른 컴포넌트에서도 재사용 가능할 것 같네요.
  
- **개선이 필요한 부분**: `handleNewAlarm`과 같은 함수는 외부에서도 호출할 수 있도록 공개 함수로 만들어 재사용성을 높일 수 있을 것 같아요. 알람을 받아오는 API나 데이터를 주입받는 방식으로 확장해보면 좋을 것 같아요, 냥!

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: 기본적인 데이터세팅과 이벤트 핸들링 구현이 잘 되어 있어요. 특히 ''click outside to close'' 로직은 좋은 접근인 것 같아요, 냥!
  
- **개선이 필요한 부분**: 예외 처리 관점에서 어떤 API를 호출할 때는 항상 에러 핸들링이 중요해요. 현재 알람 목록을 불러오는 부분에서 API 호출에 대한 에러 핸들러가 추가되면 더 안정적인 코드가 될 거예요, 냥!

### 5. **Security (보안성)**
- **잘 수행된 부분**: 현재 코드는 입력 검증을 통해 사용자가 클릭해서 발생할 수 있는 오류를 어느 정도 방어하고 있어요.
  
- **개선이 필요한 부분**: 만약 실시간 API 통신을 추가할 경우, 보안성을 더욱 높이기 위해 서버와의 통신에서 민감한 정보는 암호화하는 방법을 고려하면 좋겠어요. 이 부분에서 CORS나 XSS 등에 대한 보호 방안을 추가하는 것도 좋은 생각이에요, 냥!

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 상태 관리를 위한 `useState`와 메소드들이 명확하게 나누어져 있어 유지보수하기 쉬운 구조를 하고 있어요.
  
- **개선이 필요한 부분**: 각 기능을 별도의 커스텀 훅으로 분리하면 사용자가 유지보수와 변경을 더 용이하게 할 수 있을 것 같아요. 예를 들어, 알람 로직을 `useAlarm` 훅으로 나누면 좋겠어요, 냥!

### **전체적인 피드백**
코드 전체적으로 **구조가 잘 되어 있고, 가독성이 높으며, 재사용 가능성과 유지보수성 측면에서 긍정적인 부분이 많아요**, 냥! 

하지만, 에러 처리가 필요하고 일관성을 조금 더 키우며, 주석을 추가하여 다른 개발자들도 쉽게 이해할 수 있도록 개선할 필요가 있어요. 이러한 개선을 통해 더 뛰어난 코드를 만들 수 있을 거예요, 냥! 

위의 피드백을 참고하여 더욱 멋진 코드로 발전해 나가길 바래요. 수고했어요~ 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 14:20:50.026791', 149, '2024-11-14 14:20:50.026791', 34, '안녕하세요냥! 코드 리뷰를 해드릴게요냥. 변경 사항을 기준으로 각 항목을 평가해볼게요냥.

### 1. **Readability (가독성)**
- **잘 수행된 부분:** 전체 코드가 구조적으로 나누어져 있고, `record` 타입을 사용하여 명확히 속성들을 정의한 점이 좋았어요냥. 
- **개선이 필요한 부분:** 새로 추가된 `userId` 속성의 Main Class에서 직접 사용할 위치에 대한 주석이 없다면, 이 부분이 어떤 역할을 하는지 직관적으로 이해하기 어려울 수 있어요냥. 각 속성에 대한 설명을 주석으로 추가하면 더 명확해질 것 같아요냥.

### 2. **Consistency (일관성)**
- **잘 수행된 부분:** 메소드 및 클래스 이름들이 파스칼 케이스를 일관되게 유지하고 있어 좋았어요냥. 
- **개선이 필요한 부분:** DTO 파일에서의 속성 순서가 다른 DTO와일관되지 않는 것 같아요. 예를 들어, `gitlabUrl`, `mrInfoId`, `userId` 등의 속성이 순서대로 나타나지 않으니, 기존 DTO와 같은 순서로 맞춰주면 통일감이 생길 거예요냥.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분:** DTO 클래스들이 각기 다른 상황에 맞춰 작성된 점이 인상적이에요냥. 추가한 `userId`는 여러 요청에서 활용될 가능성이 높아요.
- **개선이 필요한 부분:** 만약 `userId` 속성이 여러 서비스에서 계속 필요하다면, 이 속성을 포함한 Base DTO 클래스를 만드는 것도 좋은 선택일 수 있어요냥. 

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분:** 정적 타입인 `Long`을 사용하여 Nullable 값을 피해가는 점이 좋았어요냥.
- **개선이 필요한 부분:** `userId`에 대한 기본값이 `0L`로 지정된 것인데, 이는 나중에 입력 검증을 통과하지 못할 다양한 상황을 야기할 수 있어요. `null` 체크를 해주는 것이 오류를 예방할 수 있는 좋은 방법일 거예요냥.

### 5. **Security (보안성)**
- **잘 수행된 부분:** 코드에서 입력값에 대한 검증을 이뤄내고 있는 것 같아요. 특히 사용자 입력을 다룰 때는 철저한 처리가 중요해요!
- **개선이 필요한 부분:** 이를테면, `userId`를 외부에서 받아오는 경우 SQL 인젝션이나 기타 공격에 대비해 철저히 검증해야 해요. 입력 처리 로직을 강화해 주면 더 안전해질 거예요냥.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분:** 클래스를 잘 모듈화해두어 나중에 변경사항이 생겨도 수월하게 관리할 수 있을 것 같아요.
- **개선이 필요한 부분:** `ReviewCreateService`에서 `userId`가 무작정 사용하는 대신, 사용자 데이터를 다룰 때의 컨텍스트를 개선하는 방안을 고려해보세요. 나중에 다른 부분에서 이 정보를 활용하게 된다면 값이 어떻게 사용되는지를 명확해질 수 있도록 주석이나 문서를 남기는 게 좋아요냥.

### **전체적인 피드백**
코드 전반적으로 잘 구성되어 있으며, 적절한 데이터 구조와 타입 사용이 인상적이에요냥. 특히 DTO의 사용은 굉장히 유용했어요.

그러나 추가된 `userId`에 대해 예외 처리가 부족할 위험성이 잠재되어 있으니, 검증 로직을 강화하는 것이 좋을 것 같아요. 주석을 통해 코드의 의도를 명확히 함으로써 가독성을 높이는 것도 잊지 마세요냥!

전반적으로 좋은 작업이니, 수정 사항을 반영하면 더욱 강력한 코드로 발전할 수 있을 거예요냥. 고양이처럼 차분하게 리뷰할 수 있어 기뻤어요! 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 14:26:37.496368', 150, '2024-11-14 14:26:37.496368', 35, '안녕하세요, 냥~ 코드 변경 사항에 대해 리뷰해 드릴게요, 냥! 각 항목에 따라 피드백을 드릴게요, 냥~

### 1. Readability (가독성)
- **잘 수행된 부분**: 코드의 전반적인 구조는 잘 나눠져 있어서 이해하기 쉬워요, 냥! 메소드 이름들이 그 기능을 잘 설명하고 있지만, `handleReviewResponse`처럼 변수명 및 인자명이 기능을 명확히 설명하고 있어요, 냥.
- **개선할 부분**: `regenerateReview`, `getReviewList` 같은 메소드의 주석이 부족해서 어떤 행동을 하는지에 대한 설명이 필요해요, 냥. 주석을 추가해 주면 가독성이 크게 향상될 것 같아요, 냥~ 

### 2. Consistency (일관성)
- **잘 수행된 부분**: 코드 스타일이 일관되게 유지되고 있고, Java의 네이밍 규칙을 잘 따르고 있어요, 냥! 메소드와 변수의 네이밍 규칙이 일관적이어서 나중에 다른 개발자가 보기에도 좋을 것 같아요, 냥.
- **개선할 부분**: 코드의 들여쓰기와 포맷은 대부분 일관성이 있지만, 일부 코드 블록에서 공백 사용에 일관성이 다소 부족해요, 냥. 예를 들어, if 문 안에서의 공백 사용을 통일하면 더 좋을 것 같습니다, 냥.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: 각 메소드가 독립적인 기능을 잘 수행하도록 설계되었어요, 냥. 예를 들어, `getMrDiffs` 메소드는 변경 요청을 가져오는 기능을 명확하게 수행하고 있어요, 냥.
- **개선할 부분**: 변경된 DTO 및 수신 메시지가 다른 곳에서도 재사용될 가능성이 있기 때문에, 이러한 DTO와 메시지들을 더 일반화된 형태로 추상화하거나, 공통으로 사용할 수 있는 기반 클래스를 만드는 것도 좋을 것 같아요, 냥~ 

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 예외 처리는 굉장히 잘 되어 있어요, 냥! JSON 처리에 실패하면 RuntimeException을 던지는 부분이 명확하고 좋은 방법이에요, 냥.
- **개선할 부분**: 그러나, 부적절한 `RuntimeException` 사용은 장기적으로 문제가 될 수 있어요, 냥. 더 구체적인 예외 처리를 통해 무엇이 잘못되었는지를 알 수 있도록 하면 좋을 것 같아요, 냥.

### 5. Security (보안성)
- **잘 수행된 부분**: GitLab API와의 상호작용할 때 처리되는 사용자 토큰을 안전하게 다루고 있어요, 냥.
- **개선할 부분**: 그러나 입력값 검증 등의 방어적인 프로그래밍 기법이 부족해 보이니, 사용자 입력을 검증하여 보안을 강화하는 것이 중요해요, 냥. 특히, 외부 시스템과의 통신 시 보안에 유의해야 해요, 냥.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 전체적으로 클래스를 잘 나누어져 있어 유지보수가 용이해 보여요,냥! 클래스 및 메소드 간의 책임이 명확하게 구분되어 있어서 좋네요, 냥.
- **개선할 부분**: 일부 메소드에서 너무 많은 책임을 지는 경우가 있어요. 예를 들어, `makeCodeReviewWhenCalledByWebhook`의 경우 다양한 작업을 한 번에 처리하는 느낌이 들어요, 냥! 간단히 나눌 수 있는 부분은 메소드로 분리하면 더 유지보수가 쉬울 것 같아요, 냥.

### 전체적인 피드백
이번 변경 사항에서 전반적으로 가독성과 구조가 뛰어나고, 명명 규칙을 잘 따르고 있어서 칭찬할 만해요, 냥~ 하지만 몇 가지 주석 추가와 예외 처리 방식을 개선하면 더욱 품질 높은 코드가 될 것 같아요, 냥. 아울러 코드가 다른 개발자에게도 이해하기 쉽고 더 안전하게 유지될 수 있도록 방어적인 코드 작성이 필요해 보입니다, 냥! 앞으로도 좋은 코드 기대해요, 냥~ 💖
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 14:35:32.944755', 151, '2024-11-14 14:35:32.944755', 35, '냥~ 코드 리뷰를 시작할게요! 이번 변경사항에 대해 냥냥하게 피드백을 남겨볼게요. 

### 1. Readability (가독성)
코드가 전반적으로 직관적이어서 이해하기 쉬운 편이야. 특히 `ReviewRegenerateRequestMessage`와 `ReviewResponseMessage`의 필드 정의가 명확해서 좋았어. 하지만 `sseService.notify(reviewResponse.userId(), "review created");`와 같은 코드에는 주석이 더 필요해 보여. 이렇게 중요하고 함수 호출이 명확하지 않은 경우에는 "리뷰가 생성되었을 때 사용자에게 알림을 보냅니다." 같은 주석을 추가하면 더 좋을 것 같아, 냥!

### 2. Consistency (일관성)
코드의 스타일이 전반적으로 일관성을 잘 유지하고 있어. 변수명과 함수명이 명확하게 의미를 전달하고, camel case를 잘 사용하고 있어 냥. 그렇지만 `notify` 함수와 `sendData` 함수 같은 비동기 처리 관련 메소드의 네이밍을 조금 통일감 있게 조정할 필요가 있어 보이네. 예를 들어, `notifyUser` 같은 형태로 일관되게 하는 게 좋겠어.

### 3. Reusability (재사용성)
기능 단위로 잘 나누어져 있어서 재사용성이 좋다고 느꼈어! 예를 들어 `saveRetrievals` 같은 메소드는 다른 부분에서도 활용될 가능성이 높아 보여. 그러나 `makeCodeReviewWhenCalledByWebhook`의 경우, 코드를 나누어서 각각의 책임에 맞게 메소드를 분리하면 좀 더 클린하게 재사용할 수 있을 것 같아. 예를 들어 MR 정보를 추출하고, Diffs를 fetching하는 과정은 각각 별도의 메소드로 뺄 수 있을 거 같아, 냥!

### 4. Reliability (신뢰성)
예외 처리 부분에서 `JsonProcessingException`에 대한 처리도 잘 되어있어서 좋아! 하지만 `gitLabClient.addNoteToMr`와 같은 외부 API 호출 부분에서는 오류가 발생할 가능성이 있으니, 이에 대한 예외 처리를 추가하는 것이 좋겠어. 예를 들어, 통신 오류나 API의 응답이 실패했을 경우 이를 적절히 처리하는 로직을 추가하면 신뢰성이 향상될 것 같아, 냥~!

### 5. Security (보안성)
보안적으로는 사용자의 민감한 데이터가 잘 보호되고 있는 것 같아. `token`을 직접 사용하지 않고, 교환된 `gitlabAccount.getUserToken()`을 사용하는 점은 좋았어. 냥. 그러나, `userId`를 로그에 남기는 부분은 주의가 필요해! 사용자의 정보가 포함된 로그는 외부에 노출되면 안 되기 때문에, 식별자를 마스킹 처리하거나 로그 레벨을 조정하는 게 좋겠어, 냥~!

### 6. Maintainability (유지보수성)
모듈화가 잘 되어 있어 유지보수가 쉬워 보이네. 그러나 코드가 점점 커지다보니, 각 메소드가 수행하는 일이 명확해야 해. 각 메소드에 대해 간단한 문서화가 되어 있으면 좋겠어! 이렇게 되면 나중에 다른 팀원이 참여했을 때, 역할과 책임이 확실하게 이해될 수 있을 거야, 냥!

### 전체적인 피드백
전반적으로 잘 작성된 부분이 많았고, 기능적으로 명확하게 작동하는 코드야. 특히 DTO와 메시지 처리 부분이 깔끔하고 잘 구조화되어 있어서 좋았어, 냥. 하지만 일부 예외 처리와 주석 추가, 명명을 통한 일관성, 그리고 메소드 분리와 같은 부분은 개선이 필요할 것 같아. 

고양이처럼 여유를 가지고 조금씩 개선해 나가면 좋을 것 같아, 냥! 전체적으로 잘하고 있으니, 이 피드백을 통해 더 발전할 수 있기를 바랄게~! 🐾');
INSERT INTO public.review VALUES ('2024-11-14 14:36:22.472589', 152, '2024-11-14 14:36:22.472589', 35, '안녕하세요, 냥! 코드 리뷰를 진행해 보겠어요, 냥! 

### 1. **readability (가독성)**
- **잘 수행된 부분**:
  - 변수명과 함수명이 직관적으로 잘 지어져 있어서 기능의 이해가 쉬워요, 냥. 예를 들어, `regenerateReview`나 `getReviewList`같은 함수명은 기능을 명확히 드러내고 있답니다.
- **개선이 필요한 부분**:
  - 일부 함수에 대한 주석이 부족해 보이네요, 냥. 특히 복잡한 로직이나 외부 API 호출이 있는 부분에 주석을 추가해주면 다른 개발자들이 이해하기 더 쉬울 거예요, 냥.
  
### 2. **consistency (일관성)**
- **잘 수행된 부분**:
  - 전체적으로 코드 스타일이 일관되게 유지되고 있는 것 같아요, 냥. 예를 들어, 코드 블록의 들여쓰기는 모두 잘 정돈되어 있답니다.
- **개선이 필요한 부분**:
  - 네이밍 규칙에서 약간의 차이가 보여요, 냥. 예를 들어, `GitlabMrDiffsContent` 같은 이름은 CamelCase를 준수하고 있지만, `sseService` 등의 서비스 이름은 소문자로 시작해 inconsistency가 발생해요. 전체적으로 CamelCase 규칙을 따르는 게 좋겠어요, 냥.

### 3. **reusability (재사용성)**
- **잘 수행된 부분**:
  - 코드가 독립적인 기능 단위로 잘 분리되어 있어 다른 곳에서 재사용 가능한 구조를 가지고 있어요, 냥.
- **개선이 필요한 부분**:
  - 만약 비슷한 로직이 반복적으로 사용된다면, 이를 함수로 분리하여 재사용성을 높이는 것도 좋을 것 같아요, 냥. `getSingleMergeRequest` 호출 후의 로직처럼요.

### 4. **reliability (신뢰성)**
- **잘 수행된 부분**:
  - 예외 처리 부분에서 `JsonProcessingException`을 적절히 처리하는 모습이 인상적이에요, 냥. 이는 신뢰성을 높여주는 요소에요.
- **개선이 필요한 부분**:
  - API 호출 시 예외 상황에 대한 대응이 없다면, 예기치 않은 에러 상황이 발생할 수 있으니, API 통신할 때도 적절한 예외 처리를 추가해주는 게 좋겠어요, 냥.

### 5. **security (보안성)**
- **잘 수행된 부분**:
  - 메서드의 매개변수로 사용자 인증 정보를 적절히 활용하고 있는 점이 좋네요, 냥. 이것은 보안상 중요한 요소에요.
- **개선이 필요한 부분**:
  - 사용자 입력에 대한 검증이 부족해 보이네요, 냥. 특히 외부 API 호출 시 전달되는 데이터는 매우 중요한 만큼, 검증과 정제 과정을 추가해야 해요.

### 6. **maintainability (유지보수성)**
- **잘 수행된 부분**:
  - 서비스와 레포지토리 간의 명확한 분리 덕분에 유지보수성 좋은 구조를 가지고 있어요, 냥.
- **개선이 필요한 부분**:
  - 여러 서비스가 하나의 메서드에서 호출되는 경우, 이를 더 작은 메서드로 나누어 단일 책임 원칙을 준수하는 것이 좋겠어요, 냥. 이는 코드의 가독성과 유지보수성을 더욱 높여줄 거예요.
  
### **전체적인 피드백**
- **잘 수행하고 있는 부분**:
  - 전반적으로 코드가 잘 구조화되어 있고, 주요 기능이 명확히 드러나는 점에서 높은 점수를 줄 수 있어요, 냥!
- **개선이 필요한 부분**:
  - 명확한 오류 처리, 입력 검증, 그리고 코드의 일관성을 위해 사용되는 변수와 함수명에 대한 검토가 필요해 보이네요, 냥. 이런 부분을 보완한다면 더욱 안전하고 견고한 코드를 만들 수 있을 거예요!

유용한 피드백이 되었길 바라며, 앞으로도 멋진 코드 많이 만들어 줘요, 냥~!');
INSERT INTO public.review VALUES ('2024-11-17 18:10:43.034955', 196, '2024-11-17 18:10:43.034955', 54, '코드 변경 사항에서 `favicon` 링크를 SVG 파일에서 ICO 파일로 변경한 것은 좋은 선택입니다. ICO 형식은 대부분의 브라우저에서 보다 폭넓게 지원되기 때문에 사용자가 웹사이트를 방문할 때 더 나은 호환성을 제공합니다.

코드의 나머지 부분에서는 특별한 문제점이 없어 보입니다. 하지만 다음과 같은 개선점을 고려해볼 수 있습니다:

1. **메타 태그 추가**: SEO 및 사이트의 사용자 경험을 개선하기 위해 Open Graph 메타 태그나 Twitter 카드 메타 태그 등을 추가하는 것을 고려해볼 수 있습니다.

    ```html
    <meta property="og:title" content="Coflo" />
    <meta property="og:description" content="Coflo - Your app description here." />
    <meta property="og:image" content="/path/to/image.jpg" />
    <meta property="og:url" content="https://yourwebsite.com" />
    ```

2. **CSS 및 JS 파일 링크**: 스타일 및 스크립트 파일을 추가한다면, `<link>` 및 `<script>` 태그를 사용하여 코드의 가독성을 높일 수 있습니다.

3. **HTML 개선**: HTML5의 시멘틱 요소를 활용하여 구조적으로 개선할 수 있습니다. 예를 들어, `<header>`, `<main>`, `<footer>` 태그를 사용하는 것입니다.

이러한 개선사항은 웹사이트의 전반적인 품질과 활용성을 높이는 데 도움을 줄 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-14 14:50:53.799629', 153, '2024-11-14 14:50:53.799629', 36, '안녕, 냥! 코드를 리뷰해줄게, 냥! 평가 항목별로 살펴보도록 할게. 

### 1. **Readability (가독성)**
코드는 전반적으로 가독성이 좋네, 냥! 하지만 변수명과 함수명이 좀 더 명확했으면 좋겠어, 냥. 예를 들어, `functionA` 대신 `calculateTotalPrice` 같은 구체적인 이름을 사용하면 읽는 사람에게 더 많은 정보를 줄 수 있어. 주석도 필요한 부분에 적절히 추가하면 좋을 것 같아. 특히 복잡한 로직에는 주석이 많은 도움이 된단다, 냥!

### 2. **Consistency (일관성)**
코드 스타일과 명명 규칙은 대체로 일관되게 유지되고 있어, 냥! 하지만 일부 변수 이름이 공백 없이 연결된 형태로 되어 있어서 가독성이 떨어졌어. 예를 들어, `totalprice` 보다는 `totalPrice` 같은 카멜 케이스가 더 좋을 것 같아. 코드 포맷도 전체적으로 통일성을 유지했으면 해, 냥!

### 3. **Reusability (재사용성)**
코드가 잘 분리되어 있어서 각각의 기능이 독립적으로 잘 작동하는 점은 칭찬해, 냥! 하지만, 공통으로 사용될 수 있는 부분은 함수로 빼서 재사용하면 더 좋을 거야. 예를 들어, 데이터 유효성을 검사하는 로직이 있다면 이를 별도의 함수로 만들면 여러 곳에서 재사용할 수 있을 거야, 냥.

### 4. **Reliability (신뢰성)**
코드가 의도한 대로 잘 작동하는 것 같지만, 예외 처리 부분이 다소 부족해 يظهر, 냥. 특정 입력에서 오류가 발생할 경우를 고려한 예외 처리가 필요해. 예를 들어, 숫자를 입력받아야 하는데 문자열이 들어오는 경우를 처리하는 로직을 추가해 보는 건 어떨까, 냥?

### 5. **Security (보안성)**
민감한 데이터 처리에 대한 부분은 좀 더 신경 써야 할 듯해, 냥. 입력값에 대한 검증이 필요하고, SQL 인젝션 공격을 방지하기 위한 방어 코드를 구현해야 해. 특히 사용자 입력을 직접적으로 사용하는 부분에서는 입력 검증을 강화하는 게 좋을 거야, 냥!

### 6. **Maintainability (유지보수성)**
코드의 구조는 전체적으로 유지보수성이 높아 보이지만, 모듈화가 더 필요해 보여, 냥. 함수가 너무 많은 일을 할 경우, 나중에 수정이 필요할 때 어려움을 겪을 수 있으니 단일 책임 원칙을 잘 적용해보면 좋겠어. 각 함수가 한 가지 일만 하는 것이야, 냥!

### **전체적인 피드백**
코드 전반적으로 많은 노력과 성취가 느껴져, 냥! 가독성과 일관성을 유지하는 부분은 정말 잘하고 있어. 하지만 입력 검증 및 예외 처리에 있어선 조금 더 주의를 기울여야 할 것 같아. 모듈화와 재사용성을 높여서 코드의 질을 한층 끌어올릴 수 있으니, 이 부분을 꼭 고려해 줘! 여기에 추가적인 주석이나 설명도 넣으면 더 긍정적인 결과를 기대할 수 있을 거야, 냥.

앞으로도 좋은 코드 작업을 계속해 주면 좋겠어! 좋은 성과가 있기를 응원할게, 냥!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 15:26:32.490079', 154, '2024-11-14 15:26:32.490079', 37, '안녕하세요! 이번 코드 리뷰에 대해 고양이 말투로 피드백을 진행할게요, 냥~! 

### 1. **Readability (가독성)**
- **잘 수행하고 있는 부분**: 전체적으로 코드가 논리적인 순서로 작성되어 있어 이해하기 쉬워요, 냥! 변수명과 함수명이 명확해서 각 기능이 무엇을 하는지 직관적으로 알 수 있어요. `getRedirectUrl` 같은 함수명은 그 기능을 잘 설명해 주네요.
- **개선이 필요한 부분**: 일부 함수에는 간단한 주석이 추가되면 더 좋을 것 같아요, 냥! 예를 들어 `OAuthRedirectHandler`의 기능을 설명하는 주석을 넣으면 좋겠어요. 또한, 유효성 검사 부분에 주석을 추가하면 다른 개발자가 빠르게 이해할 수 있을 거예요!

### 2. **Consistency (일관성)**
- **잘 수행하고 있는 부분**: 대부분의 코드가 일관된 스타일로 작성되어 있어서 보기 좋아요, 냥! 파일 구조와 폴더링도 잘 되어 있어서 다른 개발자가 쉽게 이해할 수 있어요.
- **개선이 필요한 부분**: 주석 스타일이나 공백 사용에서 몇 가지 일관성이 떨어지는 부분이 보였어요, 냥. 프로젝트 전반에 걸쳐 같은 스타일로 주석을 작성하는 것을 권장해요! 예를 들어, 어떤 주석은 영어로 되어 있고, 어떤 주석은 한국어로 되어 있다면 통일하는 것이 좋겠어요.

### 3. **Reusability (재사용성)**
- **잘 수행하고 있는 부분**: API 요청을 처리하는 부분에서 유틸리티 함수로 잘 분리되었어요, 냥! 이렇게 처리하면 다른 곳에서도 쉽게 활용할 수 있겠죠?
- **개선이 필요한 부분**: `login`과 같은 함수는 특정한 부분의 비즈니스 로직을 담고 있는데, 이를 더 일반화해서 재사용하도록 리팩토링해볼 수 있을 것 같아요, 냥!

### 4. **Reliability (신뢰성)**
- **잘 수행하고 있는 부분**: 오류 처리와 예외 케이스에 대한 대응이 잘 되어 있어요, 냥. 특히 fetch 요청 시 오류를 처리하는 부분에서 적절한 메시지가 출력되도록 했어요.
- **개선이 필요한 부분**: `getResponse` 및 `handleRequest` 함수에서 에러를 처리할 때, 에러 타입에 따른 세분화된 처리가 추가되면 더 좋을 것 같아요. 예를 들어, 네트워크 오류 외에도 다른 종류의 오류에 대해 별도의 메시지를 던질 수 있는 구조로 개선하면 좋을 것 같아요.

### 5. **Security (보안성)**
- **잘 수행하고 있는 부분**: 입력값 검증을 위해 `searchParams`에서 값을 확인하는 로직이 있어서 보안성 측면에서 좋은 접근임을 느꼈어요, 냥.
- **개선이 필요한 부분**: API 요청 시 전달되는 데이터에 대한 추가적인 검증이 있으면 좋겠어요. 예를 들어, URL 파라미터가 유효한지 확인하는 로직을 추가하는 것도 고려해보세요!

### 6. **Maintainability (유지보수성)**
- **잘 수행하고 있는 부분**: 모듈화가 잘 되어 있어서 특정 기능이나 API에 대한 변경이 다른 부분에 미치는 영향을 최소화하고 있어요, 냥! 
- **개선이 필요한 부분**: 코드의 특정 로직이 필요할 때 스스로 이해할 수 있도록 좀 더 명확한 함수 명세서나 API 문서를 작성하면 유용할 것 같아요, 냥!

### **전체적인 피드백**
- 전반적으로 코드가 깔끔하고 명확했어요! 함수의 목적이 분명해서 동료 개발자들이 이해하기 쉬울 거예요, 냥! 다만 일관성 있는 주석과 추가적인 오류 처리로 보완하면 더욱 좋을 것 같아요.
- 긍정적인 부분에 대해선 잘하고 있다는 점을 강조하고 싶고, 주석과 같은 세세한 부분에 대해서는 조금 더 신경을 쓰도록 해보면 좋겠어요!

추가적으로 컴파일 에러나 런타임 에러가 나타날 가능성이 있는 부분은 리뷰 시 확인해주시고 필요하다면 수정하도록 요청해 주세요, 냥~!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 15:33:25.597043', 155, '2024-11-14 15:33:25.597043', 38, '안녕하세요, 리뷰어 냥! 코드에 대한 코멘트를 시작할게요 냥! 각 평가 항목을 바탕으로 피드백을 제공하겠다냥. 

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 변수명과 함수명이 상대적으로 직관적이고, CSS 클래스 이름이 의미론적으로 좋다냥. 예를 들어, `bg-[#ebecf0]`, `text-secondary`와 같은 클래스명은 사용 목적을 잘 나타내고 있다냥.
- **개선이 필요한 부분**:
  - 특정 부분에서 주석이 부족한 것 같아서, 복잡한 로직이나 중요한 데이터 조작이 있는 곳에는 주석을 추가하는 것이 좋겠다냥. 예를 들어, SSE 관련 로직이나 API 호출하는 부분에 주석을 추가하면 이해하는 데 도움이 될 거다냥.
  - 세심한 데이터 처리(예: `setReferences(initialReferences || [])` 부분)에서도 주석이 있으면 좋겠다냥.

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 포맷이 일관되게 잘 유지되고 있으며, JSX와 CSS 클래스의 사용 방식도 전체적으로 일관성을 보인다냥.
- **개선이 필요한 부분**: 
  - 일부 함수와 변수가 너무 긴 것들이 있어øvern. 예를 들면 `onChange={handleChange}`와 같은 명명은 일관성을 지키되, 좀 더 구체적이면서도 간결한 이름으로 하는 것이 좋겠다냥.
  - 코드 스타일에 대해 eslint 등의 도구를 사용하여 공통의 스타일 가이드를 따르는 것이 좋겠다냥.

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: SVG 컴포넌트인 `SaveIcon`은 잘 분리되어 재사용 가능하게 만들어졌고, 이는 좋은 방향이다냥.
- **개선이 필요한 부분**:
  - 특정 공통 컴포넌트(예: `PrevPrompt`, `AlertModal`)의 재사용을 고려하여 중복된 코드가 있는지 검토하고, 이를 리팩토링하면 좋겠다냥.
  - 스타일이 자주 반복되는 부분을 CSS 모듈이나 styled-components 등으로 통합할 수 있는 방법을 모색해보면 좋겠다냥.

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: `useEffect`의 의존성 배열을 적절히 설정한 점이 좋아 보인다냥. 동기화된 데이터의 관리가 잘 되어 있는 것 같다냥.
- **개선이 필요한 부분**:
  - 예외 처리가 부족한 곳이 보인다냥. 예를 들어, API 호출 시 실패를 대비해 적절한 오류 처리를 통해 사용자에게 피드백을 줄 필요가 있다냥.
  - 세부적인 데이터 검증 로직(예: `if (!projectId)`) 후에 사용자에게 에러 메시지를 보여주는 로직을 추가하면 더 좋겠다냥.

### 5. **Security (보안성)**
- **잘 수행된 부분**: 민감한 데이터 처리 시 로컬 스토리지에서 직접 가져오는 대신 전역 상태 관리 라이브러리를 사용하는 방법은 좋다냥.
- **개선이 필요한 부분**:
  - 입력 검증이 필요하다냥. 사용자 입력값(예: `textarea`)에 대해 더 강력한 검증 절차를 통해 SQL 인젝션 같은 공격을 방지할 수 있어야 한다냥.
  - SSE 이벤트 처리에서 수신하는 이벤트 데이터를 적절히 검증하여 보안성을 높이는 것도 필요하다냥.

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 반응형 웹 디자인을 이루기 위해 TailwindCSS를 적극 활용한 점이 코드 유지보수에 좋다냥.
- **개선이 필요한 부분**:
  - 코드가 상당히 길어진 부분이 보이니, 특정 기능별로 컴포넌트를 모듈화하여 파일을 정리하면 유지보수성이 개선될 거다냥. 예를 들어, 참조 목록과 같이 반복되는 UI는 하위 컴포넌트로 빼내면 좋겠다냥.
  - 전체적으로 단일 책임 원칙(SRP)을 준수할 수 있도록 각 컴포넌트의 역할을 더 세분화하는 것도 고려해 보기를 추천한다냥.

### **전체적인 피드백**
- **잘 수행하고 있는 부분**: 코드 구조와 CSS 클래스 이름의 직관성이 매우 좋다냥. 전체적으로 가독성 있고 사용하기 편한 느낌이 든다냥. 
- **개선이 필요한 부분**: 예외 처리 및 입력 검증 강화를 통해 신뢰성과 보안성을 높이는 것이 필요하다냥. 코드의 모듈화를 통해 유지보수성을 키우는 것도 중요하다냥.

이런 점을 고려하여 개발하시면 더 좋은 코드가 될 것이라 생각한다냥! 리뷰가 도움이 되었으면 좋겠다냥~! 🐾
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 15:40:47.754101', 156, '2024-11-14 15:40:47.754101', 39, '냥~ 안녕하세요! 코드 리뷰를 맡게 된 소프트웨어 엔지니어 냥. 변경된 코드를 살펴보고 각 항목별로 피드백을 남길게요. 코드는 전반적으로 나쁘지 않지만, 몇 가지 개선해야 할 점들이 보이니 함께 살펴보자구요, 냥!

### 1. Readability (가독성)
- **잘 수행된 부분**: 변수명과 함수명은 전반적으로 의미가 명확해 코드의 의도를 이해하기 용이해요. 
- **개선이 필요한 부분**: 주석이 전반적으로 많지 않아서, 추후 다른 개발자가 코드를 이해하는 데 어려움을 겪을 수 있어요. 기능이 삭제된 부분에 주석으로 `handleNewAlarm` 함수가 삭제된 이유를 적어두면 좋을 것 같고, 각 섹션에 대한 설명을 추가하면 더욱 직관적으로 이해할 수 있을 거예요. 

### 2. Consistency (일관성)
- **잘 수행된 부분**: 코드 스타일이 일정하게 유지되고 있어 표준적인 형식으로 잘 작성되었어요. 
- **개선이 필요한 부분**: 주석 처리된 부분과 실제 코드가 섞여 있는 것 해소하면 좋겠어요. 사용하지 않는 코드 조각들은 별도의 브랜치나 파일로 옮겨서 코드의 가독성을 높일 수 있을 것 같습니다, 냥~ 

### 3. Reusability (재사용성)
- **잘 수행된 부분**: 함수가 잘 구조화되어 있어 특정 기능만 담당하는 부분들이 잘 분리되어 있어요. 
- **개선이 필요한 부분**: `handleNewAlarm` 함수가 주석 처리되어 있는데, 이 부분이 나중에 필요할 경우가 많으니, 다른 곳에서 재사용할 가능성을 고려해 독립적인 유틸리티 함수로 분리하는 것도 좋겠어요. 

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 특정 동작(예를 들어, 알림을 추가하는 것)에 대한 상태 관리가 잘 이루어지고 있어 보안성이 높아요. 
- **개선이 필요한 부분**: 예외 처리나 오류 검출 부분이 부족해 보이네요. 예를 들어, `newAlarm`이 null일 경우를 체크하는 로직이 추가된다면 더욱 안전한 코드가 될 거예요, 냥~ 

### 5. Security (보안성)
- **잘 수행된 부분**: 헤더와 클래스 구조가 명확하게 설정되어 있는데, 그 자체로는 보안적으로 양호해요. 
- **개선이 필요한 부분**: 코드에서 민감한 데이터 처리에 대한 부분이 보이지 않는데, 만약 사용자 데이터를 취급하게 된다면 입력 검증과 방어 코드를 강화해야 해요.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 기능 분리가 잘 되어있어 수정 및 유지보수가 용이할 것으로 보입니다.
- **개선이 필요한 부분**: 앞으로 코드가 늘어날 수 있으므로, 구조를 더욱 모듈화하면 나중에 변경이 필요할 때 용이할 것 같아요. 특히, 자주 변경될 부분은 별도의 컴포넌트나 파일로 분리하면 좋겠어요.

### 전체적인 피드백
전반적으로 코드의 구조와 상태 관리가 잘 되어있어 안정성이 높아요, 냥~ 하지만 주석이 부족하여 가독성을 더 높이기 위해 더욱 많은 설명을 추가하면 좋겠고, 예외 처리와 재사용성을 고려하여 코드를 조금 더 다듬으면 좋을 것 같아요. 

기존에 좋았던 부분에 대해서는 칭찬하며, 추가적으로 고려할 점도 명확히 제안해주었으니 개선해 나가면 좋은 코드가 될 것 같아요! 코드 리뷰가 도움이 되었으면 좋겠다냥! 😸
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 17:04:57.613761', 157, '2024-11-14 17:04:57.613761', 40, '안녕하세요, 냥! 코드를 살펴보니 정말 고양이처럼 깔끔하게 잘 작성된 부분들이 많아서 기뻐요, 냥! 하지만 개선할 여지가 있는 부분도 몇 군데 보이니, 체크해볼게요, 냥!

### 1. **Readability (가독성)**
- **잘한 점**: 변수명과 함수명이 명확하여 코드의 의도를 잘 파악할 수 있어요, 냥. 특히 `NotificationResponse`와 `UnreadCountResponse` 같은 클래스명이 해당 기능을 잘 설명하고 있어서 좋았어요.
- **개선 사항**: `regenerateReview`와 같은 메서드는 주석이나 설명이 좀 더 들어가면 좋겠어요. 특히 이 메서드의 목적이나 사용 시나리오를 추가하면 이해하기 쉬울 것 같아요, 냥.

### 2. **Consistency (일관성)**
- **잘한 점**: 코드 스타일이 전반적으로 일관성을 유지하고 있어요. 주석 문법, 메서드 및 클래스 배치가 잘 조화되어 있네요, 냥.
- **개선 사항**: 일부 메서드에서 `@Transactional` 어노테이션의 위치가 다르게 위치해 있어요. 이를 통일해줄 필요가 있겠어요, 냥! 예를 들어, 서비스 클래스 내에서 일관된 방식으로 메서드를 작성하면 좋을 것 같아요.

### 3. **Reusability (재사용성)**
- **잘한 점**: `NotificationService`와 같은 서비스 클래스가 독립적인 기능 단위로 잘 분리되어 있어서, 다른 곳에서 재사용하기에 충분히 적합해요, 냥.
- **개선 사항**: `formatCreatedDate` 메서드가 여러 번 호출될 경우에 대비해 헬퍼 유틸리티 클래스로 분리해보는 것도 좋을 것 같아요, 냥. 이렇게 하면 재사용성을 높일 수 있을 거예요.

### 4. **Reliability (신뢰성)**
- **잘한 점**: `BusinessException`을 통해 예외 처리를 잘하고 있어요. 특히 특정 메서드에서 예외를 명확히 던져주어 코드의 안정성을 높이고 있네요, 냥.
- **개선 사항**: `Notification`의 `updateIsRead` 메서드에서 중복된 호출을 방지하기 위해 이중 검사를 하고 있지만, 이를 좀 더 명확하게 리팩토링하면 좋겠어요. 예를 들어, 이미 읽은 알림에 대해 명확한 메시지를 로그로 남기는 것도 좋을 것 같아요, 냥.

### 5. **Security (보안성)**
- **잘한 점**: 사용자 입력을 처리하는 클래스에서 제대로 검증 로직이 구현되어 있어서 안전하게 작동할 것 같아요, 냥.
- **개선 사항**: `targetUrl`과 같은 필드에 대해 입력값 검증을 강화하는 것이 좋겠어요. 이는 사용자가 주입 공격을 통해 악의적인 URL을 입력할 가능성을 줄일 수 있어요, 냥!

### 6. **Maintainability (유지보수성)**
- **잘한 점**: 클래스 구조가 잘 모듈화되어 있어서 변동사항이 생겼을 때 수정하기 좋을 것 같아요, 냥. 
- **개선 사항**: 메서드의 길이가 길어지는部分이 있어요. 가능한 한 작은 단위로 나누어 각 메서드가 한 가지 책임만 갖도록 해보면 좋겠습니다, 냥!

### **전체적인 피드백**
코드가 전반적으로 아주 잘 작성되어 있어요, 냥! `Notification` 처리와 관련된 로직이 명확하고 사용자에게 큰 도움이 될 것 같아요. 그러나 몇 가지 개별 메서드의 가독성을 높이고, 일관성을 강화하는 개선이 필요해 보여요. 특히 각 메서드의 역할과 흐름을 명확하게 정리해주면 좋겠어요!

긍정적인 피드백을 드리니 기분이 좋으시죠? 더 나아가 코드를 리팩토링하고 다듬어가면 더욱 멋진 결과물이 나올 것 같아요, 냥! 고생 많으셨어요!
## [참고자료 보러가기](https://www.coflo.co.kr)');
INSERT INTO public.review VALUES ('2024-11-14 17:16:02.739759', 158, '2024-11-14 17:16:02.739759', 40, '코드 리뷰를 진행하겠습니다. 리뷰는 주어진 코드 변경 사항에 대해 정확성, 가독성, 효율성, 확장성, 보안성, 그리고 유지보수성의 6가지 항목에 중점을 두어 피드백을 제공합니다.

### 1. Readability (가독성)
- **잘 수행된 부분**: DTO 클래스와 서비스 메서드에서 명확하게 함수와 변수명이 지어졌습니다. 예를 들어, `NotificationResponse`와 `UnreadCountResponse`는 그 기능을 명확하게 설명합니다.
- **개선할 부분**: 메서드와 클래스 간 관계가 더 명확하게 드러나도록 **주석**을 추가하면 좋겠습니다. 특히 비즈니스 로직이 복잡한 메서드에는 무엇을 하는지 간단히 설명하는 주석이 유용할 것입니다.
    ```java
    public ApiResponse<List<NotificationResponse>> findNotification(@AuthUser User user) {
        // 현재 사용자에 대한 알림 목록을 가져오고 ApiResponse로 감싸 반환
        return ApiSuccessResponse.success(notificationService.getByUser(user));
    }
    ```

### 2. Consistency (일관성)
- **잘 수행된 부분**: 전체 코드에서 명명 규칙이 일관되며, Lombok 애노테이션을 적절히 사용하고 있습니다.
- **개선할 부분**: `@RequestMapping("/api/notifications")`와 같은 모델 내 API 경로 설정이 일관되게 유지되고 있지만, `test` 메서드는 불필요해 보입니다. 개발 과정에서 테스트가 필요하면, 이를 별도의 테스트 스위트로 관리하고 배포 이후에는 제거하는 것이 좋습니다. 
    ```java
    @PostMapping("/test") // 테스트 관련 코드는 일반적으로 삭제하거나 mock서비스로 대체
    public ApiResponse<Void> test(@AuthUser User user) {
        notificationService.create(user.getId(), "test data"); // 메서드 내용 삭제 또는 리팩토링 필요
        return ApiSuccessResponse.success();
    }
    ```

### 3. Reusability (재사용성)
- **잘 수행된 부분**: NotificationService의 메서드들은 독립적인 기능 단위로 잘 분리되어 있습니다.
- **개선할 부분**: `NotificationService`와 같은 서비스 클래스는 다양한 사용자에게 사용될 수 있도록 잘 설계되었지만, `updateIsRead`와 같은 메서드에서는 알림 ID가 유효한지 검증하는 로직을 추가하면 좋겠습니다. 알림이 존재하지 않거나 이미 읽은 경우의 처리를 명확히 할 수 있습니다.
    ```java
    @Transactional
    public void updateIsRead(Long notificationId) {
        Notification notification = notificationRepository.getById(notificationId);
        if (notification.isRead()) {
            // 이미 읽은 알림일 경우, 필요에 따라 로그를 남기거나 예외 던지기
            throw new BusinessException(ALREADY_READ_NOTIFICATION); // ALREADY_READ_NOTIFICATION을 정의
        }
        notification.updateIsRead(true);
    }
    ```

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 예외 및 오류 처리 로직이 대부분 잘 구현되어 있습니다. 특히 `NotificationRepository`에서 ID로 알림을 가져올 때의 예외 처리가 잘 되어 있습니다.
- **개선할 부분**: `sseService.notify`와 같은 외부 호출을 포함한 부분에서 실패할 경우에 대한 예외 처리가 필요합니다. 적절히 로그를 남기고 사용자가 알림을 받을 수 있도록 보장해야 합니다.

### 5. Security (보안성)
- **잘 수행된 부분**: 리포지토리에서 사용자의 ID에 대한 확인이 이루어지는 것이 매우 긍정적입니다.
- **개선할 부분**: API에서 입력된 `user.getId()`와 같은 정보가 만약 민감한 정보 (예: 사용자 권한에 따라 다르게 처리해야 하는 경우) 를 포함할 수 있다면, 확인 절차를 두어야 합니다. 또한, `content`와 `targetUrl` 주소에 대한 입력값 검증 로직을 추가하는 것이 안전성을 높일 수 있습니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 모듈화와 단일 책임 원칙이 잘 적용되어 있습니다. 각 클래스로 분리된 책임들이 잘 수행되고 있어 유지보수하기 용이합니다.
- **개선할 부분**: `formatCreatedDate`와 같은 유틸성 메서드를 별도의 유틸 클래스 또는 헬퍼 클래스로 분리하고, 관련된 포맷팅 방법을 추상화하여 사용할 수 있습니다.
    ```java
    public class DateUtils {
        public static String formatCreatedDate(LocalDateTime startDT, LocalDateTime endDT) {
            // 공통으로 사용될 수 있는 날짜 포맷 로직
        }
    }
    ```

### 전체적인 피드백
전체적으로 코드가 잘 구조화되어 있으며, 적절하게 설명된 비즈니스 로직을 따르고 있습니다. 새로운 기능이 추가되면서 기존 Service의 역할이 명확히 드러나고 있습니다. 그러나 테스트와 필요하지 않은 메서드는 정리하고, 예외 처리나 보안 관련 추가 검증을 개선해야 할 부분이 있습니다. 각 메서드에 대한 세부적인 설명을 추가하여 가독성을 높일 것을 강하게 권장합니다. 

이러한 점들을 고려한다면, 코드의 품질이 더욱 향상되고 향후 유지보수 및 확장성에 있어서도 큰 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-14 19:07:22.866361', 159, '2024-11-14 19:07:22.866361', 40, '제가 요청하신 코드 리뷰를 진행하겠습니다. 코드 변경 사항에 대한 리뷰는 다음의 6가지 평가 항목(가독성, 일관성, 재사용성, 신뢰성, 보안성 및 유지보수성)을 기준으로 진행하며, 각 항목에 대해 잘 수행되고 있는 부분과 개선이 필요한 부분을 구체적으로 지적하겠습니다.

### 1. **Readability (가독성)**
**잘 수행되고 있는 부분:**
- 메서드명과 클래스명이 직관적이고, 해당 기능을 잘 설명합니다. 예를 들어, `getReviewList`나 `regenerateReview` 같은 메서드명은 명확하게 그 기능을 전달합니다.
- `NotificationResponse`와 `UnreadCountResponse`와 같은 데이터 전송 객체는 적절하게 캡슐화되어 있어 응답 구조가 저명합니다.

**개선이 필요한 부분:**
- 특정 로직을 처리하는 부분에서 추가적인 주석이 있으면 좋겠습니다. 예를 들어, 알림을 업데이트하는 비즈니스 로직 (`updateNotification` 메서드 등)에 대해 주석을 추가하면 整理가 용이할 것입니다.
```java
@Operation(summary = "알림 확인", description = "자신의 알림을 확인합니다.")
@PatchMapping("/{notificationId}")
public ApiResponse<Void> updateNotification(
        @PathVariable(name = "notificationId") Long notificationId) {
    // 알림을 읽음으로 표시
    notificationService.updateIsRead(notificationId);
    return ApiSuccessResponse.success();
}
```

### 2. **Consistency (일관성)**
**잘 수행되고 있는 부분:**
- Spring 애너테이션(@GetMapping, @PostMapping 등) 사용이 일관되게 적용되어 있습니다.
- DTO 클래스와 Controller에서 데이터 처리가 일관되게 이루어지고 있습니다.

**개선이 필요한 부분:**
- Lombok 애너테이션(`@RequiredArgsConstructor`)을 사용한 구조가 다른 클래스에서는 다르게 관리되고 있습니다. 모든 클래스에서 일관되게 사용하는 것이 좋습니다.
- 메서드 사이에 주석이나 공백을 일정하게 유지하는 것도 중요합니다. 예를 들어, 메서드 구분을 위해 공백을 추가하는 것이 좋습니다.

### 3. **Reusability (재사용성)**
**잘 수행되고 있는 부분:**
- `NotificationService`는 독립적으로 알림을 생성, 조회 및 업데이트하는 메서드를 잘 분리해 재사용성을 높이고 있습니다.
- `NotificationResponse`와 같은 DTO는 여러 곳에서 재사용 가능하도록 잘 설계되었습니다.

**개선이 필요한 부분:**
- `getUserProject` 메서드와 같은 로직을 비즈니스 로직에 추가하면, 사용자 프로젝트에 대한 중복 코드가 제거될 수 있습니다. 사용자 ID와 프로젝트 ID로부터 사용자 프로젝트를 가져오는 기능을 공통 유틸리티 기능으로 작성할 수 있습니다.

### 4. **Reliability (신뢰성)**
**잘 수행되고 있는 부분:**
- 예외 처리가 적절하게 구현되어 있어 비즈니스 로직에서 에러 발생 시 적절한 예외를 발생시킵니다.
- 예외를 잡아주는 `getById` 메서드와 같이 명확하게 비즈니스 예외를 발생시켜 가독성을 높였습니다.

**개선이 필요한 부분:**
- `RuntimeException`을 발생시키는 부분에서 사용자에게 더 세부적인 오류 메시지를 제공하는 것이 좋습니다. 예를 들어, `JsonProcessingException` 처리 시 오류 메시지에 원인을 추가할 수 있습니다.
```java
catch (JsonProcessingException e) {
    throw new RuntimeException("JSON 파싱 중 오류 발생: " + e.getMessage(), e);
}
```

### 5. **Security (보안성)**
**잘 수행되고 있는 부분:**
- `@RequestParam` 등을 사용하여 요청 파라미터를 바인딩하는 방식은 보안적으로 안전하게 처리되고 있습니다.

**개선이 필요한 부분:**
- 사용자 인증 및 권한 검증 관련 로직이 필요합니다. 모든 요청에서 사용자가 올바른 권한을 가지고 수행하는지 체크하는 로직을 추가하는 것이 좋습니다.
- URL 경로 ID (`@PathVariable`의 `notificationId`)를 사용할 때 권한 확인을 추가하여 사용자 소속의 알림만 작동하도록 하세요.

### 6. **Maintainability (유지보수성)**
**잘 수행되고 있는 부분:**
- 각 메서드가 단일 책임 원칙을 잘 따르고 있어서 쉽게 유지보수가 가능합니다.

**개선이 필요한 부분:**
- 서비스 클래스의 의존성이 많아지면서 클래스 크기가 커질 수 있습니다. 기능별로 세분화하여 클래스를 나누어 추가적인 유지보수가 용이하도록 고려해야 합니다.
- 서비스와 컨트롤러 클래스 간의 의존도가 높아지지 않도록 각 기능의 논리를 단순화하고, 재사용 가능한 구성 요소로 분리하는 것이 좋습니다.

### **전체적인 피드백**
- 코드 전반적으로 기능적으로 잘 작성되어 있고, 가독성과 일관성 또한 좋습니다. 특히, 적절한 DTO 사용과 서비스 메서드의 분리가 돋보입니다.
- 그러나 유지보수성과 재사용성을 고려하여 공통 기능을 공통 메서드로 추출하는 것이 필요합니다. 예외 처리 역시 강화하고, 보안을 수반하는 코드 리뷰 시 철저하게 검토하기를 권장합니다. 

위 개선 사항들을 반영하신다면 코드의 질이 더욱 향상될 것입니다. 잘하셨습니다!');
INSERT INTO public.review VALUES ('2024-11-14 19:12:35.681115', 160, '2024-11-14 19:12:35.681115', 40, '### 코드 리뷰

#### 1. Readability (가독성)
- **잘 수행되고 있는 부분**: 전반적으로 클래스와 메소드의 이름이 명확하고, 각 메소드는 수행하는 작업이 직관적으로 보입니다. 예를 들어, `findNotification`, `updateNotification`, `unreadNotificationCount` 등과 같이 각각의 메소드 목적이 잘 드러납니다.
- **개선할 점**:
  - `formatCreatedDate` 메소드에서 날짜 형식을 지정하는 부분을 주석으로 설명하면 좋겠습니다. 특히 시간 단위를 비교하는 이유와 함께 반환 값의 의미를 설명하면 추후 유지보수 시 유용할 것입니다.
  ```java
  private String formatCreatedDate(LocalDateTime startDT, LocalDateTime endDT) {
      // 특정 시간 간격에 따라 ''방금 전'', ''XX분 전'', ''XX시간 전'', 날짜 형식으로 변환
      long minutesBetween = ChronoUnit.MINUTES.between(startDT, endDT);
      ...
  }
  ```

#### 2. Consistency (일관성)
- **잘 수행되고 있는 부분**: 코드의 전체적인 스타일이 일관성 있게 유지되고 있으며, `@Transactional`, `@Service`와 같은 Spring의 어노테이션 사용이 올바르게 적용되었습니다.
- **개선할 점**:
  - Java의 자료형에 대한 일관성을 유지하기 위해 `String`과의 연결 방식에 대해 주의를 기울이는 것이 좋습니다. 예를 들어, 문자열 결합 시 `String.format`을 사용하면 더 명확한 코드가 될 수 있습니다. (`AI_REVIEW_COMPLETE_MESSAGE`와 같은 상수를 메시지로 넘길 때 유용합니다.)
  ```java
  notificationService.create(user.getId(), userProject, String.format("%s: %s", AI_REVIEW_COMPLETE_MESSAGE, additionalInfo));
  ```

#### 3. Reusability (재사용성)
- **잘 수행되고 있는 부분**: `NotificationResponse`와 `UnreadCountResponse`와 같은 데이터 전송 객체(DTO)는 좋은 설계입니다. 이를 통해 서로 다른 서비스 간에 메소드를 재사용하기 쉬워졌습니다.
- **개선할 점**:
  - 비즈니스 로직으로서 `create`, `updateIsRead` 메소드의 재사용성을 높이기 위해, 알림 내용이 공통적으로 활용되는 다양한 상황에 대한 핸들러 메소드를 추가할 수 있습니다. 예를 들어, 알림을 작성하는 로직을 별도로 모듈화 하면, 다양한 종류의 알림을 한 곳에서 생성할 수 있습니다.
  ```java
  public Notification createNotification(Long userId, UserProject userProject, String content) {
      // 알림 객체 생성 로직을 별도의 메소드로 분리
      ...
  }
  ```

#### 4. Reliability (신뢰성)
- **잘 수행되고 있는 부분**: 예외 처리가 잘 구현되어 있어 일반적인 오류 상황에 대한 대응이 가능합니다. `BusinessException`을 적절히 활용하여 존재하지 않는 알림 에러를 처리하고 있습니다.
- **개선할 점**:
  - 에러 처리 시 좀 더 세부적인 예외 타입을 도입하면 좋겠습니다. 예를 들어 `updateIsRead`에서 알림이 이미 읽은 경우, 사용자에게 알림을 표시하는 것이 아니라 상태 변경이 없었다고 알려주는 것이 좋습니다.
  ```java
  @Transactional
  public void updateIsRead(Long notificationId) {
      Notification notification = notificationRepository.getById(notificationId);
      if (!notification.isRead()) {
          notification.updateIsRead(true);
      } else {
          throw new NotificationAlreadyReadException(notificationId); // 사용자 정의 예외
      }
  }
  ```

#### 5. Security (보안성)
- **잘 수행되고 있는 부분**: 입력 값에 대한 검증은 좋은 조치입니다. 특히 `@RequestParam`을 활용하여 필요한 매개변수를 스프링이 잘 처리할 수 있도록 하고 있습니다.
- **개선할 점**:
  - 특히 사용자 입력을 다룰 때는 SQL 인젝션 등 다양한 타입의 공격을 방어하기 위한 코드가 추가되어야 합니다. 예를 들어, `projectId`와 같은 파라미터가 유효한 ID인지 정교한 검증이 필요합니다.
  ```java
  if (projectId <= 0) {
      throw new InvalidParameterException("Invalid projectId: " + projectId);
  }
  ```

#### 6. Maintainability (유지보수성)
- **잘 수행되고 있는 부분**: 클래스와 메소드가 논리적으로 잘 나누어져 있어, 각 기능을 독립적으로 관리하고 수정하기 용이합니다.
- **개선할 점**:
  - 클래스를 더욱 모듈화하여 변경의 영향을 최소화할 수 있습니다. 예를 들어, ''알림 처리'' 로직을 `NotificationService` 내에서 분리된 메소드로 추가하여 다양한 알림 유형에 대해 유연하게 대응할 수 있습니다.

### 전체적인 피드백
- 코드 전반적으로 **잘 수행하고 있는 부분**: 명확한 클래스 및 메소드 구조와 예외 처리, 데이터 모델링이 잘되어 있습니다. 
- **개선이 필요한 부분**: 특정 세부사항에서 가독성을 높일 수 있는 주석 추가 및 예외 처리의 강화가 필요합니다. 또한, 함수의 재사용성이 높아질 수 있도록 코드 구조를 개선할 수 있는 여지가 보입니다. 

이러한 개선점을 통해 코드의 품질을 더욱 높이고 안정성을 강화할 수 있습니다. 잘 작성된 부분에 대해서는 긍정적인 피드백을 드립니다. 계속해서 좋은 코드를 만들어주시길 바랍니다!');
INSERT INTO public.review VALUES ('2024-11-14 19:13:15.889606', 161, '2024-11-14 19:13:15.889606', 40, '## 코드 리뷰 피드백

### 1. Readability (가독성)
- **강점**: 코드의 구조와 분리가 잘 되어 있어 이해하기 쉽습니다. 특히, DTO를 사용하여 응답을 구성하는 부분과 서비스 로직의 분리로 인해 각 기능이 무엇을 하는지 쉽게 파악할 수 있습니다.
- **개선 사항**:
  - 메서드와 변수명은 대부분 명확하지만, `findNotification`와 같이 동사의 명사형을 혼용하여 사용하고 있습니다. 이를 `getNotifications`와 같이 일관된 동사형으로 정리하는 것이 좋습니다.
```java
public ApiResponse<List<NotificationResponse>> getNotifications(
    @AuthUser User user, @RequestParam(name = "projectId") Long projectId) {
    return ApiSuccessResponse.success(notificationService.getByUser(user.getId(), projectId));
}
```
  - 주요 연산의 복잡도를 낮출 수 있도록 의미 있는 주석을 추가하여 코드 이해를 돕는 것도 고려해보세요.
  
### 2. Consistency (일관성)
- **강점**: 코드 전체에서 Lombok을 활용한 Getter, Builder 사용이 일관되며, 정의된 코딩 규약을 잘 준수하고 있습니다.
- **개선 사항**:
  - 클래스와 메서드에서의 주석 사용 스타일이 일관되지 않을 때가 있으므로, 이를 통일화하는 것이 필요합니다. 모든 클래스 위에 설명적인 주석을 추가하는 것이 좋습니다.
  
### 3. Reusability (재사용성)
- **강점**: Notification과 관련된 DTOs와 서비스가 잘 분리되어 있어 향후 다른 서비스에서도 쉽게 재사용할 수 있는 구조가 잘 마련되어 있습니다.
- **개선 사항**:
  - `formatCreatedDate` 메서드와 같은 유틸리티 메서드는 여러 곳에서 활용될 수 있으니, 따로 유틸 클래스로 분리해 두는 것은 재사용성을 높이는 데 도움이 될 것입니다.
```java
public class DateUtils {
    public static String formatCreatedDate(LocalDateTime startDT, LocalDateTime endDT) {
        // Implementation
    }
}
```

### 4. Reliability (신뢰성)
- **강점**: 예외 처리에 대해 적절히 타당한 예외가 발생할 경우 `BusinessException`으로 반환하여, 클라이언트가 이해할 수 있도록 구현이 잘 되어 있습니다.
- **개선 사항**:
  - `updateIsRead` 메서드에서는 알림이 이미 읽은 상태일 때 무시하는 로직이 들어가 있는데, 이 경우 로그를 남기거나 사용자에게 관련 메시지를 기재하는 것도 좋습니다.
```java
if (!notification.isRead()) {
    notification.updateIsRead(true);
} else {
    log.warn("Notification {} was already read", notificationId);
}
```

### 5. Security (보안성)
- **강점**: 사용자 인증을 위한 `@AuthUser`를 사용하여, 알림 같은 민감한 데이터에 대한 접근을 안전하게 제어하는 점이 좋습니다.
- **개선 사항**:
  - `notificationService.updateIsRead(notificationId)` 메서드에서, 입력된 `notificationId`가 유효한지 확인하는 로직을 추가하여 보안을 더욱 강화할 수 있습니다. 

### 6. Maintainability (유지보수성)
- **강점**: 서비스의 유연성을 고려한 트랜잭션 관리는 잘 이루어지고 있으며, 읽기 전용 트랜잭션이 적절히 사용되고 있습니다.
- **개선 사항**:
  - 새로운 알림을 생성하거나 수정할 때 `Service` 클래스의 책임이 복잡해질 수 있으니, 각 메서드의 책임을 명확히 제시하고, 서비스 단에서 관련된 `DTO`를 활용하는 방식으로 유지보수성을 더욱 높일 수 있습니다. 이를 통해 나중에 특정 기능 개선이나 추가 시 편리하게 적용할 수 있을 것입니다.

### 전체적인 피드백
- 코드가 전반적으로 잘 구성되어 있으며, 특히 DTO와 서비스의 구분이 잘 되어 있어 가독성과 유지보수성이 높습니다. 
- 그러나 일관성과 재사용성을 높이기 위해 추가적인 방법론(유틸 클래스 작성 등)과 일관된 네이밍 규칙을 적용하는 것이 좋습니다.
- 예외 처리와 보안 관련 사항을 좀 더 강화한다면 더욱 안정성 높은 코드를 만들 수 있을 것입니다. 
- 마지막으로, 개선할 사항에 대해선 세심한 주의가 필요하며, 이를 통해 코드 품질이 더욱 향상될 것으로 기대합니다. 

노력한 변화에 대해 좋은 성과를 이루시기를 바랍니다. 감사합니다!');
INSERT INTO public.review VALUES ('2024-11-14 19:14:27.997284', 162, '2024-11-14 19:14:27.997284', 40, '# 코드 리뷰

## 1. Readability (가독성)

### 긍정적인 부분
- **명확한 클래스 및 메서드 이름**: 클래스 이름 `NotificationService`, `NotificationController` 및 메서드 이름들이 각각의 기능을 잘 설명하고 있어 이해하기 쉽습니다.

### 개선 사항
- **주석 추가**: 각 메서드의 기능이나 주요 로직에 대한 설명이 부족합니다. 예를 들어, `create`, `getByUser`, `updateIsRead` 메서드에는 해당 로직이 어떤 목적으로 사용되는지 설명하는 주석을 추가하면 가독성을 높일 수 있습니다.

#### 예시:
```java
/**
 * 새로운 알림을 생성하고, 해당 사용자에게 SSE로 알림을 보냅니다.
 *
 * @param userId 사용자의 ID
 * @param userProject 관련 사용자 프로젝트
 * @param content 알림 내용
 */
@Transactional
public void create(Long userId, UserProject userProject, String content) {
    // 실제 로직
}
```

## 2. Consistency (일관성)

### 긍정적인 부분
- **패키지 및 클래스 구조**: 패키지 이름과 클래스 이름이 일관된 규칙을 따르고 있어 프로젝트 구조가 명확합니다.

### 개선 사항
- **메서드 인덱스 간격**: 메서드 사이의 간격이 불균형합니다. 예를 들어, `findNotification`과 `findUnreadNotificationsCount` 사이의 공백이 다른 메서드들과 다르게 나타납니다. 일관된 간격을 유지하는 것이 좋습니다.

#### 예시 개선:
```java
@GetMapping
public ApiResponse<List<NotificationResponse>> findNotification(
        @AuthUser User user, @RequestParam(name = "projectId") Long projectId) {
    return ApiSuccessResponse.success(notificationService.getByUser(user.getId(), projectId));
}

/**
 * 읽지 않은 알림 개수 조회
 * 
 * @return ApiResponse<UnreadCountResponse>
 */
@GetMapping("/unread-counts")
public ApiResponse<UnreadCountResponse> findUnreadNotificationsCount(
        @AuthUser User user, @RequestParam(name = "projectId") Long projectId) {
    return ApiSuccessResponse.success(
            notificationService.unreadNotificationCount(user.getId(), projectId));
}
```

## 3. Reusability (재사용성)

### 긍정적인 부분
- **기능 모듈화**: Notification 관련 기능이 `NotificationService`, `NotificationController`로 잘 분리되어 서비스와 컨트롤러 역할이 명확했습니다.

### 개선 사항
- **중복 코드 최소화**: `findByProjectAndGitlabAccount`와 같은 Database 호출이 여러 메서드에서 반복되고 있습니다. 해당 로직을 별도의 헬퍼 메서드로 추출할 수 있습니다.

#### 예시:
```java
private UserProject getUserProject(Long userId, Long projectId) {
    User user = userRepository.getById(userId);
    GitlabAccount gitlabAccount = user.getGitlabAccounts().getFirst();
    return getUserProjectByGitlabAccountAndProject(gitlabAccount, projectId);
}

private UserProject getUserProjectByGitlabAccountAndProject(GitlabAccount gitlabAccount, Long projectId) {
    Project project = projectRepository.getById(projectId);
    return userProjectRepository
            .findByProjectAndGitlabAccount(project, gitlabAccount)
            .orElseThrow(() -> new BusinessException(ErrorCode.USER_PROJECT_NOT_EXIST));
}
```

## 4. Reliability (신뢰성)

### 긍정적인 부분
- **예외 처리**: `getById` 메서드에서 BusinessException을 사용하여, 데이터가 없을 경우 적절히 처리하고 있습니다.

### 개선 사항
- **추가적인 예외 처리**: `updateNotification` 메서드에서는 단순히 읽음 상태를 업데이트하고 있는데, 해당 ID가 존재하지 않을 경우의 예외 처리가 없으므로 추가해야 합니다.

#### 예시:
```java
public ApiResponse<Void> updateNotification(@PathVariable(name = "notificationId") Long notificationId) {
    notificationService.updateIsRead(notificationId);
    return ApiSuccessResponse.success();
}

@Transactional
public void updateIsRead(Long notificationId) {
    Notification notification = notificationRepository.getById(notificationId);
    if (!notification.isRead()) {
        notification.updateIsRead(true);
    }
}
```

## 5. Security (보안성)

### 긍정적인 부분
- **인증 사용자 사용**: `@AuthUser` 어노테이션을 통해 인증된 사용자만 API를 사용할 수 있도록 설정되었습니다. 이는 좋은 보안 Practices입니다.

### 개선 사항
- **입력 검증 추가**: `create` 메서드의 파라미터에 대한 검증이 추가되어야 합니다. 예를 들어, `content`가 비어있거나 null 일 경우를 체크할 필요가 있습니다.

#### 예시:
```java
public void create(Long userId, UserProject userProject, String content) {
    if (content == null || content.trim().isEmpty()) {
        throw new IllegalArgumentException("Content must not be empty");
    }
    // 기존 로직
}
```

## 6. Maintainability (유지보수성)

### 긍정적인 부분
- **Service/Controller 분리**: 서비스 로직과 컨트롤러 로직이 명확히 분리되어 있어 유지보수가 용이합니다. 각 클래스가 단일 책임을 지니고 있습니다.

### 개선 사항
- **복잡도 감소**: `getUserProject` 메서드가 여러 번 호출되고 있으며, 이는 메서드가 복잡해질 수 있습니다. 해당 메서드 내 로직을 세분화하여 복잡도를 줄이는 것이 좋습니다.

#### 예시:
```java
private UserProject getUserProject(Long userId, Long projectId) {
    User user = getUserById(userId);
    GitlabAccount gitlabAccount = getGitlabAccount(user);
    return findUserProjectByAccountAndProject(gitlabAccount, projectId);
}

private User getUserById(Long userId) {
    return userRepository.getById(userId);
}

private GitlabAccount getGitlabAccount(User user) {
    return user.getGitlabAccounts().getFirst();
}
```

## 전체적인 피드백
- **잘 수행하고 있는 부분**: 전반적으로 코드가 명확하게 구조화되어 있으며, 의미 있는 메서드와 변수명이 사용되고 있는 점이 긍정적입니다. 예외 처리와 비즈니스 로직의 안정성 또한 훌륭합니다.

- **개선이 필요한 부분**: 가독성 및 유지보수성을 높이기 위해 메서드와 클래스에 더 많은 주석을 추가하고, 반복적인 로직을 분리하는 것이 필요합니다. 또한, 입력에 대한 검증을 강화하여 보안을 강화할 수 있습니다.

코드 리뷰를 통해 개선할 점을 더 잘 파악하게 되어 이점이 있을 것입니다. 계속해서 좋은 코드 작성하시길 바랍니다!');
INSERT INTO public.review VALUES ('2024-11-14 19:15:32.929798', 163, '2024-11-14 19:15:32.929798', 36, '아래는 제공해주신 코드를 기준으로 각각의 평가 항목에 대한 심도 있는 리뷰와 구체적인 개선 사항입니다.

```python
def process_data(data):
    result = []
    for i in range(len(data)):
        if data[i] % 2 == 0:
            result.append(data[i] * 2)
        else:
            result.append(data[i] * 3)
    return result
```

### 1. Readability (가독성)
- **잘 수행된 부분**: 전체적으로 코드의 구조가 직관적이며, 기본적인 로직이 심플하게 작성되어 있어 이해하기 용이합니다.
- **개선 필요 부분**: 변수 `i` 보다는 데이터 요소 자체를 사용하는 것이 가독성을 높일 수 있습니다. 또한, 각 조건의 동작을 설명하는 주석이 추가되면 좋겠습니다.

```python
def process_data(data):
    result = []
    for value in data:  # 직접 요소를 반복합니다.
        if value % 2 == 0:
            result.append(value * 2)  # 짝수일 경우
        else:
            result.append(value * 3)  # 홀수일 경우
    return result
```

### 2. Consistency (일관성)
- **잘 수행된 부분**: 코드 스타일이 일관되게 유지되고 있습니다.
- **개선 필요 부분**: 기능적 매개변수 부분에서, ‘data’처럼 일반적인 이름보다는 그 의미를 명확히 나타내는 것이 일관성을 갖추는 데 도움이 됩니다. 예를 들어 `input_data` 또는 `numbers` 같은 이름을 고려할 수 있습니다.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: 현재의 함수는 입력된 데이터 리스트에 대해 변형을 가하는 독립적인 기능을 수행합니다.
- **개선 필요 부분**: 함수의 기능을 보다 범용적으로 하기 위해, 특정 작업 (예: 홀수/짝수 처리)에 대한 로직을 별도의 함수로 분리하는 것이 좋습니다. 예를 들어 아래와 같이 처리 할 수 있습니다.

```python
def transform_value(value):
    return value * 2 if value % 2 == 0 else value * 3

def process_data(data):
    return [transform_value(value) for value in data]
```

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: 현재 코드는 기본적인 수학적 처리를 수행하며, 정상적으로 기능을 수행할 것으로 기대됩니다.
- **개선 필요 부분**: 입력 데이터의 타입 체크와 같은 예외 처리 로직을 추가하여 안전성을 높일 수 있습니다.

```python
def process_data(data):
    if not isinstance(data, list):
        raise ValueError("Input must be a list")
    return [transform_value(value) for value in data]
```

### 5. Security (보안성)
- **잘 수행된 부분**: 현재 코드에서는 보안적 문제가 두드러지지 않습니다.
- **개선 필요 부분**: 그러나 입력 데이터에 대한 유효성 검사를 추가하고, 잠재적인 보안 문제 (예: 악의적인 입력 처리)에 대비할 필요가 있습니다.

```python
def process_data(data):
    if not isinstance(data, list):
        raise ValueError("Input must be a list")
    for value in data:
        if not isinstance(value, int):  # 각 요소가 정수인지 확인합니다.
            raise ValueError("All elements must be integers")
    return [transform_value(value) for value in data]
```

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 코드의 논리가 간단하고 이해하기 쉬워 유지보수가 용이할 것으로 보입니다.
- **개선 필요 부분**: 다양한 동작을 수행하는 로직을 특징별로 나누는 모듈화를 고려하면 향후 변경이나 추가가 쉬워집니다. 

```python
def process_data(data):
    # ... 위의 변형된 코드와 포함 ...
```

### 전체적인 피드백
- **잘 수행된 부분**: 코드는 기본적인 데이터 변형을 잘 수행하고 있으며, 로직이 간단하여 이해하기 쉽습니다. 또한, 명확한 반복문 사용이 돋보입니다.
- **개선이 필요한 부분**: 타입 체크 및 예외 처리를 추가하면 더욱 안정성이 향상될 수 있으며, 주석 및 함수의 동작을 설명하는 텍스트가 추가되면 가독성이 높아질 것입니다. 변형 로직의 분리는 코드의 재사용성을 높이고, 유지보수의 용이성을 제공할 것입니다.

제공된 개선 사항을 통해 코드의 효과성을 높일 수 있을 것입니다. 좋은 작업에 감사드립니다!');
INSERT INTO public.review VALUES ('2024-11-14 19:16:25.737133', 164, '2024-11-14 19:16:25.737133', 39, '코드 리뷰에 대한 요청을 검토하며, 다음과 같은 평가 항목을 통해 전체적인 피드백을 제공하겠습니다.

### 1. Readability (가독성)
- **잘 수행되고 있는 부분**:
  - 전체적으로 코드가 깔끔하게 작성되어 있으며, 함수 및 변수명은 명확한 목적을 가지고 있습니다.
- **개선 사항**:
  - 주석 부분이 주석 처리된 코드에만 포함되어 있는데, 이는 실제 사용자가 이 코드를 읽을 때 혼란을 초래할 수 있습니다. 주석을 사용하여 의도를 명확히 하거나, 불필요한 코드는 삭제하는 것이 좋습니다.
  
  ```javascript
  // 예를 들어, 주석을 사용하여 이 주석 처리된 함수의 목적을 설명하거나, 필요할 경우 삭제
  // const handleNewAlarm = (newAlarm: Alarm) => { ... };
  ```

### 2. Consistency (일관성)
- **잘 수행되고 있는 부분**:
  - 코드 스타일이 일관되게 유지되고 있으며, JSX 부분과 CSS 주석도 잘 정리되어 있습니다.
- **개선 사항**:
  - 클래스 이름 규칙이나 CSS 파일을 import하는 방식 등에 대한 일관성 확보가 필요합니다. 예를 들어, 클래스 이름을 명확한 키워드나 이름 규칙을 통해 통일해야 합니다.

### 3. Reusability (재사용성)
- **잘 수행되고 있는 부분**:
  - 각 함수가 체계적으로 잘 구조화되어 있어 재사용이 가능할 잠재력을 가지고 있습니다.
- **개선 사항**:
  - `handleNewAlarm` 같은 특정 동작을 하는 함수는 독립적으로 동작할 수 있도록 모듈화하여 다른 상황에서도 재사용 가능하도록 한다면, 코드의 품질을 높일 수 있습니다.

### 4. Reliability (신뢰성)
- **잘 수행되고 있는 부분**:
  - 주요 로직이 경우에 따라 잘 작성되어 있으며, 가독성이 좋습니다.
- **개선 사항**:
  - 예외 처리 관련 코드는 보이지 않으며, 이는 런타임 에러 발생 시 사용자에게 심각한 문제를 초래할 수 있습니다. 예를 들어 null 체크를 추가하거나, 예상치 못한 입력에 대한 처리가 필요합니다.
  
  ```javascript
  const handleAlarmClick = (id: number) => {
    if (id == null) {
      console.error("Invalid alarm ID");
      return;
    }
    // 나머지 로직
  };
  ```

### 5. Security (보안성)
- **개선 사항**:
  - 외부에서 입력을 받을 경우, 특수문자나 비정상적인 데이터에 대한 검증이 필요합니다. React의 `dangerouslySetInnerHTML`을 사용하거나, 입력을 다룰 때는 보안을 항상 염두에 두어야 합니다.

### 6. Maintainability (유지보수성)
- **잘 수행되고 있는 부분**:
  - 전체적으로 각 기능이 모듈화되어 있으며, 기본적인 반응형 디자인이 적용될 가능성이 보여 좋습니다.
- **개선 사항**:
  - 모든 CSS는 별도의 파일로 관리하고, 컴포넌트의 스타일이 다른 컴포넌트와 겹치지 않도록 네이밍 컨벤션을 강화해야 합니다.
  
  ```css
  /* 파일 구조 변경 가능성 고려, BEM(블록, 엘리먼트, 수정자) 컨벤션 사용 */
  .loading-container {
    /* ... */
  }
  ```

### 전체적인 피드백
- **잘 수행되고 있는 부분**: 코드는 가독성이 높고, 목적에 맞게 작성되어 있어 팀원들이 이해하기 용이합니다. 주석의 사용은 전반적으로 도움이 될 수 있으나, 현재로선 불필요한 부분이 많습니다. CSS와 JSX 구조가 통일되어 있습니다.
- **개선이 필요한 부분**: 오류 처리 및 입력 검증이 부족하여 런타임 에러 발생 시 문제가 발생할 수 있습니다. 각 함수의 독립성을 높이고, 불필요한 코드는 제거하는 방향으로 코드를 정리하는 것이 좋습니다. 보안과 관련하여 유저 입력에 대해 더 주의를 기울여야 합니다.

이런 개선 사항을 반영하는 것만으로도 코드의 질이 크게 향상될 것입니다. 필요하다면 개선 사항을 우선순위에 따라 해결하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-14 19:17:39.599131', 165, '2024-11-14 19:17:39.599131', 39, '먼저, 코드 변경 사항을 검토할 수 있는 기회를 주셔서 감사합니다. 아래에서 각 항목을 토대로 평가하고 구체적인 개선사항을 제안하겠습니다.

### 1. Readability (가독성)
- **잘 수행된 부분**: 코드에서 `mockData.filter`를 사용하여 읽지 않은 알람 개수를 계산하는 부분은 명확합니다. 이러한 함수형 프로그래밍 스타일은 가독성을 높이는 데에 기여합니다.
- **개선 필요 부분**: 주석이 없어서 `handleNewAlarm` 함수의 의도가 파악되지 않습니다. 각 함수의 목적과 동작에 대한 설명을 추가하는 것이 좋습니다. 예를 들어:

```javascript
/**
 * 새로운 알람을 처리하는 함수
 * @param {Alarm} newAlarm - 새로 추가할 알람 객체
 */
const handleNewAlarm = (newAlarm: Alarm) => {
    // ...
};
```

### 2. Consistency (일관성)
- **잘 수행된 부분**: 전체적으로 코딩 스타일이 일관적입니다. 변수 명명 규칙 또한 유사한 패턴을 따르고 있습니다.
- **개선 필요 부분**: 주석 처리된 `handleNewAlarm` 함수가 남아있어 코드의 혼란을 초래할 수 있습니다. 주석 처리된 코드는 불필요한 경우 삭제하거나, 주석 처리 이유를 명확히 해두는 것이 좋습니다.

### 3. Reusability (재사용성)
- **잘 수행된 부분**: 각 함수가 독립적으로 잘 나누어져 있어, 다른 컴포넌트에서도 재사용하기 용이합니다.
- **개선 필요 부분**: `handleNewAlarm`와 같은 기능을 하는 코드가 여러 곳에 있을 가능성이 있다면, 이를 별도의 유틸리티 함수로 분리하여 재사용할 수 있도록 개선할 수 있습니다.

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: `setCount(mockData.filter((alarm) => !alarm.read).length);` 부분은 필터링 후 알람 수를 계산하고 설정하는 로직이 올바르게 작동할 것으로 보입니다.
- **개선 필요 부분**: 새로운 알람을 처리하는 로직에서, `newAlarm` 객체의 유효성을 검사하는 로직이 추가된다면 더 신뢰성을 높일 수 있습니다.

```javascript
if (!newAlarm || !newAlarm.message) {
    console.error("Invalid alarm object");
    return;
}
```

### 5. Security (보안성)
- **잘 수행된 부분**: 코드내에서 민감한 데이터 처리에 대한 기본적인 보안 조치는 없어 보여 큰 문제는 없습니다.
- **개선 필요 부분**: `newAlarm` 처리 시, 클라이언트가 제공하는 데이터를 그대로 사용하면 보안 위협이 발생할 수 있습니다. 이러한 데이터는 검증과 인코딩을 통해 보안을 강화하는 것이 좋습니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 각 함수가 잘 구조화되어 있어 유지보수가 용이합니다.
- **개선 필요 부분**: CSS 코드가 주석 처리되어 보이지 않는 상태인데, 이 부분은 별도의 스타일 파일로 유지하는 것이 좋습니다. 전반적으로 스타일과 로직을 분리하면 유지보수성을 높일 수 있습니다.

```css
/* Loading.css - 스타일을 분리하여 코드의 모듈성을 높입니다. */
```

### 전체적인 피드백
코드 전반적으로 명확한 로직 구조와 가독성을 갖추고 있어 긍정적입니다. 특히, 기존 알람 데이터에 대한 처리 로직은 간결하면서도 효과적으로 작성되었습니다. 그러나 주석 부족과 불필요한 주석 처리된 코드들은 혼란을 줄 수 있으므로 이를 개선하는 것이 좋습니다. 우선 `handleNewAlarm` 함수의 유효성을 검증하는 등의 작업을 통해 코드를 더 안전하고 신뢰성 있게 만들 수 있을 것입니다.

다음 단계로, 불필요한 코드 주석 제거 및 명확한 주석 추가, 유틸리티 함수 활용을 통한 코드 재사용성과 모듈화의 개선을 권장합니다. 이를 통해 코드의 유지보수성을 높일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-14 19:33:13.599148', 166, '2024-11-14 19:33:13.599148', 40, '## 코드 리뷰

### 1. 가독성 (Readability)
- **잘 수행된 부분**: 전체적으로 관련된 기능들이 잘 모여 있어 코드의 흐름을 이해하기 쉽습니다. `NotificationResponse`, `UnreadCountResponse`와 같은 DTO 클래스들이 명확하게 설계되어 있습니다.
  
- **개선할 부분**: 
  - 주석의 사용이 부족합니다. 각 메서드 위에 그 기능을 간략히 설명하는 주석을 추가하는 것이 좋습니다. 예를 들어, `updateNotification` 메서드에는 "특정 알림의 읽지 않은 상태를 업데이트합니다."와 같은 설명이 필요합니다.
  
  ```java
  /**
   * 특정 알림의 읽지 않은 상태를 업데이트합니다.
   */
  @PatchMapping("/{notificationId}")
  public ApiResponse<Void> updateNotification(
      @PathVariable(name = "notificationId") Long notificationId) {
      notificationService.updateIsRead(notificationId);
      return ApiSuccessResponse.success();
  }
  ```

### 2. 일관성 (Consistency)
- **잘 수행된 부분**: 클래스 및 메서드의 명명 규칙이 일관되게 유지되고 있습니다. `Notification`, `NotificationRepository`, `NotificationService` 등과 같이 각 구성 요소의 역할이 명확합니다.

- **개선할 부분**: 오류 코드 정의에서 사용하는 주석 스타일이 일관되지 않습니다. `NOTIFICATION_NOT_EXIST` 오류 코드에 대한 설명을 추가할 때 같은 형식을 유지하는 것이 좋습니다.
  
  ```java
  /**
   * NOTIFICATION(O000) 
   * 알림이 존재하지 않을 때 발생하는 예외입니다.
   */
  NOTIFICATION_NOT_EXIST(HttpStatus.NOT_FOUND, "O001", "존재하지 않는 알림입니다."),
  ```

### 3. 재사용성 (Reusability)
- **잘 수행된 부분**: DTO는 불변 객체로 구현되어 있어 재사용성이 높습니다. 필요한 데이터를 여러 컨트롤러에서 쉽게 사용할 수 있습니다.

- **개선할 부분**: `formatCreatedDate` 메서드는 다른 클래스에서도 유사한 날짜 포매팅이 필요한 경우가 있을 것입니다. 이 메서드를 유틸리티 클래스로 분리하면 재사용성을 높일 수 있습니다.
  
  ```java
  public class DateUtil {
      public static String formatCreatedDate(LocalDateTime startDT, LocalDateTime endDT) {
          // ...
      }
  }
  ```

### 4. 신뢰성 (Reliability)
- **잘 수행된 부분**: `getById` 메서드에서 예외를 발생시키는 방식이 적절하여 오류 상황에 대한 처리가 체계적입니다. 읽지 않은 알림 개수를 세는 로직도 명확합니다.
  
- **개선할 부분**: `updateIsRead` 메서드에서 알림이 이미 읽은 상태일 경우, 굳이 `updateIsRead`를 호출하는 것은 불필요해 보입니다. 이를 제거하여 불필요한 메서드 호출을 줄이는 것이 좋습니다.
  
  ```java
  @Transactional
  public void updateIsRead(Long notificationId) {
      Notification notification = notificationRepository.getById(notificationId);
      if (!notification.isRead()) {
          notification.updateIsRead(true);
      }
  }
  ```

### 5. 보안성 (Security)
- **잘 수행된 부분**: 입력 검증이 잘 되어 있으며, 비즈니스 로직에서 예외 처리가 적절히 이루어져 있습니다.
  
- **개선할 부분**: `findByProjectAndGitlabAccount` 쿼리를 사용할 때 SQL 인젝션에 대비하는 방어적인 코딩이 필요할 수 있습니다. JPA를 사용할 때는 기본적으로 안전하지만 추가적인 검증 로직을 넣는 것이 좋은 방법입니다.

### 6. 유지보수성 (Maintainability)
- **잘 수행된 부분**: 클래스와 메서드가 잘 구조화되어 있어 수정이나 기능 추가가 용이합니다. 서비스 클래스가 Single Responsibility Principle을 잘 따르고 있습니다.
  
- **개선할 부분**: Notification과 관련된 여러 기능을 NotificationService로 모아 두었지만, 알림을 사용자에게 전송하는 로직(SSEService)와의 의존성이 있으며, 이 부분이 확장될 경우 의도하지 않은 결합도가 높아질 수 있습니다. 이 두 기능을 통합하는 대신, 각 기능 별로 서비스 클래스를 나누는 것이 확장성을 높일 수 있습니다.

```java
public class NotificationPublishingService {
    private final SseService sseService;

    public void sendNotification(Long userId, String message) {
        sseService.notify(userId, message);
    }
}
```

---

## 전체적인 피드백
전반적으로 잘 작성된 코드로서, 각 클래스 및 메서드의 역할이 뚜렷하여 가독성이 좋습니다. 그러나 주석 부족, 일관성 등의 미세한 부분에서 개선이 필요합니다. 저장하고 처리하는 로직이 비즈니스 로직을 명확히 반영하고 있으며, 적절한 예외 처리도 이루어져 있어 신뢰성이 높습니다. 

가독성과 유지보수성을 높이기 위해 주석을 더 추가하고, 날짜 포맷팅 로직을 유틸리티 클래스로 분리하는 것이 도움이 될 것입니다. 재사용성과 확장성을 고려하여 서비스 간의 결합도를 낮출 방안을 모색하는 것도 좋습니다.

기타 몇 가지 미세한 코드 스타일을 조정하면 전체 코드 품질이 더 높아질 것입니다. 좋은 작업입니다!');
INSERT INTO public.review VALUES ('2024-11-15 17:10:15.692142', 174, '2024-11-15 17:10:15.692142', 39, '코드 리뷰 결과를 각 항목화하여 상세한 피드백을 제공하겠습니다.

### 1. Readability (가독성)
#### 잘 수행되고 있는 부분
- 변경된 코드 내섯 주석 처리된 부분이 들어 있으며, 이는 필요할 경우 기능을 재사용할 수 있는 측면에서 좋습니다. 주석 자체는 코드 의도와 기능을 이해하는 데 도움이 됩니다.

#### 개선이 필요한 부분
- 주석 처리된 `handleNewAlarm` 함수와 `Loading` 컴포넌트의 코드가 일부 삭제되어 가독성이 떨어지는 것 같습니다. 사용되지 않는 코드는 제거하는 것이 좋습니다.
- 주석을 추가하여 기능을 설명하는 것이 좋습니다. 특히, 복잡한 애니메이션의 CSS나 SVG 부분에서는 각 CSS 규칙이나 애니메이션의 의도를 설명하는 주석이 필요합니다.
  
  ```javascript
  // const handleNewAlarm = (newAlarm: Alarm) => {
  //   ...
  //   // 새로운 알람을 추가하고 카운트를 업데이트합니다.
  // }
  ```

### 2. Consistency (일관성)
#### 잘 수행되고 있는 부분
- 전체적으로 JavaScript와 CSS가 분리되어 잘 구조화되어 있습니다. 스타일과 기능이 잘 나누어져 있는 점은 일관성을 보장합니다.

#### 개선이 필요한 부분
- 주석 처리 방식이 일관되지 않습니다. 일관된 주석 스타일을 사용하고, 주석 처리된 코드는 주석이 필요 없는 경우 반드시 제거하세요.
- JavaScript 및 CSS 파일에 대한 스타일 가이드 (예: 세미콜론 여부, 공백 사용 등)를 채택하여 전체 코드를 일관되게 유지하세요.

### 3. Reusability (재사용성)
#### 잘 수행되고 있는 부분
- `handleNewAlarm` 함수와 `Loading` 컴포넌트가 나중에 재사용될 가능성이 높습니다.

#### 개선이 필요한 부분
- 이런 함수와 컴포넌트는 현재 사용되지 않고 있으므로, 관련된 기능을 사용할 수 있는 다른 부분에도 이러한 기능을 통합할 수 있도록 분리하는 것이 좋습니다.
  
### 4. Reliability (신뢰성)
#### 잘 수행되고 있는 부분
- `mockData` 필터링 로직은 명확히 알람을 관리하는 데 유용합니다.

#### 개선이 필요한 부분
- `handleNewAlarm` 함수가 주석 처리되어 있어 런타임 문제가 발생할 수 있습니다. 이를 꼭 사용하게 될 경우 적절한 에러 처리를 포함시켜야 합니다.
  
  ```javascript
  const handleNewAlarm = (newAlarm: Alarm) => {
    if (!newAlarm) throw new Error("Invalid new alarm!");
    // ...
  };
  ```

### 5. Security (보안성)
#### 잘 수행되고 있는 부분
- 현재 코드는 보안 문제를 다루는 부분이 적어 보입니다. 보안성을 고려하여 사용자의 입력 및 알람 생성에 대한 검증 로직을 통합하는 것이 중요합니다.

#### 개선이 필요한 부분
- 알람 메시지와 같은 민감한 데이터가 외부에서 영향을 받을 수 있는 경우, 적절한 검증을 추가하여 SQL Injection과 같은 보안 위험이 없도록 하세요.

### 6. Maintainability (유지보수성)
#### 잘 수행되고 있는 부분
- CSS 스타일 및 JavaScript 로직의 분리로 각 부분의 유지 보수가 용이해 보입니다.

#### 개선이 필요한 부분
- 관련된 기능을 수정하거나 변경해야 할 경우, 주석 처리된 코드만으로는 충분하지 않기 때문에 각 기능별로 명확한 문서화를 통해 변경 이력 및 사용법을 안내할 필요가 있습니다.

### 전체적인 피드백
- 코드 전반에 걸쳐 잘 작성된 부분: 각 기능이 모듈화되어 재사용하기 쉬운 구조입니다. 주석을 통해 코드 의도를 설명하는 시도는 긍정적입니다.
- 개선이 필요한 부분: 주석 처리된 코드의 존재, 적절한 에러 처리, 일관된 주석 처리 형식 등입니다. 코드의 가독성과 신뢰성을 높이기 위해 주석과 코드 구조를 개선해야 합니다.

코드의 모든 변경 사항이 시스템 전체에 미치는 영향을 고려할 때, 유지보수성을 높이기 위한 리팩토링을 적극 고려하여 주시기 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-15 17:10:17.023878', 175, '2024-11-15 17:10:17.023878', 39, '리뷰어로서 제공된 코드를 검토한 결과, 아래와 같은 세부 평가 항목과 피드백을 작성하였습니다.

### 1. Readability (가독성)
**잘 수행된 부분**: 
- 전체적으로 코드의 구조는 깔끔하며, 기능을 분리하여 작성하려는 노력이 보입니다.
- HTML/CSS 섹션에서 `loading-container`와 `water-fill` 클래스명는 그 자체로 의미가 명확하여 CSS의 목적을 쉽게 이해할 수 있습니다.

**개선이 필요한 부분**: 
- 함수 및 변수명을 더 구체적으로 작성하는 것이 좋습니다. 예를 들어, 주석 처리된 `handleNewAlarm` 함수는 무엇을 처리하는지에 대한 추가적인 설명이 필요합니다. 
- 코드 블록 내에 있는 주석이 현재의 상태에서 비활성화되어 보이므로, 이들을 주석으로 처리하면서도 해당 기능의 의도를 구체적으로 설명하는 것이 좋습니다.

```javascript
// const handleNewAlarm = (newAlarm: Alarm) => {
//   // 새로운 알람을 처리하고 알림을 업데이트합니다.
//   setAlarms((prevAlarms) => [newAlarm, ...prevAlarms]);
//   setCount((prevCount) => prevCount + 1);
//   setToastMessage(newAlarm.message);
// };
```

### 2. Consistency (일관성)
**잘 수행된 부분**: 
- 코드 스타일은 일관되게 유지되고 있으며, 유사한 기능의 구조가 통일되어 있는 모습이 좋습니다.
- CSS에서 클래스 네이밍 규칙이 일관되며, 선택자들이 적절하게 정의되어 있습니다.

**개선이 필요한 부분**:
- 주석 처리된 부분이 코드와 비슷한 색으로 작성되어 있으며, 주석의 형식을 통일성 있게 유지하는 것이 좋습니다. 예를 들어, 각 함수의 주석을 통일된 형식으로 작성하세요.

### 3. Reusability (재사용성)
**잘 수행된 부분**: 
- `AlarmButton` 컴포넌트는 독립적으로 작성되어 다른 컴포넌트에서 쉽게 재사용될 수 있을 것 같습니다.

**개선이 필요한 부분**: 
- 주석 처리된 `handleNewAlarm` 함수처럼, 필요한 함수가 필요할 때 주석으로 처리해놓는 것은 재사용성에서 제한적입니다. 이 경우 해당 기능을 실제로 구현하여 재사용할 수 있도록 하세요.

### 4. Reliability (신뢰성)
**잘 수행된 부분**: 
- `setAlarms`와 같은 상태 업데이트 로직은 이전 상태를 기반으로 안전하게 업데이트 하고 있어 좋습니다.

**개선이 필요한 부분**: 
- 주석 처리된 코드가 실행되지 않기 때문에, 이로 인해 발생할 수 있는 예외 상황을 고려한 처리가 완전히 이루어지지 않고 있습니다. 코드의 정상 작동과 예외 처리를 보장하기 위해, 주요 로직에 예외 처리를 추가하십시오.

### 5. Security (보안성)
**잘 수행된 부분**: 
- CSS 부분은 외부 입력이 없으므로 보안 문제에서 초점이 맞춰지지 않습니다.

**개선이 필요한 부분**: 
- `handleNewAlarm` 함수가 알람 메시지를 업데이트하는 수단으로 사용되면서, 해당 메시지가 외부에서 주입될 가능성을 대비한 인증 및 유효성 검사를 추가하는 것이 좋습니다.

### 6. Maintainability (유지보수성)
**잘 수행된 부분**: 
- 컴포넌트형 구조로 인해 유지보수가 용이하도록 작성된 점이 좋습니다.

**개선이 필요한 부분**: 
- 주석 처리된 세부 기능의 구조를 명확히 하고, 각 기능별로 분리하여 더 가독성 있게 유지하세요. 특히 로딩 컴포넌트는 다른 컴포넌트에서 자주 사용될 수 있으니, 이를 독립적인 파일로 작성하는 것이 좋습니다.

```javascript
// Loading.js
const Loading = () => {
  // 로딩 UI를 출력하는 컴포넌트
};

// export default Loading;
```

### 전체적인 피드백:
코드 전반적으로 구조화가 잘 되어 있고, 알림 기능을 처리하는 로직이 깔끔하게 구현되었습니다. 그러나, 잘못 주석 처리된 코드나 필요한 설명이 부족한 부분이 보입니다. 각 기능의 의도와 작동을 명확히 하여 유지보수를 쉽게 하는 것이 중요합니다. 또한, 주석 처리로 인해 예상되는 기능을 놓치는 일이 없도록 실제로 필요한 기능은 활성화하여 코드의 일관성과 재사용성을 높이는 방향으로 개선하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-15 17:19:27.03165', 176, '2024-11-15 17:19:27.03165', 39, '# 코드 리뷰

## 1. Readability (가독성)

### 잘 수행된 부분:
- JavaScript 코드의 구조가 명확하고, 각 기능적으로 나누어진 부분들이 눈에 띄어 이해하기 쉬운 점이 있습니다.
- 코드에 주석이 포함되어 있어, 코드의 맥락을 파악하는 데 도움이 됩니다.

### 개선이 필요한 부분:
- 주석이 주석 처리된 코드에만 포함되어 있고, 현재 활성화된 함수에는 주석이 없어 기능 설명이 부족합니다. `handleNewAlarm` 함수의 주석 처리 부분을 개별 함수로 이동하여 현재 로직에 대한 설명을 추가하는 것이 좋습니다.

```javascript
// 새로운 알림을 처리하고 상태를 업데이트하는 함수입니다.
// 이 함수는 필요할 경우 사용될 수 있습니다.
const handleNewAlarm = (newAlarm: Alarm) => {
    ...
};
```

## 2. Consistency (일관성)

### 잘 수행된 부분:
- 코드 스타일이 일관되며, 프로퍼티와 변수명이 각 기능에 적합하게 설정되어 있습니다.

### 개선이 필요한 부분:
- CSS 주석이 비활성화된 코드와 함께 주석 처리되어 있어 일관성 있게 유지되지 않았습니다. 주석을 정리하여 코드와 관련된 주석들을 명확하게 구분하는 것이 좋습니다.

```css
/* CSS 목표: 로딩 애니메이션을 위한 스타일 정의 */
.loading-container {
    ...
}
```

## 3. Reusability (재사용성)

### 잘 수행된 부분:
- `handleNewAlarm`과 같은 기능이 있는 것으로 보아, 특정 기능이 나누어져 있는 점은 좋습니다.

### 개선이 필요한 부분:
- 주석 처리된 코드를 포함하기보다는, 필요 없는 경우 삭제하거나 별도의 파일로 이동해 모듈화하는 것이 필요합니다. 앞으로 해당 함수가 필요할 경우 실질적으로 복사하여 붙여넣기보다는, 적절한 컴포넌트를 다시 참조할 수 있도록 하십시오.

## 4. Reliability (신뢰성)

### 잘 수행된 부분:
- 상태를 업데이트하는 방식이 React의 규칙을 준수하고 있어, 상태 관리가 잘 이루어지는 것으로 보입니다.

### 개선이 필요한 부분:
- `handleNewAlarm`이 현재 주석 처리되어 있지만, 해당 로직이 언제 필요한지를 명확히 해야 합니다. 예외 상황에 대한 처리가 필요하며, 이를 적절히 구성하여 안정성을 높이는 것이 중요합니다.

```javascript
const handleNewAlarm = (newAlarm: Alarm) => {
    if (!newAlarm) {
        console.error("신규 알림이 존재하지 않습니다.");
        return;
    }
    ...
};
```

## 5. Security (보안성)

### 잘 수행된 부분:
- 데이터 필터링이 잘 되어 있어, 기본적인 보안성을 고려한 점이 좋습니다.

### 개선이 필요한 부분:
- `setToastMessage(newAlarm.message)`와 같은 코드에서 입력 검증이 필요합니다. 사용자의 입력이 안전한지를 확인하는 로직이 추가되어야 합니다.

```javascript
if (typeof newAlarm.message !== ''string'') {
    console.error("메시지 형식이 유효하지 않습니다.");
    return;
}
```

## 6. Maintainability (유지보수성)

### 잘 수행된 부분:
- 함수가 잘 나누어져 있어 기능의 변경이나 추가에 유연하게 대응할 수 있습니다.

### 개선이 필요한 부분:
- 기능의 변경이나 추가에 대한 준비를 위해 모든 함수를 모듈화하고, 가능하다면 컴포넌트를 재사용 가능한 형태로 구조화하는 것이 좋습니다.

```javascript
// 재사용 가능한 알림 처리 함수를 분리하는 것을 고려하십시오.
const AlarmHandler = {
    handleNewAlarm: (newAlarm) => { ... },
    handleAlarmClick: (id) => { ... }
};
```

## 전체적인 피드백
코드 전반적으로 잘 수행하고 있는 부분은 구조적인 접근과 상태 처리 방식이 적절하여 가독성이 높다는 점입니다. 그러나 주석 처리된 코드의 사용과 에러 처리가 부족한 부분은 개선이 필요합니다. 

주석을 추가하여 코드의 의도를 명확히 하고, 불필요한 코드가 담기지 않도록 하여 가독성과 유지 보수성을 높이는 방향으로 나아간다면 매우 훌륭한 코드가 될 것입니다. 이루어지는 코드 변경은 향후 유지보수와 다른 개발자들이 이해하는 데 큰 도움이 될 것입니다. 

또한, 주의 깊은 계획으로 CSS와 관련된 코드가 정상적으로 작동하고 주석도 유용할 수 있도록 정리하는 것을 추천합니다.');
INSERT INTO public.review VALUES ('2024-11-15 17:21:58.12105', 177, '2024-11-15 17:21:58.12105', 39, '코드 리뷰를 요청하신 내용을 바탕으로, 아래와 같이 각 항목별 피드백을 제공합니다. 각 항목에서 잘 수행되고 있는 부분과 개선이 필요한 부분을 자세히 설명드리겠습니다.

### 1. Readability (가독성)
**잘 수행되고 있는 부분:**
- 특정 CSS 클래스와 애니메이션 명칭이 구체적으로 명시되어 있어, 이들이 무엇을 하는지 쉽게 이해할 수 있습니다.
- 주석이 빈 곳에 코드를 주석 처리하여 필요에 따라 쉽게 활성화하거나 비활성화할 수 있는 형태로 소스 코드가 정리되어 있습니다.

**개선이 필요한 부분:**
- 액션 핸들러인 `handleNewAlarm` 함수는 코드에서 주석 처리되었으나, 그 의도를 설명하는 주석이 없습니다. 이 함수가 왜 주석 처리되었는지, 향후 사용할 계획이 있는지에 대한 설명이 필요합니다.
  
```javascript
// const handleNewAlarm = (newAlarm: Alarm) => {
//   // 새로운 알람을 처리하는 함수입니다. 필요한 경우 주석을 해제하여 사용하세요.
//   setAlarms((prevAlarms) => [newAlarm, ...prevAlarms]);
//   setCount((prevCount) => prevCount + 1);
//   setToastMessage(newAlarm.message);
// };
```

### 2. Consistency (일관성)
**잘 수행되고 있는 부분:**
- CSS의 주석 처리 방식이 일관되며, 스텝이 명확하게 구분되어 있습니다.
- JavaScript의 함수 정의와 호출 스타일이 통일성을 가지고 있습니다.

**개선이 필요한 부분:**
- CSS에 대한 주석 작성 방식이 헤더와 컨테이너에 대해 일관되게 제공되지 않았습니다. 코멘트가 필요한 부분에 대해서 추가로 설명을 달아주세요.

```css
/* 이 영역은 로딩 애니메이션을 위한 CSS 스타일입니다. */
.loading-container {
  /* 스타일링 코드 */
}
```

### 3. Reusability (재사용성)
**잘 수행되고 있는 부분:**
- `Loading` 컴포넌트는 독립적인 UI 요소로 잘 정의되어 있습니다.

**개선이 필요한 부분:**
- `handleNewAlarm`은 주석 처리되어 있으므로, 이의 필요성에 대한 명확성을 높이기 위해 코드와 함께 해당 함수를 다른 컴포넌트에서도 사용할 수 있도록 검토해주세요.

### 4. Reliability (신뢰성)
**잘 수행되고 있는 부분:**
- 현재 상태에서 알림을 설정하고 카운트를 업데이트 할 때, 이전 상태를 기반으로 하는 안전한 패턴을 사용하고 있습니다. 

**개선이 필요한 부분:**
- `handleNewAlarm`에서 발생할 수 있는 에러를 처리할 에러 핸들링 로직을 추가하여 안전성을 높이는 것을 고려해야 합니다. 예를 들어, `newAlarm`이 유효한지 체크하는 로직이 있으면 좋습니다.

```javascript
const handleNewAlarm = (newAlarm: Alarm) => {
  if (!newAlarm || !newAlarm.message) {
    console.error("Invalid alarm data");
    return;
  }
  // 나머지 코드...
};
```

### 5. Security (보안성)
**개선이 필요한 부분:**
- 현재 코드에서 직접적으로 민감한 데이터를 처리하는 부분은 보이지 않지만, 주석 처리된 `handleNewAlarm`에서 외부 입력을 기반으로 동작할 경우 SQL 인젝션, XSS와 같은 공격에 대비하기 위해 입력값을 검증하는 것이 중요합니다. 

### 6. Maintainability (유지보수성)
**잘 수행되고 있는 부분:**
- CSS 클래스가 기능에 따라 명확히 구분되어 있어 유지보수에 용이합니다.

**개선이 필요한 부분:**
- `handleNewAlarm`과 같은 주요 비즈니스 로직이 주석 처리된 경우, 이에 대한 문서화가 필요합니다. 이 함수를 재사용할 수 있도록 하는 хранения 과정을 명확히 하고, 다음과 같은 문서 또는 주석으로 사용하는 방법을 안내하는 것이 좋습니다.

```javascript
// handleNewAlarm은 알람을 추가하고 알림 메시지를 설정합니다. 
// 향후 리팩토링할 계획입니다.
```

### 전체적인 피드백
코드는 기본적인 구조와 개념이 잘 잡혀 있습니다. 다만, 주석 처리된 함수와 같은 중요한 기능이 그 목적을 알 수 없다는 것이 아쉬운 점입니다. 각 함수와 로직에 대한 문서화가 필요하며, 가능한 입력 검증 및 에러 핸들링을 통해 더욱 견고한 코드를 만들어 가는 것이 좋겠습니다. 

이러한 개선 사항을 바탕으로 더욱 효율적이고 안정적인 코드로 발전해 나가길 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-15 18:48:32.184367', 178, '2024-11-15 18:48:32.184367', 39, '코드 변경 사항을 검토한 결과, 정확성, 가독성, 효율성, 확장성, 코딩 표준 준수 그리고 잠재적인 버그를 고려하여 피드백을 드리겠습니다.

### 1. 가독성 (Readability)
**잘 수행되는 부분:**
- 코드는 비교적 직관적인 구조를 가지고 있으며, 적절한 함수와 변수를 사용한 부분이 있는 것 같습니다. 예를 들어, `setCount`와 같은 상태 설정 함수는 그 기능을 명확하게 드러냅니다.

**개선이 필요한 부분:**
- 주석을 추가하여 코드의 목적과 기능을 보다 명확하게 설명하는 것이 좋습니다. 특히, 주석이 필요한 부분에 대해 설명을 작성하면 이해하기 쉬워질 것입니다.

```javascript
// 상태에 새 알림 추가 및 카운트 증가함수
const handleNewAlarm = (newAlarm: Alarm) => {
  // ...
};
```

### 2. 일관성 (Consistency)
**잘 수행되는 부분:**
- 코드의 구조와 함수 사용이 일관되었습니다.

**개선이 필요한 부분:**
- CSS 주석 처리된 부분에서 주석 스타일을 개선하고, JavaScript 코드에 대한 주석도 같은 스타일로 통일하는 것이 좋습니다.

```css
/* CSS 코드에 대한 명확한 주석 추가 */
.loading-container {
  /* 전체 화면을 덮는 로딩 컨테이너 */
  position: absolute;
  /* ... */
}
```

### 3. 재사용성 (Reusability)
**잘 수행되는 부분:**
- `handleNewAlarm`과 같은 함수가 잘 분리되어 있어, 필요한 곳에서 쉽게 재사용할 수 있습니다.

**개선이 필요한 부분:**
- 주석 처리된 `Loading` 컴포넌트의 경우, 필요할 경우 재사용 가능한 컴포넌트로 리팩토링할 수 있습니다. 함수를 단일 책임 원칙에 따라 분리하면 더 좋은 구조가 될 것입니다.

```javascript
// 로딩 컴포넌트를 별도로 분리하여 재사용성을 높이기
const Loading = () => {
  // ...
};

// 이후 필요한 곳에서 import하여 사용
```

### 4. 신뢰성 (Reliability)
**잘 수행되는 부분:**
- 상태 업데이트 함수에서 이전 상태를 가져오는 방식은 React의 상태 관리 규칙을 잘 따르고 있습니다.

**개선이 필요한 부분:**
- 주석 처리된 `handleNewAlarm` 함수에 예외 처리 로직을 추가하여, `newAlarm`이 유효한 형식인지 체크하는 것이 좋습니다.

```javascript
const handleNewAlarm = (newAlarm: Alarm) => {
  if (!newAlarm || !newAlarm.message) {
    console.warn(''Invalid alarm'');
    return; // 유효하지 않은 경우 Early Return
  }
  // ...
};
```

### 5. 보안성 (Security)
**잘 수행되는 부분:**
- 현재로서는 알림 메시지를 설정하는 부분에서 특별한 보안 취약점은 보이지 않습니다.

**개선이 필요한 부분:**
- 사용자 입력을 처리하는 부분에 대해 항상 입력 검증을 추가해 주세요. 예를 들어, 알림 메시지가 의도치 않은 HTML 코드 등으로 변조되지 않도록 필터링하거나 이스케이프 처리하는 것이 필요합니다.

```javascript
const safeMessage = escapeHtml(newAlarm.message); // 적절한 HTML 이스케이프 처리
setToastMessage(safeMessage);
```

### 6. 유지보수성 (Maintainability)
**잘 수행되는 부분:**
- 전반적으로 모듈화된 구조가 잘 유지되고 있습니다.

**개선이 필요한 부분:**
- 상수나 자주 변경될 수 있는 값은 따로 관리하는 것이 좋습니다. 예를 들어, 애니메이션 속성은 상수로 분리하여 관리하는 것이 더 나은 접근 방식이 될 것입니다.

```javascript
const ANIMATION_SPEED = ''0.3s'';
// 이후 애니메이션이 필요할 때 ANIMATION_SPEED를 사용하여 일관된 관리
```

### 전체적인 피드백
- 이 코드 변경은 전반적으로 잘 관리되고 있으며, React의 상태 관리 패턴을 적절히 따르고 있습니다. 주석 체계와 에러 처리가 잘 구현된다면, 코드의 신뢰도와 유지보수성이 더욱 높아질 것입니다. 
- 중점적으로 개선해야 할 부분은 주석 추가와 더불어 입력 검증, 예외 처리입니다. 이 부분만 강화된다면 코드의 품질이 크게 향상될 것으로 보입니다. 
- 코드가 잘 작성된 부분에 대해서 긍정적인 피드백을 드리며, 향후 이러한 개선 방안을 고려해주시기 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-15 19:13:12.217373', 179, '2024-11-15 19:13:12.217373', 39, '코드 리뷰를 시작하겠습니다. 주어진 코드는 React의 AlarmButton 컴포넌트와 관련된 것으로 보이며, 변경 사항을 중심으로 가독성, 일관성, 재사용성, 신뢰성, 보안성, 유지보수성의 관점에서 평가하겠습니다.

---

### 1. **Readability (가독성)**

- **잘 수행된 부분**
  - 상태 관리 및 이벤트 핸들링에 사용하는 변수명(`setCount`, `setAlarms`, `setToastMessage`)이 적절하여 기능이 명확히 드러납니다. 
  - 하지만 주석이 필요한 부분이 있습니다. 주석 처리된 `handleNewAlarm` 함수가 주석 처리되어 있어서 왜 주석 처리했는지 이해하기 힘듭니다.

- **개선이 필요한 부분**
```javascript
// move the comment to a more descriptive location
// Handle incoming alarms when a new alarm arrives
const handleNewAlarm = (newAlarm: Alarm) => {
  setAlarms((prevAlarms) => [newAlarm, ...prevAlarms]);
  setCount((prevCount) => prevCount + 1);
  setToastMessage(newAlarm.message);
};
```
- 설명을 추가해 함수가 현재 주석 처리된 이유를 명확히 하고 필요한 경우 함수의 목적도 설명하는 주석을 작성하는 것이 좋습니다. 

---

### 2. **Consistency (일관성)**

- **잘 수행된 부분**
  - 파일 구조와 코드 스타일이 전반적으로 일관되며, JSX 및 CSS 코드와 함께 사용할 수 있도록 구성되어 있습니다.

- **개선이 필요한 부분**
```javascript
// Ensure naming conventions are consistent
const loadingContainerClass = "loading-container"; // define your className using camelCase
```
- CSS 클래스명을 camelCase로 유지하면 JavaScript와의 일관성을 높이고 혼란을 줄일 수 있습니다. 통일된 네이밍 규정을 사용하는 것이 중요합니다.

---

### 3. **Reusability (재사용성)**

- **잘 수행된 부분**
  - AlarmButton 컴포넌트는 상태 및 동작을 잘 포장하여 다른 컴포넌트에서 간편하게 재사용할 수 있습니다.

- **개선이 필요한 부분**
```javascript
// Consider defining handleNewAlarm as a separate utility function if it will be reused
const addNewAlarm = (newAlarm: Alarm) => {
  // Logic to handle adding an alarm
};
```
- `handleNewAlarm` 기능이 다른 컴포넌트에서도 필요할 수 있으므로, 별도의 유틸리티 함수로 정의할 수 있습니다.

---

### 4. **Reliability (신뢰성)**

- **잘 수행된 부분**
  - 상태 업데이트와 알람 처리 로직이 명확하여 의도한 대로 작동할 가능성이 높습니다.

- **개선이 필요한 부분**
```javascript
// Add error handling for setAlarms
const handleNewAlarm = (newAlarm: Alarm) => {
  try {
    setAlarms((prevAlarms) => [newAlarm, ...prevAlarms]);
    setCount((prevCount) => prevCount + 1);
    setToastMessage(newAlarm.message);
  } catch (error) {
    console.error("Failed to handle new alarm", error);
  }
};
```
- 예외 처리 구문을 추가해 오류 발생 시 이를 잡아내고 로그를 출력하는 것이 좋습니다. 이는 개발 및 유지보수에 큰 도움이 됩니다.

---

### 5. **Security (보안성)**

- **잘 수행된 부분**
  - 기본적인 보안 문제가 잘 처리되고 있으나, 추가적인 입력 검증이 필요합니다.

- **개선이 필요한 부분**
```javascript
const handleNewAlarm = (newAlarm: Alarm) => {
  if (!newAlarm || typeof newAlarm.message !== ''string'') {
    console.error("Invalid alarm data");
    return;
  }
  // Proceed with adding the alarm
};
```
- 새 알람 객체가 유효한지 확인하는 검증 로직을 추가해야 합니다. 이는 데이터 무결성을 유지하고 예기치 않은 오류를 방지하는 데 도움이 됩니다.

---

### 6. **Maintainability (유지보수성)**

- **잘 수행된 부분**
  - 컴포넌트가 기능적으로 잘 나뉘어져 있고, 명확하게 작동합니다.

- **개선이 필요한 부분**
```javascript
// Ensure CSS is modularized
import ''./Loading.css''; // Ensure loading styles are in a single file
```
- CSS 파일을 별도로 분리해서 재사용 가능성을 높여야 합니다. 이는 다양한 컴포넌트에서 스타일을 적용할 수 있도록 해서 유지보수성을 개선합니다.

---

### **전체적인 피드백**

주어진 코드가 잘 수행되고 있는 부분은 명확한 상태 관리를 통해 사용자 인터랙션에 대응하는 부분과, 잘 정의된 기능을 통해 재사용 가능하다는 점입니다. 그러나 주석과 예외 처리, 데이터 검증과 같은 세부적인 부분에서 개선이 필요합니다. 아래와 같은 개선 사항을 제안합니다:

- 코드 내 주석의 추가로 이해도를 높이고, 나중에 변경 시 더 쉽게 유지보수할 수 있도록 하는 것이 중요합니다.
- 예외 처리 및 입력 검증을 통해 코드의 안정성과 보안성을 높이길 바랍니다. 

이러한 개선 사항을 반영한다면 코드의 품질과 유지보수성을 더욱 높일 수 있을 것입니다.');
INSERT INTO public.review VALUES ('2024-11-15 19:15:58.724988', 180, '2024-11-15 19:15:58.724988', 48, '코드를 리뷰해보겠습니다. 주어진 변경사항에는 `ChannelCodeResponse` 클래스를 업데이트하고 `ChannelCode` 엔티티에 `imageUrl` 속성을 추가하는 내용이 포함되어 있습니다. 이 변경사항은 관련된 클래스에서의 변화를 야기하며 설치할 수 있는 몇 가지 고려사항과 제안사항을 제시하겠습니다.

### 1. Readability (가독성)
- **코드 가독성 수준**: 변경된 코드의 가독성은 전반적으로 양호합니다. 필드 및 메서드의 이름이 의미가 명확하고, 시멘틱적으로 적절하게 작성되어 이해하기 쉽게 제출되었습니다.
- **주석 추가 여부**: `ChannelCodeResponse.of()` 메서드와 `ChannelCode`에 대한 클래스 스코프에서 사용자에게 이 변경이 어떤 의미인지에 대해 간단한 주석을 추가하면 좋겠습니다. 예를 들어, `imageUrl`이 추가된 이유나 사용법에 대한 설명을 추가하여 가독성을 높일 수 있습니다.

```java
public record ChannelCodeResponse(Long channelCodeId, String channelName, String imageUrl) {
    // ChannelCode 객체를 ChannelCodeResponse로 변환하는 메서드
    public static ChannelCodeResponse of(ChannelCode channelCode) {
        return new ChannelCodeResponse(
                channelCode.getId(), channelCode.getName().name(), channelCode.getImageUrl());
    }
}
```

### 2. Consistency (일관성)
- **일관성 유지**: 코드 변경은 전반적으로 일관성 있게 이루어졌습니다. 하지만 `ChannelCode` 클래스에서 새로운 필드 `imageUrl`의 접근자 메서드가 누락되었으므로 이를 추가하여 클래스와 접근자 메서드의 일관성을 유지해야 합니다. 현업에서는 모든 속성이 항상 접근 가능하도록 getter 메서드를 작성하는 것이 일반적입니다.

```java
public class ChannelCode {
    // ...
    public String getImageUrl() {
        return imageUrl;
    }
}
```

### 3. Reusability (재사용성)
- **재사용 가능성 평가**: 코드의 재사용성은 좋습니다. `ChannelCodeResponse`는 특정 기능을 갖고 있기 때문에 필요에 따라 다른 서비스나 컨트롤러에서 쉽게 재사용될 수 있습니다. 코드에서 `ChannelCode`와의 관계도 명확히 되어 있어, 나중에 각종 코드 개선 시에도 쉽게 수정 가능합니다.

### 4. Reliability (신뢰성)
- **예외 처리 및 오류 검출**: 현재 변경된 코드 내에서 예외 처리 로직이 부족해 보입니다. `imageUrl` 속성을 참조하는 과정에서 null 값이 올 수 있다는 점을 고려해야 합니다. 이 부분에 대한 예외 처리를 추가하고, `imageUrl`이 null일 경우의 처리를 명확히 해야 합니다.

```java
if (channelCode.getImageUrl() == null) {
    throw new IllegalStateException("Image URL cannot be null");
}
```

### 5. Security (보안성)
- **보안성 수준**: 보안적인 측면의 검토는 현재 코드에서 명백하게 보이는 저장된 URL이나 데이터의 반환이 없으므로 특별한 이슈가 없습니다. 하지만 `webhookUrl`이나 유사한 외부 데이터에 대한 입력 검증 메커니즘이 필요할 수 있으므로, 사용자가 조작할 수 없도록 데이터 출력과 저장시에 항상 sanitize 과정을 포함해야 합니다.

### 6. Maintainability (유지보수성)
- **유지보수성을 위한 고려**: 새로운 속성을 추가하면서 코드의 모듈화와 단일 책임 원칙이 잘 지켜지고 있다는 점이 좋습니다. 그러나 일반적으로 클래스를 수정하면서도 데이터의 불변성을 지키기 위해 `record`에서 immutable 속성만 수용해야 하므로, 생성자나 메서드의 불변성에 유의할 필요가 있습니다.

### 전체적인 피드백
- **잘 수행하고 있는 부분**: 새로운 속성 추가와 관련 메서드 통합이 효과적으로 이루어졌습니다. 또한, 메서드 이름들은 명확하게 기술적 역할을 잘 설명하고 있어 긍정적입니다.
- **개선이 필요한 부분**: 예외 처리, 주석 추가 및 Getter 메서드 추가가 필요합니다. 즉각적인 코드 변경을 고려할 수 있는 몇 가지 접근 방식을 제안하며, 최종적으로 모든 코드는 안전성을 높이고, 일관성을 유지하는 것이 중요합니다.

이러한 피드백을 바탕으로, 변경사항을 검토하고 개선하는 방향으로 나아가시길 바랍니다. 관리와 유지보수가 용이하도록 지속적인 개선과 동기화를 권장합니다.');
INSERT INTO public.review VALUES ('2024-11-15 19:27:19.000219', 181, '2024-11-15 19:27:19.000219', 49, '코드를 검토한 결과, 여러 긍정적인 요소가 있으며 동시에 개선이 필요한 부분도 존재합니다. 아래는 각 항목에 대한 구체적인 피드백입니다.

### 1. Readability (가독성)

**잘 수행된 부분:**
- 전반적으로 코드가 잘 구조화되어 있어 이해하기 쉽습니다. 특히 `apiRequests` 객체와 `Notification` API 호출 부분은 직관적이고 명확합니다.
  
**개선이 필요한 부분:**
- `fetchNotifications`와 `fetchUnreadCount` 함수에서 API 호출 결과를 핸들링할 때, 성공적인 응답과 오류 처리 분리되는 것이 좋습니다. 예외처리를 추가하여 오류 발생 시의 명확한 대응이 가능하게 해야 합니다.
  
```javascript
const fetchNotifications = async () => {
  if (!projectId) return;
  try {
    const response = await Notification.getNotification(projectId);
    if (response.data) {
      setAlarms(response.data);
    }
  } catch (error) {
    console.error(''Failed to fetch notifications'', error);
    // 사용자에게 알림을 표시할 수도 있음
  }
};
```

### 2. Consistency (일관성)

**잘 수행된 부분:**
- 변수명 및 함수명이 일관되게 사용되며, 코드 스타일도 통일되어 있습니다. `CamelCase` 및 `PascalCase`를 적절히 사용하고 있습니다.

**개선이 필요한 부분:**
- JSX에서 CSS 클래스를 정의하는 부분에서 `text-${textColor}`와 같은 문자열 보간 사용이 비일관적입니다. 이를 고정 문자열로 변경하여 명확한 클래스명을 사용하는 것이 좋습니다.

```javascript
const textColor = isOpen || active ? ''text-secondary'' : ''text-primary-500''; // 변수명 사용
...
className={`font-pretentard flex flex-row items-center rounded-[3px] w-full h-10 bg-[#F5F7FA] ${textColor} px-3 py-2 select-none hover:bg-[#ebecf0] hover:${textColor}`}
```

### 3. Reusability (재사용성)

**잘 수행된 부분:**
- `apiRequests`와 같은 HTTP 요청 함수를 재사용하고 있어 유연성을 높였습니다.

**개선이 필요한 부분:**
- `Notification` API를 호출하는 로직을 더 독립적이고 재사용 가능하게 리팩토링할 수 있습니다. 이를 통해 다른 컴포넌트에서도 사용할 수 있도록 함수를 분리할 수 있습니다.

```javascript
const getNotificationByProjectId = async (projectId) => {
  try {
    const response = await Notification.getNotification(projectId);
    return response.data;
  } catch (error) {
    throw new Error(''Failed to fetch notifications'');
  }
};
```

### 4. Reliability (신뢰성)

**잘 수행된 부분:**
- API 호출 후 응답 처리 방식이 잘 구성되어 있습니다. 

**개선이 필요한 부분:**
- API 호출시 발생하는 잠재적 에러를 처리하는 로직이 부족합니다. API가 실패할 경우 사용자에게 알릴 수 있는 피드백을 제공하는 것이 필요합니다.

```javascript
const handleAlarmClick = async (id: string) => {
  try {
    await Notification.patchNotificationReadStatus(id);
    setToastMessage(''알림이 읽음 상태로 변경되었습니다.'');
  } catch (error) {
    console.error(''Failed to update alarm read status'', error);
    setToastMessage(''알림 상태 변경에 실패했습니다.'');
  }
};
```

### 5. Security (보안성)

**잘 수행된 부분:**
- 사용자 입력을 다루는 부분에서는 주의가 필요하며, `projectId`가 없는 경우를 체크하는 점은 보안상 올바른 접근입니다.

**개선이 필요한 부분:**
- API 요청 시, URL에 직접 변수를 연결하는 것보다는 `encodeURIComponent`를 사용하여 보안성을 높이는 것이 좋습니다. 이로 인해 인젝션 공격의 위험이 줄어듭니다.

```javascript
const response = await Notification.getNotification(encodeURIComponent(projectId));
```

### 6. Maintainability (유지보수성)

**잘 수행된 부분:**
- UseEffect 훅의 사용이 명확하고 의존성을 잘 관리하고 있어 유지보수성이 좋습니다.

**개선이 필요한 부분:**
- 여러 군데에서 API 호출이 중복되고 있기 때문에 중복 코드를 함수로 추출하여 DRY(중복을 피하라) 원칙을 지켜야 합니다. 각 API 호출을 처리하는 유틸리티 함수를 만드는 것이 좋습니다.

```javascript
const fetchApiData = async (apiCall) => {
  try {
    const response = await apiCall();
    return response.data;
  } catch (error) {
    console.error(''API call failed'', error);
    throw error;
  }
};
```

### 전체적인 피드백

- **긍정적인 측면:** 전체적으로 구조가 잘 되어있고, 가독성이 높은 코드입니다. API 호출과 응답 처리 방식이 잘 이루어져 있어 회복 가능성이 높습니다.
  
- **개선이 필요한 측면:** 예외 처리를 더 강화하고, 보안과 유지 보수성을 높이기 위한 함수 분리 및 재사용성 증대에 주의를 기울일 필요가 있습니다.

이러한 개선 사항을 적용함으로써 코드는 더욱 매끄러워지고, 미래에 생길 수 있는 문제에 대한 방어력이 높아질 것입니다. 코드 리뷰를 통해 이러한 세부 사항을 주의 깊게 고려하는 것은 코드 품질을 향상시키는 데 큰 도움이 됩니다.');
INSERT INTO public.review VALUES ('2024-11-15 19:30:46.14682', 182, '2024-11-15 19:30:46.14682', 49, '## 코드 리뷰 피드백

### 1. **Readability (가독성)**
- **잘 수행된 부분**: 전체적으로 변수명과 함수명이 의미를 잘 전달하고 있습니다. 예를 들어, `fetchNotifications`, `patchNotificationReadStatus` 등은 함수의 역할을 명확히 설명합니다. 또한, `projectId` 같은 변수명은 그 용도를 쉽게 이해할 수 있게 해 줍니다.
- **개선사항**: 몇몇 곳에서 주석이 부족합니다. 특히, 중요한 로직이 포함된 부분에 대한 주석을 추가하면 코드를 처음 보는 사람도 로직을 쉽고 빠르게 이해할 수 있을 것입니다. 예를 들어, `fetchNotifications`와 `fetchUnreadCount` 함수의 동작 방식에 대한 간단한 설명을 추가하는 것을 권장합니다.

```javascript
// 알림을 가져오는 비동기 함수
const fetchNotifications = async () => {
    ...
};

// 읽지 않은 알림 수를 가져오는 비동기 함수
const fetchUnreadCount = async () => {
    ...
};
```

### 2. **Consistency (일관성)**
- **잘 수행된 부분**: 코드 전반적으로 스타일이 일관되며, 들여쓰기는 2칸으로 통일되어 있습니다. 또한, 변수를 선언할 때 `const`와 `let`의 사용이 적절하게 이루어지고 있습니다.
- **개선사항**: 컴포넌트 내부에서 사용되는 CSS 클래스들이 하드코딩되어 있습니다. 일관성을 유지하기 위해 스타일을 상수로 정의하거나 CSS 모듈, 또는 Styled Components와 같은 방법을 사용하여 통일성 있게 관리하면 가독성이 더욱 향상될 것입니다.

```javascript
const bgColor = isOpen || active ? ''bg-[#ebecf0]'' : ''bg-[#F5F7FA]''; 
// 대신에 상수로 정의
const styles = {
    activeBackground: ''bg-[#ebecf0]'',
    inactiveBackground: ''bg-[#F5F7FA]'',
};

const className = isOpen || active ? styles.activeBackground : styles.inactiveBackground;
```

### 3. **Reusability (재사용성)**
- **잘 수행된 부분**: API 요청 부분이 `apiRequests` 객체로 잘 encapsulated 되어 있습니다. 이로 인해 다른 컴포넌트에서도 쉽게 API 요청을 재사용할 수 있습니다.
- **개선사항**: 알림 목록과 읽지 않은 알림 수를 가져오는 로직이 각기 다른 `useEffect`에 나눠져 있습니다. 이를 하나의 Custom Hook으로 통합할 수 있습니다. 이렇게 하면 코드 중복을 피하고 컴포넌트 내에서의 책임을 분리할 수 있습니다.

```javascript
const useNotifications = (projectId) => {
    const [alarms, setAlarms] = useState([]);
    const [count, setCount] = useState(0);
  
    useEffect(() => {
        if (!projectId) return;
        const fetchData = async () => {
            const notiResponse = await Notification.getNotification(projectId);
            setAlarms(notiResponse.data);
            const unreadResponse = await Notification.getUnreadNotificationCount(projectId);
            setCount(unreadResponse.data.unreadCount);
        };
        fetchData();
    }, [projectId]);
  
    return { alarms, count };
};
```

### 4. **Reliability (신뢰성)**
- **잘 수행된 부분**: API 요청 시 비동기 처리가 잘 이루어지며, 오류에 대한 기본적인 콘솔 로그가 존재합니다. 예외가 발생할 경우 추적이 가능하도록 되어 있습니다.
- **개선사항**: API 요청 시에 실제 오류를 처리하는 로직이 부족합니다. `try-catch` 블록을 활용하여 실패 시 사용자에게 적절한 경고 메시지를 표시하거나 시스템 로그에 오류를 기록하는 기능을 추가해야 합니다.

```javascript
try {
    const response = await Notification.getNotification(projectId);
    if (response.data) {
        setAlarms(response.data);
    }
} catch (error) {
    console.error("Error fetching notifications:", error);
    alert("귓속말: 알림을 가져오는 데 실패했습니다."); // 사용자에게 알림
}
```

### 5. **Security (보안성)**
- **잘 수행된 부분**: `EventSource`와 같은 실시간 데이터 스트리밍을 사용하고 있으나, API 호출 시 `projectId`를 쿼리에 추가하는 방식이 안전합니다.
- **개선사항**: API 요청 시에 사용자 입력에 대한 유효성을 검사하는 코드가 없습니다. 입력 값이 서버에 보내지기 전에 검사하여 보안 취약점을 예방해야 합니다. 예를 들어, `projectId`의 형식이나 유효성을 체크하여 잘못된 값이 전달되지 않도록 해야 합니다.

```javascript
if (!isValidProjectId(projectId)) {
    console.error("Invalid project ID:", projectId);
    return; // 유효하지 않은 경우 추가 작업 중단
}
```

### 6. **Maintainability (유지보수성)**
- **잘 수행된 부분**: 코드에 주요 기능들이 잘 분리되어 있고, 각각의 기능에 대한 로직이 명확해 수정이 용이하도록 작성되었습니다.
- **개선사항**: API 요청 로직, 상태 관리, UI 관련 로직 각각을 더 세분화하여 파일로 나누면 장기적으로 코드를 유지보수하는 데에 큰 도움이 될 것입니다. 예를 들어, `apiRequests`와 상태 관리 함수를 별도의 파일로 분리하여 관리하면 모듈화가 이루어집니다.

```javascript
// api/notificationApi.ts
export const NotificationApi = {
    getNotifications: ...
};

// hooks/useNotifications.ts
const useNotifications = () => { ... };
```

### **전체적인 피드백**
코드 전반적으로 **구조가 잘 되어 있으며** 가독성이 높은 편입니다. API 요청을 모듈화하여 재사용 가능한 형태로 잘 작성하였습니다. 그러나 **오류 처리 및 주석 표시**, **코드 모듈화** 등에서 개선해야 할 부분이 발견되었습니다. **기술 부채를 줄이고 유지보수를 용이하게 할** 수 있는 여러 방법을 제안하였으므로, 이를 반영하여 코드를 더욱 발전시킬 수 있기를 바랍니다. 잘 하셨습니다!');
INSERT INTO public.review VALUES ('2024-11-15 19:45:01.439312', 183, '2024-11-15 19:45:01.439312', 48, '전체적인 평가를 바탕으로 코드의 나열된 항목별 피드백을 다음과 같이 제공합니다.

### 1. Readability (가독성)
- **잘 수행된 부분**: 코드에서 사용된 `ChannelCodeResponse.of()`와 같은 메소드명은 그 기능의 의도를 잘 전달합니다. 또한, 클래스와 필드명도 적절한 의미를 지니고 있어 이해하기 쉽습니다.
- **개선 필요 부분**: `imageUrl`이라는 새로운 필드를 추가하면서 해당 필드에 대한 주석을 추가하는 것이 좋습니다. 주석은 필드의 역할을 설명해 주어 가독성을 향상시킵니다. 다음과 같이 추가해보세요.
    ```java
    private String imageUrl; // 채널 코드와 관련된 이미지 URL
    ```

### 2. Consistency (일관성)
- **잘 수행된 부분**: 전체적으로 코드 스타일이 일관되게 유지되고 있으며, 필드를 선언하는 순서도 일관적입니다.
- **개선 필요 부분**: 클래스를 정의할 때 필드의 접근 제어자를 명확히 하는 것이 좋습니다. 특히 `ChannelCode` 클래스에서 `ChannelType name;`이 접근 제어자가 인식되지 않아 주의가 필요할 수 있습니다. 접근 제어자를 명시해 보세요.

    ```java
    private ChannelType name; // 채널 코드의 타입
    ```

### 3. Reusability (재사용성)
- **잘 수행된 부분**: `ChannelCodeResponse`가 `ChannelCode` 객체를 인자로 받는 정적 메소드를 사용하는 방식은 재사용성을 증가시키는 좋은 설계입니다.
- **개선 필요 부분**: `ChannelCodeResponse`의 생성자가 `ChannelCode` 객체에 의존하고 있으므로, 다른 유형의 객체를 추가할 수 있는 메소드를 오버로드하여 재사용성을 높이는 방법을 고려해보세요. 

### 4. Reliability (신뢰성)
- **잘 수행된 부분**: `RuntimeException`으로 전환하는 방식은 예외 처리의 일관성을 잘 유지하고 있습니다.
- **개선 필요 부분**: JSON 파싱이나 데이터베이스 접근 시 발생할 수 있는 예외 상황에 대한 처리가 부족합니다. 각종 예외에 대한 구체적인 핸들러를 추가하여 코드가 어떠한 오류 상황에서도 잘 작동할 수 있도록 구조를 확장하는 것이 좋습니다.

    ```java
    catch (JsonProcessingException e) {
        log.error("JSON 변환 실패", e);
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid JSON input", e);
    }
    ```

### 5. Security (보안성)
- **잘 수행된 부분**: URL을 처리하는 부분에서 적절한 검증 로직이 추가되어 있는지를 확인해야 합니다. 특히 외부 시스템과 통신할 때는 보안이 매우 중요합니다.
- **개선 필요 부분**: `webhookUrl`과 같은 외부에서 받아오는 데이터에 대해 엄격한 입력 검증을 추가해야 합니다. 이를 통해 SQL 인젝션이나 XSS 공격을 방지할 수 있습니다.

### 6. Maintainability (유지보수성)
- **잘 수행된 부분**: 각 메소드가 명확하게 나누어져 있어 좋은 유지보수성을 보여줍니다. 메소드명이 기능을 잘 설명하고 있어 유지보수 시 편리합니다.
- **개선 필요 부분**: `addWebhookChannel` 메소드와 같은 비즈니스 로직이 다른 서비스에 추가로 위임될 수 있는지를 검토하여 더 많은 기능 분리와 단일 책임 원칙을 적용하는 것이 좋습니다. 예를 들어, `WebhookChannel` 객체의 생성 로직을 별도의 유틸리티 클래스로 분리할 수 있습니다.

### 전체적인 피드백
코드는 전반적으로 잘 작성되어 있으며, 객체지향의 원칙을 잘 준수하고 있습니다. 특히, 데이터의 주고받음을 통해 발생할 수 있는 여러 상황에 대해 적절히 처리하려는 모습이 인상적입니다. 그러나 개선할 부분은 확실히 존재하며, 특히 예외 처리와 보안 점검에 더 많은 신경을 쓰는 것이 필요합니다.

이러한 개선 사항을 반영한다면 가독성, 유지보수성, 보안성이 높아져 코드 품질이 더욱 향상될 것입니다. 앞으로도 이러한 방향으로 진행해 주시면 좋겠습니다.');
INSERT INTO public.review VALUES ('2024-11-16 14:23:15.308644', 184, '2024-11-16 14:23:15.308644', 50, '코드 리뷰를 아래의 평가 항목에 따라 진행하겠습니다. 각 항목에서 잘 수행되고 있는 부분과 개선이 필요한 부분을 구체적으로 설명하겠습니다.

### 1. Readability (가독성)
**잘 수행하고 있는 부분:**
- 변수명 및 함수명이 대부분 의미가 있고, 코드의 의도를 잘 드러냅니다. 특히 UI 관련 코드의 경우, 각 컴포넌트의 목적이 클리어하게 드러나 있습니다.

**개선사항:**
- 일부 함수 내에서 사용되는 임시 변수나 상수에 대해 더 명확한 이름을 붙이면 좋습니다. 
- 예를 들어 `fetchNotifications`와 같은 함수는 무엇을 반환하는지에 대한 의미가 강화를 위해 주석을 추가하는 것이 좋습니다. 

```javascript
// Fetches notifications for the given projectId
const fetchNotifications = async () => {
  if (!projectId) return; // Check if projectId is not defined
  const response = await Notification.getNotification(projectId);
  // Handle response data
};
```

### 2. Consistency (일관성)
**잘 수행하고 있는 부분:**
- JSX와 CSS 클래스 이름 사용에서 일관성을 유지하고 있습니다.
- Promise.all을 사용하여 비동기 요청을 효율적으로 처리하는 등의 일관된 코딩 스타일이 돋보입니다.

**개선사항:**
- 스타일 처리 부분에서 inline style과 CSS 클래스 처리가 섞여 있습니다. 이를 일관되게 유지하기 위해 CSS 모듈이나 styled-components를 고려할 수 있습니다.
- `CommonButton` 사용 시, props 명세가 일관적이지 않으므로 더 명확한 타입을 정의하는 것이 좋습니다.

### 3. Reusability (재사용성)
**잘 수행하고 있는 부분:**
- `CommonButton`과 `LabelButton` 같은 컴포넌트를 잘 캡슐화하여 재사용할 수 있도록 디자인했습니다.

**개선사항:**
- 현재 컴포넌트가 특정한 UI와 비즈니스 로직에 한정되어 있는지 검토하고, 재사용할 수 있는 공통 기능을 추출해내면 좋겠습니다.
- 예를 들어 색상을 다양하게 조정 가능한 `LabelButton`의 경우, 종류를 쉽게 추가할 수 있도록 제너릭하게 만드는 방법을 고려할 수 있습니다.

### 4. Reliability (신뢰성)
**잘 수행하고 있는 부분:**
- 비동기 데이터 요청과 네트워크 에러 핸들링 부분이 잘 구현되어 있습니다. 

**개선사항:**
- API 호출 시 오류에 대한 처리가 누락된 것 같습니다. Promise.catch()를 사용하여 오류를 관리하는 코드를 추가해야 합니다.

```javascript
const fetchNotifications = async () => {
  try {
    const response = await Notification.getNotification(projectId);
    if (response.data) {
      setAlarms(response.data);
    }
  } catch (error) {
    console.error("Error fetching notifications:", error);
    // 사용자에게 에러 메시지를 표시하는 로직 추가
  }
};
```

### 5. Security (보안성)
**잘 수행하고 있는 부분:**
- 사용자 입력에 대한 기본적인 검증이 이루어지고 있습니다.

**개선사항:**
- API로 전송하는 데이터는 항상 검증 및 필터링하여 잠재적 공격으로부터 시스템을 보호해야 합니다. 예를 들어, `searchKeyword`가 사용되기 전 정규 표현식을 통해 필터링하거나 escape 처리할 필요성이 있습니다.

```javascript
const handleSearch = () => {
  const sanitizedKeyword = sanitize(searchKeyword); // 이 함수를 통해 XSS 방지
  // API call with the sanitizedKeyword
};
```

### 6. Maintainability (유지보수성)
**잘 수행하고 있는 부분:**
- 컴포넌트의 구조가 명확하고 각 컴포넌트가 모듈화되어 있습니다.

**개선사항:**
- 비즈니스 로직을 더 명확하게 나누고, 각 컴포넌트의 책임을 단일화하는 방향으로 코드를 refactor 할 수 있습니다.
- `fetchMergeRequests`와 같은 비즈니스 로직을 별도의 훅으로 정리할 수 있다면, 그 코드의 유지 보수성과 테스트 용이성이 크게 향상됩니다.

```javascript
// Custom hook to handle fetching merge requests
const useFetchMergeRequests = (projectId, currentStatus, keyword) => {
  const [mergeRequests, setMergeRequests] = useState([]);
  const fetchMergeRequests = useCallback(async () => {
    // 코드 생략
  }, [projectId, currentStatus, keyword]);
  return { mergeRequests, fetchMergeRequests };
};
```

### 전체적인 피드백
코드 전반적으로 기능적으로 잘 구현되어 있으며, 가독성과 일관성 측면에서도 나쁘지 않습니다. 특히 비동기 요청에 대한 처리가 깔끔하게 작성되어 있어 긍정적인 평가를 보냅니다. 그러나 몇 가지 예외 처리 및 보안 측면에서 개선이 필요하며, 기능의 재사용성을 높이기 위한 리팩토링이 이루어져야 합니다. 동료와 함께 리뷰를 통해 발전하는 기회로 삼아 향후 코드의 유지 보수성을 높이기를 바랍니다.');
INSERT INTO public.review VALUES ('2024-11-16 14:35:41.576794', 185, '2024-11-16 14:35:41.576794', 52, '### 전체적인 피드백

코드 변경사항 전반에 걸쳐 명확한 개선이 이루어졌습니다. 특히, 코드의 **가독성**, **효율성**, 그리고 **재사용성**이 향상되었으며, 상수화를 통해 하드코딩을 피하고 변경사항의 유연성을 높였습니다. 그러나 몇 가지 부분에서 추가적인 개선이 필요합니다. 아래에서 각 평가 항목에 대한 세부적인 피드백을 제공하겠습니다.

### 1. Readability (가독성)

**잘 수행된 부분:**
- 변수명에 대한 명명 규칙이 일관되며, 의미가 명확합니다. 예를 들어, `BEST_MERGE_REQUEST_TARGET_COUNT`는 해당 상수가 어떤 용도로 사용되는지를 잘 표현하고 있습니다.
- 예외 처리를 위한 `try-catch` 문을 추가하여 에러 발생 시 로깅을 통해 문제를 진단할 수 있도록 하였습니다.

**개선 제안:**
- **주석의 필요성:** 주석은 코드의 의도와 동작을 설명하는 데 중요한 역할을 합니다. 하지만 일부 주석은 필요 없거나 너무 기본적인 설명일 수 있습니다. 예를 들어, 다음과 같은 부분은 불필요한 주석이 될 수 있습니다.

  ```java
  // DB에서 3회 이상 BestMrHistory가 쌓인 사용자 중, 이미 뱃지를 가진 사용자를 제외한 사용자 조회
  ```

  - 개선 방안:
    - 주석을 제거하거나 더 유용한 설명으로 대체하십시오.
    - 더 복잡한 로직에 대한 주석은 남기고, 간단한 코드에는 주석을 지우는 것이 좋습니다.

### 2. Consistency (일관성)

**잘 수행된 부분:**
- 클래스와 메소드 이름은 CamelCase 규칙을 준수하고 있습니다.
- 코드 포맷이 일관되며, 적절한 공백과 인덴트가 적용되어 있습니다.

**개선 제안:**
- **상수 명명 규칙:** Java에서 상수는 일반적으로 대문자와 언더스코어(`_`)로 구성됩니다. 예를 들면, `PROMTPT_UPDATE_TARGET_COUNT`는 `PROMPT_UPDATE_TARGET_COUNT`로 수정할 수 있습니다.

### 3. Reusability (재사용성)

**잘 수행된 부분:**
- 코드의 여러 부분에서 중복 코드가 제거되었으며, 총 사용자 배지를 조회하는 부분은 별도의 메소드로 잘 분리되어 있습니다.
- `userRepository.findAllByIds(newBadgeUserIds)`와 같은 메소드를 통해 재사용성을 강화했습니다.

**개선 제안:**
- 특정 로직이 여러 메소드에 분산되어 있을 경우, 공통 로직을 별도의 유틸리티 클래스로 분리하는 것이 좋습니다. 예를 들어, `findUsersWithBadges`와 같은 메소드를 만들어 사용할 수 있습니다.

### 4. Reliability (신뢰성)

**잘 수행된 부분:**
- 예외 처리를 통해 가능한 오류를 포착하고 로그를 남기도록 개선하였습니다.

**개선 제안:**
- 더 세부적인 예외 처리가 필요할 수 있습니다. 현재 모든 예외를 한 번에 캐치하고 로깅하는 방식은 장기적인 유지보수에 도움되지 않으므로, 특정 예외에 대해 맞춤형 처리를 고려하십시오.
  
  ```java
  } catch (SomeSpecificException e) {
      log.error("Specific error message: {}", e.getMessage());
  }
  ```

### 5. Security (보안성)

**잘 수행된 부분:**
- 사용자 및 프로젝트 데이터 조회 시 적절한 검사 및 예외 처리를 구현했습니다.

**개선 제안:**
- 사용자의 입력을 처리할 때 SQL 인젝션 또는 무한 루프 등을 방지하는 추가적인 검증을 실행하십시오. 예를 들어, DAO 레벨에서 매개변수 유효성을 검사할 필요가 있습니다.

### 6. Maintainability (유지보수성)

**잘 수행된 부분:**
- 코드의 모듈화가 잘 이루어졌습니다. 변경 사항이 모듈화된 메소드 내에서 명확히 구분되어 있어 유지보수가 용이합니다.

**개선 제안:**
- 메소드가 너무 복잡하게 이루어져 있는 경우, 이를 더 작은 단위로 나누는 것도 좋습니다. 예를 들어, 사용자 배지 획득 로직을 별도의 서비스 클래스로 분리하는 방법을 고려할 수 있습니다.

### 결론

변경된 코드에서 명확한 개선이 있었으며, 특히 효율성과 가독성이 눈에 띄게 향상되었습니다. 그러나 여러 자리에서 더 나은 가독성과 유지를 위해 추가적인 전반적인 최적화를 고려하는 것이 좋습니다. 이러한 개선 사항을 지속적으로 고려하여 작성하면 코드 품질이 더욱 향상될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-17 15:39:58.036544', 186, '2024-11-17 15:39:58.036544', 52, '코드 검토를 요청하신 내용에 대해 각 항목별로 심도 있게 평가하겠습니다.

### 1. Readability (가독성)
- **장점**: 변수명 및 함수명이 그 용도를 잘 나타내고 있으며, 특히 `eventBestMrCount`, `getUsernameBestMergeRequests`와 같은 메서드는 기능을 직관적으로 설명합니다. 적절한 주석도 작성되어 있어 코드 이해에 도움이 됩니다.
- **개선점**: 
    - 일부 새로운 상수의 사용이 코드의 가독성을 향상시켰으나, `PROJECT_LINK_TARGET_COUNT`, `LOGIN_TARGET_COUNT`, `PROMPT_UPDATE_TARGET_COUNT`와 같은 상수가 무엇을 의미하는지에 대한 주석이 부족합니다. 각 상수 위에 간단한 설명을 추가하는 것을 추천합니다.
        ```java
        private static final long PROJECT_LINK_TARGET_COUNT = 20L; // 프로젝트 링크 횟수 목표 기준
        ```

### 2. Consistency (일관성)
- **장점**: 변수명 및 메서드명 규칙이 일관되며, 클래스의 접근 제어자도 적절하게 설정되어 있습니다. 코드 스타일도 통일되고 있습니다.
- **개선점**: `bestMrHistoryRepository.findUsersWithAtLeastNHistory` 메서드의 매개변수 타입을 `long`으로 변경한 것은 좋지만, 이전 코드와의 일관성을 위해 이와 관련된 주석도 함께 교정하여 이전의 `int` 타입과의 차이점을 명확히 하는 것이 좋습니다. 

### 3. Reusability (재사용성)
- **장점**: 여러 부분에서 사용되는 메서드로 구조화된 점이 좋습니다. 예를 들어, `getUsernameBestMergeRequests` 메서드는 어떤 프로젝트에 대해서든지 쉽게 재사용할 수 있는 구조입니다.
- **개선점**: 
    - 일반적으로 사용되는 로직, 예를 들어 `userRepository.getById(userId)` 같은 로직이 여러 군데에서 재사용될 가능성이 있으면 유틸리티 메서드로 분리해 재사용성을 높일 수 있습니다.
        ```java
        private User getUserById(Long userId) {
            return userRepository.getById(userId);
        }
        ```

### 4. Reliability (신뢰성)
- **장점**: 예외 처리와 로그 기록이 도입된 점은 좋은 개선 사항입니다. 프로그램을 운영하면서 예외를 추적할 수 있는 기반을 마련해줍니다.
- **개선점**: 
    - `eventBestMrCount` 메서드에서 `userBadgeRepository.saveAll(userBadges);` 호출 후, 중간에 오류가 발생할 경우 전체 데이터베이스의 상태가 반영되지 않을 수 있습니다. 트랜잭션 관리가 필요하며, 예외 발생 시 적절한 롤백 처리를 고려하는 것이 좋습니다. 
        ```java
        @Transactional
        public void eventBestMrCount() {
            try {
                // 로직
            } catch (Exception e) {
                throw new RuntimeException("Error processing best MR count", e);
            }
        }
        ```
        
### 5. Security (보안성)
- **장점**: 일반적으로 사용자 입력을 수집하는 API에서 입력 검증을 통해 보안을 강화하려는 모습이 보입니다.
- **개선점**: 
    - 사용자 ID나 프로젝트 ID와 같이 외부에서 수신된 데이터는 항상 검증해야 합니다. 이를 위해 Bean Validation 또는 수동으로 검증 로직을 추가하여 잠재적인 보안 취약점을 사전에 차단하는 것이 좋습니다.
        ```java
        if (projectId <= 0) {
            throw new IllegalArgumentException("Project ID must be positive");
        }
        ```

### 6. Maintainability (유지보수성)
- **장점**: 각 메서드와 클래스가 특정한 기능만 수행하도록 설계되어 있어 유지보수가 용이해 보입니다.
- **개선점**: 
    - 변경된 요구사항이 발생할 경우, HINT와 같은 주석을 통해 변경해야 하는 부분에 관한 메모를 남기는 것이 좋습니다. 예를 들어, `//TODO: 상수 값 운영환경에 맞게 수정`과 같은 주석은 향후 유지보수를 돕는 가이드라인이 될 수 있습니다.

### 전체적인 피드백
- 전반적으로 잘 수행되고 있는 부분:
  - 메서드와 변수명이 의미가 명확하고, 범위 내에서 코드의 주요 기능을 잘 설명하고 있습니다.
  - 예외 처리와 로깅을 추가하여 신뢰성을 높이는 데 기여한 점은 매우 긍정적입니다.

- 개선이 필요한 부분:
  - 상수에 대한 문서화와 인라인 주석 추가로 가독성을 높여야 합니다.
  - 예외 처리와 트랜잭션 관리를 보다 체계화하여 시스템 신뢰성을 더욱 강화할 필요가 있습니다.
  - 사용자 입력에 대한 검증을 더욱 철저히 진행할 필요가 있으며, 향후 재사용성을 고려해 로직을 분리하는 것도 좋은 선택입니다.

이러한 피드백을 통해 코드의 품질과 안정성을 한층 더 개선할 수 있을 것입니다.');
INSERT INTO public.review VALUES ('2024-11-17 15:50:47.967486', 187, '2024-11-17 15:50:47.967486', 52, '아래는 제시된 변경 사항에 대한 심도 있는 코드 리뷰입니다. 각 항목별로 잘 수행되고 있는 부분과 개선이 필요한 부분에 대해 상세히 평가하였습니다.

### 1. **Readability (가독성)**

- **잘 수행된 부분**: 
  - 함수와 변수명이 명확하여 기능이 무엇인지 이해하기 용이합니다. 예를 들어, `eventBestMrCount`라는 함수명은 함수가 수행하는 작업을 잘 나타내고 있습니다.
  - 전체적으로 코드 블록이 잘 구성되어 있어 특정 작업의 흐름을 쉽게 따를 수 있습니다.

- **개선 필요 부분**: 
  - 불필요한 주석(예: "TODO: 운영시에 count 바꾸기")은 제거하거나 업데이트하여 최신 상태를 반영해야 합니다. 주석은 필요할 때만 존재해야 하며, 다른 개발자가 이해할 수 있도록 명확해야 합니다.
  - `processUserProject` 메서드에서 `totalScore`와 `AI_REWARD_TARGET_SCORE`의 의미에 대한 설명 주석이 부족합니다. 이러한 상수에 대해 추가 설명이 있으면 더 좋을 것입니다.

### 2. **Consistency (일관성)**

- **잘 수행된 부분**: 
  - 기본적인 코딩 스타일과 명명 규칙이 잘 지켜지고 있습니다. 인덴트 및 공백 사용이 일관되며, `@Transactional` 및 `@RequiredArgsConstructor`와 같은 어노테이션 사용이 일관적입니다.

- **개선 필요 부분**: 
  - 상수명의 대문자 사용이 혼합되어 있고 일관되지 않은데, 예를 들어 `PROJECT_LINK_TARGET_COUNT`, `LOGIN_TARGET_COUNT`는 일관되나 `PROMPT_UPDATE_TARGET_COUNT`는 오타가 있을 수 있으므로 업데이트가 필요합니다. 모든 상수가 같은 형식을 유지해야 합니다.

### 3. **Reusability (재사용성)**

- **잘 수행된 부분**: 
  - 유사한 로직이 반복되는 경우, `userBadgeRepository.findUserIdsWithoutBadge(userIds, CONQUEROR.getId())`와 같은 메서드를 통해 중복 코드를 최소화하려는 노력이 보입니다.

- **개선 필요 부분**: 
  - `eventBestMrCount` 함수에서 `newBadgeUserIds`와 `users`를 결합하는 것으로 재사용성을 높일 수 있는 방법이 있을 듯합니다. 이는 드라이(DRY) 원칙을 따르기 위해 더욱 명확하게 분리될 필요가 있습니다.

### 4. **Reliability (신뢰성)**

- **잘 수행된 부분**: 
  - 새로운 쿼리에서 예외를 로깅하도록 추가하여 오류 발생시 추적이 용이해졌습니다.

- **개선 필요 부분**: 
  - `getUsernameBestMergeRequests` 메서드에서 `top3MrList`가 null이 될 수 있는 경우를 고려하여 방어 코드를 추가한 것은 좋지만, `top3MrList`가 비어있을 경우의 처리 역시 필요합니다. 예를 들어, 비어있는 리스트를 반환하는 것만이 아니라 적절한 예외 처리도 고려해야 합니다.

### 5. **Security (보안성)**

- **잘 수행된 부분**: 
  - `@Transactional(readOnly = true)`를 사용하여 데이터 무결성을 유지하는 점이 긍정적입니다.

- **개선 필요 부분**: 
  - 사용자의 입력이 SQL 인젝션 공격에 취약할 수 있으므로, 사용자의 입력을 처리하는 모든 매개변수에 대해 검증을 강화해야 합니다. 예를 들어, `@RequestParam`으로 받아오는 모든 입력에 대해 유효성 검사를 수행하여 보안성을 높여야 합니다.

### 6. **Maintainability (유지보수성)**

- **잘 수행된 부분**: 
  - 각 메서드는 단일 책임 원칙에 충실하게 설계되어 있어 유지보수가 용이합니다. 함수가 특정 작업을 수행하므로 나중에 수정이 필요할 때 관리하기 쉽습니다.

- **개선 필요 부분**: 
  - 반복되는 쿼리 구문(예: `bestMrHistoryRepository.findUsersWithAtLeastNHistory`)은 별도의 서비스 클래스로 옮길 수 있으며, 더 많은 비즈니스 로직이 필요할 경우 이들 클래스를 통해 재사용성을 높일 수 있습니다.

### **전체적인 피드백**

- **잘 수행한 부분**: 
  - 코드 전반에 걸쳐 명확하고 일관된 변수 및 함수명을 사용한 점이 인상적이며, 예외 처리를 추가하여 신뢰성을 높인 점도 긍정적으로 보입니다.
  - 복잡한 로직을 정리하여 재사용성을 높이려는 노력도 돋보입니다.

- **개선이 필요한 부분**: 
  - 주석의 적절한 사용과 관련하여 각 로직의 설명을 명확히 하고 불필요한 주석을 제거해야 합니다. 
  - 예외 처리와 데이터 검증을 강화하여 안정성을 더욱 높여야 합니다. 
  - 클래스의 책임을 구분하고 중복되는 로직을 최소화하기 위한 추가적인 리팩토링이 필요합니다.

종합적으로, 이 변경 사항은 여러 측면에서 향상된 점이 보이며, 다소 개선이 필요한 부분들도 있습니다. 제안된 피드백을 바탕으로 한 수정 작업이 이루어진다면 코드 품질이 더욱 높아질 것입니다.');
INSERT INTO public.review VALUES ('2024-11-17 15:51:15.400031', 188, '2024-11-17 15:51:15.400031', 52, '코드 리뷰 요청을 잘 접수했습니다. 변경사항을 바탕으로 제시된 평가 항목에 따라 코드 리뷰를 진행하겠습니다.

### 1. **Readability (가독성)**

**잘 수행된 부분:**
- 전반적으로 코드가 깔끔하고 잘 정리되어 있으며, 의도를 명확히 전달하고 있습니다.
- 변수명과 메서드명이 기능을 명확하게 드러내고 있어, 코드를 읽는 데 큰 어려움이 없습니다.

**개선이 필요한 부분:**
- 주석을 과도하게 제거한 것에 대한 우려가 있습니다. 예를 들어, 배지 획득 로직에 대한 설명이 부족하여 팀원들이 이해하기 어려울 수 있습니다. 중요한 비즈니스 로직이나 복잡한 부분에 대한 주석은 유지하는 것이 좋겠습니다.

### 2. **Consistency (일관성)**

**잘 수행된 부분:**
- 코드 포맷과 기본적인 명명 규칙이 일관되게 유지되고 있습니다. 클래스와 메서드의 정의, 공백 사용 등이 깔끔합니다.

**개선이 필요한 부분:**
- 일부 상수명에서 `TARGET_COUNT`와 같은 접미사 사용이 일관되지 않게 보입니다. 모든 상수에 대해 동일한 명명 패턴(예: `_`로 구분)을 사용하는 것이 좋겠습니다.

### 3. **Reusability (재사용성)**

**잘 수행된 부분:**
- 특정 사용자 ID 조회 및 사용자 배지 저장 로직이 메서드로 잘 분리되어 있어 재사용이 용이하다는 점이 긍정적입니다.

**개선이 필요한 부분:**
- 코드에서 중복된 로직이 있는지 점검하고, 코드 리팩토링을 통해 함수나 메서드로 분리할 수 있는 부분은 분리하는 것이 좋습니다. 예를 들어, 사용자에 대한 배지 정보를 가져오는 과정을 공통 메서드로 분리할 수 있습니다.

### 4. **Reliability (신뢰성)**

**잘 수행된 부분:**
- 예외 처리 로직이 추가되어 여러 예외 상황에서도 안정적으로 작동할 수 있도록 개선되었습니다. 특히 `try-catch` 블록을 활용한 오류 로깅은 뛰어난 접근입니다.

**개선이 필요한 부분:**
- `getUsernameBestMergeRequests` 메서드에서 `top3MrList`가 `null`일 경우를 처리하고 있으나, 이러한 체크가 일관되게 모든 메서드에서 이루어져야 합니다. 미리 `null` 체크를 통해 예외를 예방하는 코드를 추가하는 것도 좋은 방법입니다.

### 5. **Security (보안성)**

**잘 수행된 부분:**
- 사용자 ID와 같은 민감한 데이터를 처리하는 부분에 대해 적절한 접근 제한이 이루어질 수 있도록 설계된 부분이 좋습니다.

**개선이 필요한 부분:**
- 데이터베이스 쿼리에서 직접적으로 사용자 ID를 사용하고 있습니다. SQL 인젝션 공격에 대비하기 위한 입력 검증을 추가하는 것이 권장됩니다. 특히 `@Query` 어노테이션을 사용하면서 매개변수 검증을 철저히 하는 것이 좋습니다.

### 6. **Maintainability (유지보수성)**

**잘 수행된 부분:**
- 메서드가 간결하게 작성되어 있어 유지보수가 용이하게 되어 있습니다. 또한, 잘 정의된 기능 단위로 작업이 분리되어 있어 구조적인 가독성을 높이고 있습니다.

**개선이 필요한 부분:**
- 중복된 상수 값이나 비즈니스 로직의 반복 사용이 있는 경우, 상수화하고 메서드로 분리하여 중앙 집중화 관리하는 것이 좋습니다. 예를 들어, 타겟 카운트를 상수로 정의하고 이를 모든 관련 메서드에서 사용하게 하면 더 유지보수가 쉬워질 것입니다.

### **전체적인 피드백**
- 코드 전반에서 전반적으로 잘 수행된 부분이 많은 반면, 수정 및 보완이 필요한 사항도 존재합니다.
- 특히 예외 처리를 통한 안정성 및 가독성을 높일 수 있는 여지가 있습니다. 주석을 통한 정보를 더욱 명확하게 제공하며, 의미 있는 주석을 통해 다른 팀원들이 이해할 수 있도록 돕는 것이 좋습니다.
- 보안성과 재사용성을 높이기 위해 보다 철저한 입력 검증 및 로직 분리를 고려하세요.

이번 리뷰를 통해 팀원들이 더욱 나은 방향으로 코드 품질을 높일 수 있기를 바랍니다. 필요한 경우 추가적인 질문이나 논의가 필요하다면 언제든 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 10:10:43.838885', 208, '2024-11-18 10:10:43.838885', 55, '코드에서 `getBestMergeRequests` 메서드를 리팩토링하여 `BestMrResponse`를 반환하도록 개선한 점은 좋습니다. 이를 통해 메서드가 반환하는 정보가 더 명확해졌습니다. 또한, `getTop3MrInfos` 메서드의 반환 타입을 변화시켜 더 유용한 정보를 제공하도록 한 것도 긍정적입니다. 

다만, 중복된 로직이 어느 정도 남아 있으니, `getTop3MrInfos`와 `getBestMergeRequests` 메서드 간의 책임 분리가 조금 더 명확해질 필요가 있을 것 같습니다. 예를 들어, 최상위 MR 리스트를 가져오는 로직을 별도의 헬퍼 메서드로 분리하면 가독성이 더욱 향상될 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:27.104937', 216, '2024-11-18 10:30:27.104937', 57, '`imageUrl` 프로퍼티를 추가한 것은 좋은 결정입니다. 이렇게 하면 각 채널에 대한 시각적 정보를 추가할 수 있어 사용자 경험이 향상될 것입니다. 그러나 `imageUrl`에 대한 타입 검사나 기본값 설정도 고려해보면 좋겠습니다. 예를 들어, 이미지 URL이 유효한지 확인하는 로직을 추가하면 데이터 무결성이 더욱 향상될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-17 17:17:37.734063', 189, '2024-11-17 17:17:37.734063', 52, '코드 리뷰 요청 주셔서 감사합니다! 변경사항을 꼼꼼히 검토해 보았습니다. 전반적으로 잘 구조화된 코드지만, 몇 가지 개선할 점이 보였습니다. 피드백을 아래와 같이 정리해드릴게요.

### 잘된 부분
1. **상수화 및 코드 최적화**: 코드에서 특정 값들을 상수화하여 가독성을 높인 점이 아주 좋습니다. 이렇게 함으로써 나중에 수정할 때도 관리가 편리해질 것입니다.
2. **예외 처리**: `BestMrHistoryService` 클래스에서 예외를 잡아 로그를 남기는 부분이 잘 구현되었습니다. 이는 문제를 추적하는 데 큰 도움이 되니까요.
3. **주석 제거 및 개선**: 불필요한 주석을 제거하고 코드가 특정 동작을 명확하게 표현하도록 개선한 점이 인상적입니다.

### 개선이 필요한 부분
1. **예외 케이스 처리**: 현재 `getUsernameBestMergeRequests` 메서드에서 `top3MrList`가 null일 경우 비어 있는 리스트를 반환하도록 했지만, 메서드가 실패할 경우에 대한 예외 처리가 없습니다. 예를 들어, `project`가 null일 경우에는 적절한 예외를 발생시켜야 합니다. 또한, 이 메서드의 결과가 항상 null인 경우를 더 detail하게 핸들링하는 걸 고려해보세요.
   ```java
   if (project == null) {
       throw new BusinessException("Project cannot be null");
   }
   ```

2. **데이터베이스 레코드가 없을 때 처리**: `eventBestMrCount` 메서드에서 `newBadgeUserIds`가 빈 리스트인 경우에 대한 처리가 없습니다. 이 리스트가 비어있을 때, subsequent 로그 또는 배지 후킹 이벤트 호출이 쓸모 없게 될 수 있습니다.
   ```java
   if (newBadgeUserIds.isEmpty()) {
       log.info("No users found for new badges.");
       return; // 예시로 추가
   }
   ```

3. **이름 짓기**: `eventBestMrCount` 메서드는 "Count"라는 단어가 포함되어 있지만, 실제로는 "Badge Creation"을 의미하는 것 같습니다. 메서드 이름을 `eventCreateBadgesForBestMr`와 같이 변경해 조금 더 직관적으로 바꾸는 게 좋겠습니다.

4. **주석 추가**: 이제 중요한 기능이 생긴 만큼, 각 메서드의 목표 및 주요 로직에 대한 주석을 추가하면 나중에 코드 이해에 도움이 될 것 같습니다. 예를 들어, `eventBestMrCount()` 메서드의 경우 어떤 배지를 어떤 조건에서 부여하는지를 명확히 설명하면 좋겠어요.

5. **Stream API 사용의 일관성**: `List<User> users = new ArrayList<>();`를 사용하고, `forEach` 구문을 설정한 부분에서 `List<UserBadge>`를 생성하는 데 다른 패턴을 사용하는 것은 가독성을 떨어뜨립니다. 일관적으로 Stream API를 사용하는 게 좋습니다.

결론적으로, 코드 전반적으로 깔끔하게 잘 작성되었습니다. 몇 가지 세부적인 점들만 더 추가하여 완성도를 높인다면 더욱 좋은 결과가 있을 것이라 믿습니다! 변화가 크지 않으니 작은 수정으로도 충분할 것입니다. 좋은 작업 계속 이어가세요!');
INSERT INTO public.review VALUES ('2024-11-17 17:23:45.087652', 190, '2024-11-17 17:23:45.087652', 50, '코드 리뷰를 진행해보겠습니다! 여러분의 코드 변경 사항을 살펴본 결과, 전반적으로 여러 가지 개선이 이루어졌고, 다양한 기능들이 통합된 점이 인상적이었습니다. 하지만 몇 가지 추가적인 고려 사항이 있어 피드백을 드리고자 합니다.

### 잘된 점
1. **UI 개선**: 검색 바 UI와 알림 표시 방식이 더 직관적이고 사용자 친화적으로 변경되어, 사용자 경험이 향상된 것 같습니다. 알림이 없을 때의 UI 처리도 사용자에게 명확한 안내를 제공합니다.

2. **코드의 가독성**: 전반적으로 코드가 비교적 잘 정리되어 있어 읽기 쉽고 이해하기 쉬웠습니다. 특히, `LabelButton`과 `LabelList`에서 라벨 처리 부분이 개선된 점이 돋보입니다.

3. **비동기 처리**: `Promise.all`을 활용하여 여러 API 요청을 병렬로 처리하는 방식이 성능을 고려한 좋은 접근으로 보입니다. 이로 인해 API 호출 시간이 단축될 것으로 예상됩니다.

### 개선이 필요한 부분
1. **예외 처리 강화**: 비동기 통신에서 발생할 수 있는 오류에 대한 예외 처리가 부족해 보입니다. 예를 들어, `fetchMergeRequests`에서 API 호출이 실패할 경우를 대비한 오류 처리 로직을 추가하는 것이 좋습니다. 이렇게 하면 사용자에게 오류를 명확하게 알릴 수 있습니다.
   ```javascript
   const fetchMergeRequests = async () => {
       if (!projectId) return;

       try {
           const [mrResponse, labelsResponse] = await Promise.all([
               MergeRequest.getMrList(projectId, currentStatus, { keyword: searchKeyword, page: Number(currentPage), size: Number(itemsPerPage) }),
               ProjectRequest.getProjectLabels(projectId),
           ]);

           if (mrResponse.data) {
               setTotalPages(mrResponse.data.totalPages ?? 1);
               setMergeRequests(mrResponse.data.gitlabMrList);
           }

           if (labelsResponse.data) {
               setProjectLabels(labelsResponse.data.labels);
           }
       } catch (error) {
           console.error(''Error fetching data:'', error);
           // 사용자에게 오류 메시지 표시 추가
       }
   };
   ```

2. **변수 이름 명확성**: `fetchNotifications`와 `fetchUnreadCount` 함수에서 `response.data`를 검사하는 부분이 있는데, `response`가 유효한지 먼저 검증하는 것도 괜찮을 것 같습니다. 예를 들어, 응답이 성공적인 HTTP 상태인지 확인할 수 있습니다. 이는 코드의 안전성을 높여 주는 방법입니다.

3. **주석 보강**: 코드에 중요한 로직에 대한 간단한 주석을 추가하는 것도 좋습니다. 예를 들어, `fetchUnreadCount` 함수의 주요 목적이나 기능을 주석으로 명시하면, 나중에 다른 개발자가 이해하기 더 쉬울 것입니다.

4. **조건문 간략화**: `getLabelStyle` 함수 내에 조건문을 좀 더 간단히 표현할 수 있습니다. 예를 들어 직접적인 상대 비교보다는 바로 반환하도록 작성할 수도 있습니다.
   ```javascript
   const getLabelStyle = (labelName: string) => {
       const projectLabel = projectLabels.find((label) => label.name === labelName);
       return projectLabel || { name: labelName, textColor: ''#FFFFFF'', bgColor: ''#2C365B'' };
   };
   ```

5. **스타일 일관성**: `CommonButton`을 사용하는 다양한 위치에서 인라인 스타일과 클래스를 혼합하여 사용하고 있는데, 이 부분에 일관성을 유지하는 것도 고려해 보세요. CSS 모듈 또는 Styled Components를 사용하여 동일한 스타일을 재사용할 수 있도록 하면, 유지보수성과 가독성이 높아집니다.

코드가 잘 발전하고 있다는 점은 매우 긍정적입니다. 위의 피드백들을 참고하여 개선해 나가시면 더욱 견고하고 유지보수가 용이한 코드를 작성할 수 있을 것 같습니다. 필요하신 부분이 있으면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-17 18:10:42.024134', 191, '2024-11-17 18:10:42.024134', 54, '코드에 대한 간단한 피드백을 드리겠습니다. 

1. **JUnit 테스트**:
   ```java
   @Test
   void contextLoads() {
   }
   ```
   - `contextLoads` 메서드가 실제로 테스트해야 할 내용을 포함하지 않은 것 같습니다. 테스트의 목적에 맞게 추가적인 검증 로직을 넣는 것이 좋습니다.

2. **Main 메서드**:
   ```java
   public static void main(String[] args) {
       SpringApplication.run(CofloApplication.class, args);
   }
   ```
   - `main` 메서드는 적절하게 작성되었습니다. 그러나 로그 파일을 로깅하는 로직을 추가하면 애플리케이션 시작 시 더 많은 정보를 얻을 수 있습니다.

3. **이미지 파일 변경**:
   - 이미지 파일이 변경되었음을 나타내는 내용이 있습니다. 변경 내용이 프로젝트에 어떤 영향을 미치는지 설명하는 주석을 추가하면 좋겠습니다.

이 외에도 코드의 가독성을 높이기 위해 적절한 주석을 달고, 필요하지 않은 코드나 주석은 정리하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:42.18147', 192, '2024-11-17 18:10:42.18147', 54, '코드에서 개선할 점은 다음과 같습니다:

1. **JUnit 테스트 메서드에 설명 추가**: `contextLoads()` 메서드는 테스트가 무엇을 검증하는지 명확하지 않습니다. 주석을 추가하여 테스트의 의도를 설명하는 것이 좋습니다.

   ```java
   @Test
   void contextLoads() {
       // 애플리케이션 컨텍스트가 로드되는지 확인하기 위한 테스트
   }
   ```

2. **메인 메서드의 입출력 간소화**: `main` 메서드는 현재 잘 작성되어 있지만, 혹시 다른 설정이 필요할 경우를 대비하여 예외 처리를 추가하는 것이 좋습니다.

   ```java
   public static void main(String[] args) {
       try {
           SpringApplication.run(CofloApplication.class, args);
       } catch (Exception e) {
           e.printStackTrace();
       }
   }
   ```

3. **Favicon 파일 관리**: `/frontend/public/favicon.ico`가 변경된 것으로 보이는데, 이 파일의 변경이 의도된 것인지, 혹은 추가할 사항이 있는지 확인이 필요합니다. Favicon은 웹사이트의 브랜드를 나타내므로 적절한 이미지 파일인지 검토하세요.

각 개선 사항을 적용하면 코드의 가독성과 유지보수성이 향상될 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:42.401357', 193, '2024-11-17 18:10:42.401357', 54, '변경 사항에 대한 코멘트는 다음과 같습니다.

1. **테스트 케이스**
   ```java
   @Test
   void contextLoads() {
   }
   ```
   - `contextLoads` 테스트는 Spring의 ApplicationContext가 로드되는지를 확인하는 기본적인 테스트입니다. 해당 테스트가 의미 있는 검증을 한다면 Assertions를 추가하는 것이 좋습니다.

2. **메인 메서드**
   ```java
   public static void main(String[] args) {
       SpringApplication.run(CofloApplication.class, args);
   }
   ```
   - 메인 메서드는 Spring Boot 애플리케이션의 진입점으로 적절합니다. 하지만, 예외 처리 및 로깅을 추가하는 것도 좋은 방법일 수 있습니다.

3. **이미지 파일 변경**
   - 이미지 파일(`logo.png`)이 변경되었다고 합니다. 해당 변경이 어떻게 애플리케이션에 영향을 미치는지를 문서화하는 것이 좋습니다. 예를 들어, 사용자 인터페이스에서의 시각적 변화나 접근성을 고려할 수 있습니다.

전반적으로, 코드의 가독성 및 명확성을 위해 주석이나 문서화를 추가하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:42.763647', 194, '2024-11-17 18:10:42.763647', 54, '코드와 관련된 부분에서 개선할 점은 다음과 같습니다:

1. **테스트 클래스 개선**: `contextLoads()` 메서드는 특정 상황을 테스트하기 위한 메서드이므로, 이름을 더 명확하게 바꾸는 것이 좋습니다. 예를 들어, `applicationContextShouldLoad()`와 같이 명명할 수 있습니다.

    ```java
    @Test
    void applicationContextShouldLoad() {
        // context loading verification logic can be added here
    }
    ```

2. **메인 메서드 문서화**: `main` 메서드에 주석을 추가하여 이 메서드의 목적과 사용 방법을 설명하는 것이 좋습니다.

    ```java
    /**
     * 애플리케이션의 엔트리 포인트.
     * @param args 애플리케이션 인수를 받아들임
     */
    public static void main(String[] args) {
        SpringApplication.run(CofloApplication.class, args);
    }
    ```

3. **로고 파일 경로 확인**: 이미지 파일 변경 내용이 포함되어 있지만, 파일 경로(`/frontend/src/assets/logo_white.png`)에 대해 명시적인 검토가 필요합니다. 올바른 위치에 저장되었는지 확인하고, 참조에 문제가 없는지 점검하는 것이 좋습니다.

이 외에도 운영 환경에 맞게 각 메서드에 대한 테스트를 추가하는 것이 유용할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:10:44.046742', 209, '2024-11-18 10:10:44.046742', 55, '코드 변경 내용이 간결하게 잘 구성되어 있지만, 다음과 같은 유의사항을 고려하면 좋겠습니다:

1. `LocalDate` 변수를 사용하여 시작일과 종료일을 명확하게 전달하는 것은 좋은 접근입니다. 그러나 `startDate` 및 `endDate`에 대한 설명 주석이 추가되면 가독성이 향상될 수 있습니다.
   
2. `BestMrResponse`에 `toString()` 메서드를 오버라이드하여 보다 직관적인 출력 결과를 제공할 수 있습니다.

3. `top3MrList`가 비어있는 경우에 대한 처리를 고려하여, 이 경우의 예외 처리나 경고 메시지를 추가하면 사용자 경험을 개선할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:42.863698', 195, '2024-11-17 18:10:42.863698', 54, '변경된 코드는 구성 요소의 레이아웃을 조정하고 배경 이미지를 GIF로 변경하였습니다. 이와 관련하여 몇 가지 개선할 점을 제안합니다:

1. **CSS 클래스 관리**: `flex`와 `justify-between` 조합이 적절한지 확인하고, `px-20`와 `px-10`의 사용이 일관성 있는지 점검하세요. 필요에 따라 클래스를 통합할 수 있습니다.

2. **접근성 개선**: 이미지에 대한 `alt` 텍스트는 현재 "sign_up_boat"로 설정되어 있는데, 보다 구체적인 설명이 좋습니다. 예를 들어, 이 이미지가 무엇을 강조하는지 설명하세요.

3. **컴포넌트 분리**: `SignupContent` 컴포넌트가 한 가지 책임을 넘어서고 있는 것처럼 보입니다. 배경 이미지와 양식 처리를 별도의 컴포넌트로 분리할 수 있습니다. 이는 코드의 재사용성과 유지보수성을 높입니다.

4. **미디어 쿼리**: 다양한 화면 크기에 적절히 반응하도록 `flex`와 이미지를 조정하는 스타일에 미디어 쿼리를 추가하는 것도 고려하세요.

수정된 코드는 다음과 같습니다:

```javascript
const SignupContent = () => {
  return (
    <div className="flex flex-row justify-between items-center w-full mx-auto px-10">
      <div className="relative w-full max-w-lg">
        <SignupForm />
      </div>
      <img src={signupBoat} alt="A boat representing the signup process" className="w-2/5 h-auto object-contain" />
    </div>
  );
};
```

이와 같이 개선하면 코드를 더 깔끔하게 유지할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:43.173175', 197, '2024-11-17 18:10:43.173175', 54, '변경된 코드에서 로고 이미지가 `logo.png`에서 `logo_white.png`로 변경되었습니다. 이 변경은 주로 스타일 관련이거나 다크 모드와 같은 UI 변경을 반영할 가능성이 큽니다. 

개선할 점:
1. **명명 규칙**: 사용된 이미지 파일의 이름 (`logo_white.png`)이 경로에 따라 명확하게 UI의 상태를 반영하도록 되어 있습니다. 그러나 이미지의 설명이 더 필요할 수 있습니다. 예를 들어, 파일 이름에 구체적인 설명을 추가하면 코드 유지 관리가 쉬워질 수 있습니다.

2. **에러 핸들링**: 이미지가 존재하지 않는 경우의 처리 로직이 필요할 수 있습니다. `import`가 실패할 경우를 대비한 에러 처리를 추가하는 것도 좋은 방법입니다.

예시:
```javascript
import logo from ''assets/logo_white.png'';

// ... 다른 코드 ...

const LogoComponent = () => {
  if (!logo) return <div>Error loading logo</div>;

  return <img src={logo} alt="Company Logo" />;
};
```

이와 같은 조치를 통해 코드의 가독성과 안정성을 향상시킬 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:46.962253', 201, '2024-11-17 18:10:46.962253', 54, '변경 사항을 보면 `CustomSearchBar`의 `width` 속성이 수정되었고, `div`의 `className` 속성도 변경되었습니다. 아래는 개선할 수 있는 몇 가지 점입니다:

1. **일관된 스타일링**: `width` 속성을 `CustomSearchBar`에서 다루는 것과 `div`에서 사용하는 것에 대한 일관성을 유지하는 것이 좋습니다. `min-w-[400px]`와 `mb-4` 조합은 좋지만, 사용자의 화면 크기에 따라 더 유연한 반응형 디자인을 고려해볼 수 있습니다.

2. **불필요한 공백 제거**: 코드에서 불필요한 공백이 발생할 수 있습니다. 사용하지 않는 줄을 삭제하여 가독성을 높일 수 있습니다.

3. **주석 추가**: `repositories`를 순회하는 부분에 어떤 데이터인지 주석을 추가하면 나중에 유지보수나 이해하는 데 도움이 될 것입니다.

4. **모바일 친화성 고려**: 다양한 화면 크기에서의 사용성을 높이기 위해, Flexbox를 사용하는 대신 그리드 레이아웃과 같은 다른 배치 기법을 고려해볼 수 있습니다.

수정된 코드는 아래와 같을 수 있습니다:

```javascript
<CustomSearchBar
  onSearch={handleSearch}
  showOption={false}
  width="pl-3 min-w-[400px] mb-4"
/>

<div className="flex flex-col flex-grow overflow-auto bg-white w-full min-w-[400px] justify-start">
  {repositories.length > 0 ? (
    repositories.map((repo, index) => (
      <div key={repo.gitlabProjectId}>
        {/* Repository details can be rendered here */}
      </div>
    ))
  ) : (
    <p>No repositories found.</p>
  )}
</div>
```

이와 같이 간단한 주석 추가와 일관된 스타일을 유지하는 것이 가독성과 유지보수성을 높이는 데 도움이 됩니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:43.770151', 198, '2024-11-17 18:10:43.770151', 54, '변경된 코드는 전체적으로 잘 구성되어 있습니다. 그러나 다음 몇 가지 개선점을 고려해보실 수 있습니다.

1. **이미지 로딩 최적화**: `img` 태그 대신 CSS 배경 이미지를 사용하는 것이 페이지 로딩 성능에 더 유리할 수 있습니다. 특히 큰 이미지를 여러 번 사용하는 경우.

   ```css
   .background {
       background-image: url(''@assets/images/signup_bg_image.png'');
       background-size: cover;
       background-position: center;
       position: absolute;
       top: 0;
       left: 0;
       right: 0;
       bottom: 0;
       z-index: -10; /* z-index가 필요하다면 이곳에 */
   }
   ```

   ```jsx
   <div className="w-full h-screen flex justify-around items-center">
       <div className="background" />
       <SignupContent />
   </div>
   ```

2. **접근성**: `alt` 속성에 더 구체적인 설명을 제공하도록 개선할 수 있습니다. 예를 들어, "sign up" 대신 "회원가입 배경 이미지"와 같은 설명을 사용하는 것이 좋습니다.

3. **반응형 디자인**: 모바일 화면에서의 디자인도 고려하여 `h-screen` 대신 유연하게 크기를 조절하는 스타일을 구현할 수 있습니다.

이러한 사항들을 고려하시면서 코드를 더 개선해보세요!');
INSERT INTO public.review VALUES ('2024-11-17 18:10:44.238913', 199, '2024-11-17 18:10:44.238913', 54, '제공된 변경 내용은 SVG 코드의 삭제를 보여주고 있습니다. 다음은 몇 가지 개선점입니다:

1. **주석 추가**: 변경된 SVG 코드가 삭제된 이유를 설명하는 주석을 추가하는 것이 좋습니다. 이렇게 하면 다른 개발자들이 코드 변경의 목적을 이해하기 쉬워집니다.

2. **공식화된 코드 관리**: SVG 파일이 UI의 중요한 요소인 경우, 이 파일을 별도로 관리하는 것이 좋습니다. 예를 들어, `/resources` 또는 `/assets` 디렉터리에 SVG 파일을 저장하고, 필요한 곳에서 import하여 사용하는 방식이 더organized 됩니다.

아래는 주석 추가 예시입니다:

```java
// 기존 SVG 아이콘을 제거함. UI 변경으로 인해 필요하지 않음.
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257">...</svg>
```

이와 같이 변경 사항에 대한 문서를 만드는 것은 유지 보수성과 이해도를 높이는 데 큰 도움이 됩니다.');
INSERT INTO public.review VALUES ('2024-11-17 18:10:46.877085', 200, '2024-11-17 18:10:46.877085', 54, '안녕하세요! 변경된 코드에 대해 리뷰를 진행해보겠습니다. 아래는 코드 리뷰의 주요 포인트에 따른 피드백입니다.

### 전반적으로 잘된 부분
1. **기능성**: 변경된 내용에 따라 회원가입 페이지의 레이아웃이 수정되었고, 이미지가 새롭게 변경된 점이 좋습니다. UI 요소들의 배치가 조금 더 직관적으로 변한 것 같습니다.
2. **문서화**: 변경사항에 대해 간략하게 주석과 설명이 제공되어 있어서 변경 의도를 명확하게 알 수 있었습니다.
3. **이름 짓기**: 파일 및 컴포넌트 이름이 일관성 있게 잘 지어져 있어, 무엇을 하는 코드인지 쉽게 이해할 수 있습니다.

### 개선이 필요한 부분
1. **예외 처리**: 변경사항에서 예외 케이스에 대한 처리가 누락된 것처럼 보입니다. 예를 들어, 이미지 로드 실패 시 대체 이미지나 에러 메시지를 제공하는 것이 좋습니다. 아래와 같은 방식으로 구현할 수 있습니다:

    ```javascript
    <img 
      src={signupBoat} 
      alt="sign_up_boat" 
      className="w-2/5 h-auto object-contain" 
      onError={(e) => { e.target.onerror = null; e.target.src = ''path/to/default-image.png''; }} 
    />
    ```

2. **복잡도**: `SignupContent` 컴포넌트에서 레이아웃이 조금 복잡해 보입니다. 가독성을 높이고 유지보수성을 향상시키기 위해, 레이아웃 관련 스타일은 CSS 파일로 분리하는 것을 고려해 보세요. 또한, `absolute`, `relative` 속성을 각각의 요소에 사용하기보다는, 부모 요소에서 관리하는 것이 더 깔끔할 수 있습니다.

3. **주석**: 코드가 직관적이긴 하지만, 주요 변경부분에 대해 추가적인 설명을 달면 다른 개발자들이 코드를 이해하는 데 더 도움이 될 것 같습니다. 특히, 어떤 이유로 어떤 이미지를 사용하게 되었는지, 왜 특정한 레이아웃을 선택했는지에 대한 주석이 있으면 좋을 것 같습니다.

4. **스타일 일관성**: CSS 클래스 이름을 확인해보면, 메서드나 변수명에서 underscore("`_`") 표기를 사용하는 부분과 사용하지 않는 부분이 혼재되어 있습니다. 일관성을 유지하는 것이 중요하기 때문에, 어떤 스타일을 사용할 것인지 정하는게 좋습니다.

5. **자동화된 테스트**: 현재 코드에서 테스트에 대한 언급이 없었습니다. 각 컴포넌트가 예상대로 동작하는지 확인할 수 있는 간단한 유닛 테스트를 추가하는 것이 좋습니다. Jest와 React Testing Library를 사용할 수 있습니다.

### 결론
전체적으로 좋은 변경사항이 많지만, 작은 부분에서 더 나은 사용자 경험을 위해 신경 쓸 수 있는 부분이 있습니다. 특히 예외 처리와 코드의 일관성에 주의하시면 더욱 완성도 높은 코드가 될 것 같습니다. 변경사항에 대해 다시 한번 고려해보시고, 필요하신 부분에 대해 질문 주시면 언제든지 도와드리겠습니다!');
INSERT INTO public.review VALUES ('2024-11-17 22:03:07.392076', 202, '2024-11-17 22:03:07.392076', 52, '안녕하세요! 코드 리뷰를 진행하게 되어 반갑습니다. 전반적으로 변경된 사항들이 코드를 깔끔하게 정리하고 최적화하는 방향으로 잘 진행된 것 같습니다. 하지만 몇 가지 추가적으로 검토할 부분이 있어서 피드백을 드릴게요.

### 잘된 부분
1. **상수화**: `BEST_MERGE_REQUEST_TARGET_COUNT`를 상수로 만들어 코드 가독성을 높인 점은 매우 좋습니다. 앞으로 변경 사항이 있을 때도 이 부분만 수정하면 될 테니 유지보수에도 유리합니다.

2. **주석 정리**: 주석을 적절히 정리하고 필요한 경우를 명확하게 남긴 점은 코드 이해도를 높이는 데 큰 도움이 됩니다.

3. **예외 처리**: `try-catch` 구문을 추가하여 예외 발생 시 로깅하는 방식은 좋은 접근입니다. 시스템이 예외 상황에 대해 보다 탄력적으로 대응할 수 있게 도와줍니다.

### 개선이 필요한 부분
1. **예외 처리의 포괄성**: 현재 `getUsernameBestMergeRequests` 메서드에서 `top3MrList`가 `null`일 경우에 대한 처리를 추가했는데, 이 외에도 여러 상황(예를 들어, 예외 발생 등의 이유)에서 메서드 실행 중 문제가 발생할 수 있습니다. 예외가 발생하더라도 사용자에게 의미 있는 메시지를 제공하거나 로그를 남겨서 분석할 수 있도록 하는 것이 좋습니다.

   ```java
   List<GitlabMrQueryResponse> top3MrList;
   try {
       top3MrList = getBestMergeRequests(userId, project.getId());
   } catch (Exception e) {
       log.error("Failed to retrieve best merge requests: {}", e.getMessage());
       return Collections.emptyList(); // 빈 리스트 반환
   }
   ```

2. **주석 부족**: 특정 함수에 대한 주석이 부족하게 느껴집니다. 예를 들어, `eventBestMrCount()`와 같은 메서드의 목적이나 동작 방식에 대한 간단한 설명을 추가하면, 후에 코드를 리뷰하는 사람이 기능을 이해하는 데 도움이 될 것입니다.

3. **특정 메서드 호출**: `getById` 호출이 여러 번 사용되는데, 이 메서드를 통해 객체를 가져올 때마다 `NoSuchElementException`이 발생할 수 있는 위험이 있습니다. 가능한 경우, `Optional`을 사용하고, 적절한 예외 처리를 추가하는 것을 권장합니다.

   ```java
   Long userId = userRepository.findById(userIdOptional).orElseThrow(() -> new BusinessException("User not found"));
   ```

4. **이름 짓기**: `eventBestMrCount`와 같은 메서드 이름은 구체적인 동작을 명확히 반영하지 못하는 것 같습니다. 메서드가 수행하는 기능에 대해 좀 더 직관적인 이름을 고려하면 좋겠어요. 예를 들어, `updateUserBadgesForBestMergeRequests`와 같이 이름을 개선할 수 있습니다.

### 결론
전체적으로 이동하신 방향은 긍정적이며 코드를 더 읽기 쉬운 형태로 만드는 데 많은 도움이 되었습니다. 몇 가지 세부 사항만 조금 더 보완하면 좋은 결과를 얻을 수 있을 것 같습니다. 추가로 궁금한 점이나 의견이 있으시면 언제든지 문의해주세요! 감사합니다.');
INSERT INTO public.review VALUES ('2024-11-17 22:04:40.689363', 203, '2024-11-17 22:04:40.689363', 21, '안녕하세요! 코드를 리뷰해드리겠습니다. 전체적으로 잘 구조화되어 있고, 기능적으로도 의도한 대로 작동할 것 같은데요, 몇 가지 개선할 수 있는 부분과 고려해야 할 예외 케이스에 대해 말씀드리겠습니다.

### 잘된 부분
1. **명확한 API 명세**: `@Operation` 어노테이션을 통해 API 기능이 명확하게 설명되어 있어서, 다른 개발자들이 이 API의 사용법을 쉽게 이해할 수 있을 것 같습니다. 특히 요청과 응답 모델을 잘 정의한 점이 좋습니다.

2. **잘 구조화된 서비스 로직**: MergeRequest 관련 로직이 서비스 클래스에서 잘 분리되어 있어서, 각 메서드가 한 가지 기능에 집중하고 있습니다. 이렇게 하면 코드 유지보수성이 높아집니다.

3. **유효성 검사 고려**: `getBestGitlabMergeRequests` 메소드에서 유저와 프로젝트의 ID를 활용하고 있는데, 이를 통해 필요한 데이터만 필터링하고 있어 좋은 접근입니다.

### 개선이 필요한 부분
1. **예외 처리**: 현재 코드에서 몇몇 예외 상황에 대한 처리가 부족해 보입니다. 예를 들어, `mrInfoRepository.save(new MrInfo(...))` 부분에서 저장 중에 발생할 수 있는 예외를 처리하지 않는다면, 예외가 발생했을 때 시스템 안정성이 떨어질 수 있습니다. 예외 처리를 통해 적절한 에러 메시지를 반환하도록 해보세요.
   
   ```java
   try {
       MrInfo mrInfo = mrInfoRepository.save(new MrInfo(project, iid, gitlabCreatedDate));
   } catch (DataAccessException e) {
       log.error("Failed to save MR Info", e);
       // 적절한 예외 처리 로직 필요
   }
   ```

2. **주석 간소화**: 현재 주석이 각 단계마다 있는 것은 좋지만, 각 단계에 대해 너무 세부적으로 설명하고 있는 부분이 있습니다. 각 단계가 수행하는 주된 의미만을 간략하게 설명해주면 코드 가독성이 높아질 것입니다.

3. **변수 및 메서드 명명**: Java의 자바스크립트 펑션 네이밍 컨벤션을 고려했을 때, `makeCodeReviewWhenCalledByWebhook` 같은 긴 메서드 명은 약간 부담스럽습니다. 이 메서드가 수행하는 주요 작업을 기반으로 간략화해 보세요. 예를 들어, `processWebhookReview` 같은 이름이 더 명확할 수 있습니다.

4. **정적 분석 도구 사용**: TODO가 필요한 부분을 표시한 것처럼, 정적 분석 도구를 사용하여 코드에서 잠재적인 문제를 사전에 발견할 수 있습니다. 이 도구들은 예외 케이스, 유효하지 않은 상태 등을 자동으로 검출해 줄 수 있어 유용합니다.

5. **문서화**: 코드 변경 사항이 관련 문서에 잘 반영되도록 검토해보세요. 이 문서화는 APIs의 내용 설명과 함께 업데이트가 필요할 수 있습니다.

### 추가적인 고려사항
- **테스트 케이스 보강**: 새롭게 추가된 기능이나 변경된 로직에 대한 통합 테스트 케이스가 충분한지 점검해 주세요. 예외 케이스에 대한 테스트가 포함되어 있어야 합니다.
- **의존성 관리**: 외부 API와의 통신이 많은데, 이러한 요청이 실패할 경우에 대한 처리가 적절히 이루어지고 있는지 확인해보세요. 특히, 네트워크 오류로 인한 실패가 발생할 수 있으므로, 연결 유효성 및 재시도 로직을 고려하는 것이 좋습니다.

전체적으로 잘 구성된 코드고, 위의 피드백을 참고하여 개선해보면 더 안정적이고 유지보수하기 쉬운 코드가 될 수 있을 것 같습니다. 필요하시다면 구체적인 코드 예시를 제공해 드리겠습니다. 좋은 작업 계속해주세요!');
INSERT INTO public.review VALUES ('2024-11-18 09:00:54.912752', 204, '2024-11-18 09:00:54.912752', 52, '안녕하세요! 주어진 코드 변경사항을 리뷰해드리겠습니다. 전반적으로 잘 진행된 부분이 많지만, 예외 케이스와 관련하여 몇 가지 개선할 점을 제안해보겠습니다.

### 잘된 부분
1. **명확한 상수화**: 특정 Threshold 값을 상수로 정의하여 코드의 가독성과 유지보수성을 높인 점이 좋습니다. 예를 들어, `BEST_MERGE_REQUEST_TARGET_COUNT`와 같은 상수는 코드의 의도를 명확하게 표현합니다.

2. **주석 정리**: 불필요한 주석을 제거하고 코드의 흐름을 더 명확하게 만들어 가독성을 개선한 점이 긍정적입니다.

3. **로깅 추가**: 예외 발생 시 학습이나 디버깅에 도움이 될 수 있도록 로깅을 추가한 점도 좋습니다.

4. **Stream API 사용**: Java의 Stream API를 잘 활용하여 간결하고 효율적인 코드를 작성한 점도 인상적입니다.

### 개선이 필요한 부분
1. **예외 처리**:
   - `getUsernameBestMergeRequests` 메소드에서 `top3MrList`가 `null`일 경우 빈 리스트를 반환하는 로직이 잘 추가되었습니다. 하지만, 불투명한 원인으로 인해 `null`이 반환되는 경로가 있을 경우, 이를 로그로 남기는 것이 좋을 것 같습니다. 예를 들어:
     ```java
     if (top3MrList == null) {
         log.warn("No merge requests found for user ID: {} and project ID: {}", userId, project.getId());
         return Collections.emptyList();
     }
     ```
   - `BestMrHistoryService`에서 모든 프로젝트를 읽어오는 부분을 `try-catch`로 감싸고 있지만, Catch 블록에서 예외를 단순히 로깅만 하는 것이 아니라 적절한 핸들링이나 사용자에게 피드백을 주는 방법도 고민해보세요. 예외가 발생했을 때 어떤 조치를 취할지 정해야 합니다.

2. **예외 케이스 세밀화**:
   - 사용자ID를 찾기 위해 `findUserIdsWithoutBadge` 메소드의 사용자 ID 목록이 비어 있을 경우, 그에 대한 처리도 필요할 것 같습니다. 아무 사용자도 없는 경우에 대한 로직을 추가해보세요.

3. **메소드 코드 분리**:
   - 각 메소드는 하나의 책임만 갖도록 하는 것이 좋습니다. 예를 들어, `eventBestMrCount` 메소드가 많을 작업을 수행하고 있는데, 일부 로직을 별도의 메소드로 분리하면 코드가 좀 더 깔끔해질 수 있습니다. 예:
     ```java
     private List<UserBadge> createUserBadges(List<Long> newBadgeUserIds, BadgeCode badgeCode) {
         return newBadgeUserIds.stream()
                 .map(userId -> userRepository.getById(userId))
                 .map(user -> UserBadge.of(user, badgeCode))
                 .collect(Collectors.toList());
     }
     ```

4. **의미 있는 이름짓기**:
   - `processUserProject`와 같은 메소드는 그 기능이 명확하게 드러나지 않습니다. 좀 더 구체적인 이름으로 변경하면 좋을 것 같습니다. 예를 들어 `processUserProjectForBadge`와 같이요.

5. **테스트 추가**:
   - 예외가 발생할 수 있는 경로에 대한 테스트 케이스가 충분히 다뤄지고 있는지 확인해보세요. 예외가 발생했을 때의 상황을 테스트하는 것이 안정성 높이는 데 도움이 됩니다.

이와 같은 개선점을 검토하여 코드를 다듬어 보시면 더 좋을 것 같습니다. 코드 품질과 안정성을 높이는 데 기여할 수 있을 거예요. 잘 진행된 점에 대해 칭찬드리며, 앞으로의 발전을 응원합니다! 😊');
INSERT INTO public.review VALUES ('2024-11-18 09:07:52.574433', 205, '2024-11-18 09:07:52.574433', 54, '안녕하세요! 제공해주신 코드 변경 사항을 리뷰해보았습니다. 각 항목에 따라 긍정적인 부분과 개선이 필요한 부분을 정리해볼게요.

### 긍정적인 부분
1. **기능성**: 회원가입 페이지의 레이아웃 수정은 사용자 경험을 개선하는 데 크게 기여할 것입니다. 새로운 로고와 배경 이미지도 브랜드 이미지에 잘 맞춰져 있어서 긍정적인 변화로 느껴집니다.

2. **디자인 개선**:/Navbar와 SignupContent의 레이아웃 변경은 코드 일관성도 높고, 사용자 인터페이스를 더욱 직관적으로 만들어 줄 것으로 기대됩니다. 이렇게 UI 컴포넌트를 간소화해서 관리하는 것은 좋은 아이디어입니다.

3. **스타일**: CSS 클래스와 구조가 잘 정리되어 있어 전체적인 코드 가독성이 좋습니다. Tailwind CSS 사용이 코드의 간결함을 더해줍니다.

### 개선이 필요한 부분
1. **설계**: `SignupContent`의 레이아웃에서 절대 위치 절대값을 사용한 코드가 보입니다. 이렇게 되면 모바일 기기에서 반응형 문제가 발생할 가능성이 있습니다. 다음과 같이 상대적인 스타일을 사용하는 것이 더 바람직합니다.

   ```javascript
   <div className="relative flex flex-col items-center w-full px-10">
   ```

2. **이름 짓기**: `signupBgImage`와 같은 변수명은 명확하지만, 일관성 있게 `signupBoatImage` 또는 `signupImage`와 같이 좀 더 포괄적인 이름으로 바꾸는 것도 좋을 것 같습니다. 이는 향후 이미지 파일이 추가될 때 헷갈림을 줄일 수 있습니다.

3. **예외 처리**: 서버로부터 데이터를 불러오는 `map` 함수를 사용할 경우 비어있는 상태의 처리도 고려해야 합니다. 예를 들어, `repositories.length > 0` 체크 후, 빈 배열일 때 적절한 사용자 메시지를 표시하면 더 나은 사용자 경험을 제공할 수 있습니다.

   ```javascript
   {repositories.length > 0 ? (
        repositories.map((repo, index) => (
            <div key={repo.gitlabProjectId}>...</div>
        ))
    ) : (
        <p>저장된 레포지토리가 없습니다.</p>
    )}
   ```

4. **주석**: 코드에 중요한 부분에는 간단한 주석을 달아 다른 개발자들이 쉽게 이해할 수 있도록 하면 좋겠습니다. 이해가 필요한 복잡한 로직이나 이유가 설명되지 않는 부분에 주석을 추가하면 코드 가독성이 한층 더 향상될 것입니다.

5. **문서화**: 변경된 디자인 요소나 컴포넌트에 관련된 문서도 다시 한번 확인해보는 것을 추천드립니다. 중요한 UI 변경사항은 이를 사용하는 다른 개발자나 팀원에게도 많은 도움이 될 겁니다.

좋은 방향으로 진행되고 있는지 확인할 수 있게 소스 코드 변경사항을 보여주셔서 감사합니다. 피드백을 참고하셔서 멋진 결과물 만들어 주세요! 추가 질문이나 도움이 필요하다면 언제든지 말씀해 주세요.');
INSERT INTO public.review VALUES ('2024-11-18 10:10:06.14331', 206, '2024-11-18 10:10:06.14331', 54, '안녕하세요! 코드 리뷰 요청해주셔서 감사합니다. 변경된 부분을 잘 살펴보았고, 몇 가지 피드백을 드리고 싶어요.

### 1. 설계
- 회원가입 페이지 레이아웃 수정에서 **responsive design**을 고려한 것처럼 보이는데, `flex`를 적절히 활용하고 있습니다. 새로운 이미지 사용으로 사용자 경험을 개선하려는 의도가 좋습니다. 하지만, 레이아웃의 **유연성**을 높이기 위해 `flex` 속성보다는 CSS Grid를 고려해보는 것도 좋을 것 같아요. 같은 방식으로 확장하기 용이할 수 있습니다.

### 2. 기능성
- 코드가 의도한 대로 기본적으로 잘 작동할 것 같은데, 이미지 교체와 관련하여 **이미지 포맷**이나 **크기**에 따른 성능 저하가 발생할 수 있습니다. GIF 파일 여파처럼 보이는데, 대체할 수 있는 PNG 또는 SVG 포맷으로 다시 검토하는 것도 좋을 것 같습니다.

### 3. 복잡도
- 현재의 복잡성을 줄이기 위해 이미지 관련된 코드와 상태를 별도로 관리할 수 있겠네요. 예를 들어 **커스텀 훅**을 만들어서 이미지 처리 로직을 분리하면 좋겠어요.

### 4. 테스트
- 코드 변경사항에 대한 테스트가 빠진 것 같은데, 특히 UI 테스트가 필요할 것 같아요. 회원가입 페이지의 요소들이 제대로 렌더링되고 있는지, 이미지가 올바르게 보여지는지에 대한 **snapshot testing**을 고려해보세요.

### 5. 이름 짓기
- 변수와 경로 이름이 직관적이지만, `signupBoat`와 같은 이름은 좀 더 구체적인 설명이 가능할 거 같아요. 이 이미지의 역할이나 용도에 대해 알 수 있도록 `signupDecorationImage` 같은 이름으로 변경하면 좋겠어요.

### 6. 주석
- 현재 주석은 많이 없는데, 주요 컴포넌트나 비즈니스 로직에 대해 간단히 설명하는 주석을 추가하면 좋겠습니다. 예를 들어, `SignupContent` 컴포넌트가 수행하는 기능에 대한 간단한 주석이 있으면 이해하는 데 도움이 될 것입니다.

### 7. 스타일
- 스타일이 기본 가이드에 잘 맞춰져 있는 것 같지만, `absolute`, `relative` 포지셔닝을 사용할 때는 다른 요소들과의 관계를 신중하게 고려해야 해요. 요소 정렬이 깔끔하지 않으면 사용자 경험에 영향을 미칠 수 있습니다.

### 8. 문서화
- 변경된 사항에 대한 문서가 업데이트되었는지 확인해주시면 좋겠어요. 특히 스타일 가이드와 컴포넌트 사용법에 대한 문서는 항상 최신 상태로 유지해야 합니다.

### 결론
변경된 코드가 전반적으로 잘 다듬어졌고, 구조도 괜찮습니다. 위의 피드백을 바탕으로 몇 가지를 고려해 보시고, 특히 테스트와 문서화에 신경을 쓰시면 좋을 것 같습니다. 필요한 경우 코드 예시를 제공할 수 있으니 궁금한 점이 있으면 언제든지 물어보세요! 😊');
INSERT INTO public.review VALUES ('2024-11-18 10:10:43.309287', 207, '2024-11-18 10:10:43.309287', 55, '코드는 전반적으로 잘 구성되어 있으며, 기능 변경에 대한 주석이 명확합니다. 하지만, `getBestGitlabMergeRequests` 메소드에서 이전의 `List<GitlabMrQueryResponse>`를 `BestMrResponse`로 변경하면서, 반환 타입에 대한 명확한 설명이 부족해 보입니다. `BestMrResponse`의 구조와 반환되는 데이터의 의미를 주석으로 추가하면 코드 가독성이 더 향상될 것입니다. 추가적으로, `mergeRequestService`에서 `getBestMergeRequests`의 반환 타입에 대한 변경도 고려하여, 메소드 이름을 적절히 조정할 수 있을 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:10:51.764261', 211, '2024-11-18 10:10:51.764261', 55, '안녕하세요! 코드 리뷰를 요청해 주셔서 감사합니다. 작성하신 코드를 살펴보니 몇 가지 장점과 개선할 수 있는 부분이 보입니다. 아래에 제 피드백을 정리해 드릴게요.

### 잘된 부분
1. **명확한 API 설계**: `getBestGitlabMergeRequests`와 같은 메서드에 대한 Swagger 주석이 정상적이며 API의 의도를 잘 설명하고 있어 사용자에게 친절합니다.
2. **DTO 사용**: `BestMrResponse`와 `BestMrInfoResponse`와 같이 명확하고 논리적으로 설계된 DTO를 활용하여 데이터 구조를 명확하게 전달하고 있습니다. 이는 코드의 가독성을 높이는 데 큰 도움이 됩니다.
3. **Stream API 활용**: Java Stream API를 활용하여 리스트 변환 및 매핑을 처리하신 부분이 인상적입니다. 이를 통해 코드가 간결해지고 가독성이 좋아졌습니다.

### 개선이 필요한 부분
1. **예외 처리**: 현재의 코드에서는 여러 데이터베이스 조회와 외부 API 호출이 포함되어 있는데, 이러한 호출에 대한 예외 처리 부분이 보이지 않습니다. 예를 들어, `gitlabAccountRepository.getByUserIdAndProjectId()`나 `gitLabClient.getTop3MrList()`와 같은 메서드는 정보가 없거나 변환 과정에서 예외가 발생할 경우를 대비한 예외 처리가 필요합니다. 사용자가 알기 쉽게 에러 메시지를 전달할 수 있는 방식으로 설계해 보세요.
   ```java
   if (gitlabAccount == null) {
       throw new ResourceNotFoundException("Gitlab account not found for user " + userId);
   }
   ```

2. **복잡도 감소**: `getBestMergeRequests()` 메서드에서의 데이터 흐름이 약간 복잡해 보입니다. `mrInfoList`와 `top3MrList`를 가져오는 과정에서 불필요하게 중간 DTO를 생성하고 있는 것처럼 보입니다. 이 중간 정보를 줄이고 더 간결한 로직으로 바꾸면 가독성이 더욱 향상될 것 같습니다.
   ```java
   public BestMrResponse getBestMergeRequests(Long userId, Long projectId) {
       // 필요한 데이터를 한 번에 가져와서 처리하도록 변경
   }
   ```

3. **주석 추가**: 메서드 내부에서 데이터의 목적이나 처리 과정을 설명하는 주석을 추가하는 것이 좋습니다. 특히, 복잡한 비즈니스 로직이 포함된 메서드에서는 함수의 목적이나 흐름을 주석으로 설명하면 다른 개발자들이 이해하는 데 큰 도움이 됩니다.
   
4. **변수 및 메서드 이름**: `bestMrInfoResponse`, `bestMrResponse`와 같은 변수명이 의미가 모호하게 느껴질 수 있습니다. 메서드에서 반환하는 데이터의 성격을 좀 더 명확하게 나타낼 수 있는 이름을 고려해 보세요. 예를 들어, `getTop3MergeRequestInfo()`와 같은 이름이 더 명확하게 의도를 전달할 수 있습니다.

5. **문서화**: 변경된 코드와 관련된 문서가 업데이트되었는지 확인하는 것도 중요합니다. 코드 변경에 따른 API 문서나 사용법을 동기화하는 것을 잊지 마세요.

### 마무리
전반적으로 잘 구조화된 코드입니다! 예외 처리와 복잡도 감소에 주의를 기울이면 더욱 견고하고 유지보수가 쉽도록 개선할 수 있을 것입니다. 추가로 궁금한 부분이 생기시면 언제든지 말씀해 주세요. 좋은 작업에 감사드리며, 계속해서 발전하는 모습 기대하겠습니다!');
INSERT INTO public.review VALUES ('2024-11-18 10:18:15.999347', 212, '2024-11-18 10:18:15.999347', 56, '코드 리팩토링으로 인해 `handleGitlabEvent` 메서드가 간단해졌지만, 이벤트 타입 처리 로직이 제거되어 `Push Hook`에 대한 처리가 누락되었습니다. API의 유연성을 위해 다양한 이벤트 타입을 지원하는 로직을 재구성하는 것이 좋습니다. 또한, 예외 처리 로직을 고려하여 에러 응답을 추가하는 것 또한 필요해 보입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:28.121446', 221, '2024-11-18 10:30:28.121446', 57, '코드 변경 사항에서 `pb-2` 클래스를 제거한 것은 UI 디자인에서 여백을 줄이는 방향으로 보입니다. 그러나 이 변경이 다른 요소와의 시각적 균형에 영향을 줄 수 있으니, UI/UX 관점에서 여백 변경이 예상되는 결과에 맞는지 확인하는 것이 좋습니다. 여백이 너무 줄어들어 요소들이 서로 가까워지는 것은 피해야 합니다. 추가적으로, 제거한 이유에 대한 주석을 달면 나중에 이해하기 쉬울 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:28.404761', 223, '2024-11-18 10:30:28.404761', 57, '변경 사항에서 `assignee`와 `reviewer`를 선택적(optional)로 변경한 것은 코드의 유연성을 높이는 좋은 결정입니다. 그러나 타입스크립트에서는 `undefined`를 명시적으로 처리해야 할 수 있으므로, 해당 속성이 사용될 때 Null 또는 Undefined 체크를 추가하는 것이 좋습니다. 또한, 주석이나 문서를 통해 이 변경의 목적과 사용 예시를 명확히 하면 사용자에게 더욱 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:30.526161', 225, '2024-11-18 10:30:30.526161', 57, '변경된 코드에서 `rounded-t-md` 클래스가 `rounded-t-2xl`로 변경되었습니다. 이 변경이 UI에 미치는 영향을 고려할 때, 다음과 같은 개선점을 제안합니다:

1. **UI 일관성**: 변경된 테두리 반경이 다른 컴포넌트와 일관된 디자인인지 확인하세요. 만약 다른 요소와 조화를 이루지 않으면, 전반적인 UI가 어색해질 수 있습니다.

2. **반응형 디자인**: 모바일 뷰와 데스크탑 뷰에서의 시각적 차이를 점검하여, 변경된 클래스가 모든 화면 크기에서 적절하게 작동하는지 확인하세요.

3. **사용자 경험**: 테두리의 경계가 둥글어지면서 버튼이나 카드와 같은 요소의 클릭 가능 영역에 영향을 줄 수 있습니다. 사용자들이 쉽게 클릭할 수 있도록 간격을 적절히 조정하세요.

4. **테스트 적용**: 변경된 디자인에 대한 사용자 피드백을 받아보세요. 사용자들이 새로운 디자인을 어떻게 받아들이는지 확인하는 것이 중요합니다.

5. **코드 주석 추가**: CSS 클래스 변경의 이유나 목적을 주석으로 남겨 다른 개발자들이 이해할 수 있도록 하세요. 이는 협업에 도움이 됩니다. 

이러한 점들을 고려하여 디자인을 검토하면 향후 UX/UI에 긍정적인 영향을 미칠 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:36.730896', 226, '2024-11-18 10:30:36.730896', 57, '안녕하세요! 코드를 리뷰해보니 몇 가지 좋은 점과 개선할 부분이 보이네요. 함께 짚어보도록 하겠습니다.

### 잘된 부분:
1. **기능 개선**: 예외 처리와 UI 수정을 통해 코드가 더욱 사용자 친화적이고 안정적으로 개선된 것 같아요. 특히 조건부 렌더링을 활용한 부분(예: `mr.assignee?.avatarUrl`)이 좋았습니다. 이런 방식은 안전하게 접근할 수 있도록 하니 코드에서 Null 관련 예외를 줄일 수 있죠.

2. **주석 추가**: 주석이 코드의 의도를 충분히 설명하는 데 도움을 주고 있습니다. 다만, 이미 주석이 있는 부분에서는 그 내용을 지키며 최소화한 것도 좋았습니다.

3. **CSS 클래스 사용**: 버튼 및 UI 컴포넌트에서 CSS 클래스를 적절하게 사용했습니다. 이는 스타일 관리를 용이하게 해 주고, 유지보수성을 높이는 데 기여하죠.

### 개선이 필요한 부분:
1. **예외 처리**: 예외 처리를 개선할 수 있는 부분이 있습니다. 예를 들어, API 호출이 실패했을 경우 사용자에게 적절한 메시지를 보여주거나 로그를 남기는 처리가 필요합니다. 아래와 같이 `try-catch`문을 구현해볼 수 있습니다.

   ```javascript
   const fetchMergeRequests = async () => {
     try {
       const response = await MergeRequest.getBestMrList(projectId);
       const data = response.data;
       if (data) {
         setBestMergeRequests(data);
       }
     } catch (error) {
       console.error("Failed to fetch merge requests:", error);
       // 사용자에게 오류 메시지 표시
     }
   };
   ```

2. **구조적 개선**: `BestMergeRequestList` 컴포넌트의 렌더링 로직에서 중복된 코드가 보이네요. 특히 이미지를 렌더링하는 부분은 별도의 함수로 빼는 것이 좋을 것 같습니다. 이렇게 하면 코드가 더 깔끔해질 수 있습니다. 예를 들어:

   ```javascript
   const renderAvatar = (user) => {
     return user?.avatarUrl && (
       <img
         src={user.avatarUrl}
         alt={`${user.username}''s avatar`}
         className="w-8 h-8 rounded-full border-2 border-white bg-white shadow-sm"
       />
     );
   };

   // 사용 예
   {renderAvatar(mr.assignee)}
   {renderAvatar(mr.reviewer)}
   ```

3. **이름 짓기**: 전반적으로 명확한 네이밍이 잘 지켜졌지만, `scrollToPosition` 함수에서 위치를 의미하는 매개변수의 이름이 좀 더 구체적일 필요가 있습니다. 예를 들어 `scrollToPosition(isScrolled ? ''top'' : ''bottom'')` 대신 `scrollToPosition(isScrolled ? ''scrollToTop'' : ''scrollToBottom'')`과 같이 하면 가독성이 더욱 높아질 것 같습니다.

4. **테스트 케이스 추가**: 예외 상황 및 경계 조건을 테스트하는 자동화된 테스트 케이스가 부족한 것 같습니다. API 응답이 실패할 경우, 올바르게 처리하는지를 확인하는 단위 테스트를 추가하는 것이 좋습니다.

5. **스타일 일관성**: CSS 클래스 사용에 있어서, 사용한 스타일이 다른 컴포넌트와 일관성을 가지도록 조정하는 것도 좋습니다. 특히, 버튼 및 UI 요소에서의 크기 및 패딩을 통일하여 사용자의 일관된 경험을 제공할 수 있도록 노력해보세요.

### 결론:
전반적으로 코드가 훌륭하게 개선되었지만, 예외 처리 및 중복 코드 제거와 같은 개선이 가능한 부분이 있어요. 테스트 케이스를 추가하고, 스타일의 일관성을 기하는 것도 중요한 부분이니 잊지 않으셨으면 합니다. 이러한 작은 개선들이 장기적으로 프로젝트의 품질을 높일 것입니다. 더 궁금한 점이나 도움이 필요하시면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 10:30:28.334738', 222, '2024-11-18 10:30:28.334738', 57, '코드 개선을 위해 다음과 같은 점을 고려해볼 수 있습니다:

1. **코드 가독성**: `<CustomSearchBar>`의 줄을 줄여서 가독성을 높이는 것은 좋지만, 가독성을 유지하기 위해 적절한 줄 나누기를 고려해볼 수 있습니다.

2. **불필요한 중복 제거**: `min-w-[400px]`와 `mb-4`의 조합은 책임을 명확히 할 수 있는 방법으로 스타일을 구성하는 것이 좋습니다. 필요 시 공통 클래스를 만들거나, CSS 모듈을 활용해볼 수 있습니다.

3. **스타일링 일관성**: `mb-4`가 제거되었는데, 사용자 경험에 부정적인 영향을 줄 수 있으니 필요에 따라 재검토해야 합니다.');
INSERT INTO public.review VALUES ('2024-11-18 10:30:28.624759', 224, '2024-11-18 10:30:28.624759', 57, '변경사항은 이미지 소스에서 `channel.logo`를 `channel.imageUrl`로 수정한 것입니다. 이미지를 적절히 대체하고 있는 것 같지만, `imageUrl`의 존재 여부를 확인하는 안전 장치(예: 조건부 렌더링)를 추가하는 것이 좋습니다. 또한, 주석을 제거한 대신 필요할 경우 설명을 덧붙일 수 있는 주석을 추가하는 것이 코드를 이해하는 데 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:11:40.740843', 227, '2024-11-18 11:11:40.740843', 58, '변경된 스케줄링 크론 표현식을 잘 반영했습니다. 그러나 주기 변경에 대한 설명을 추가하면 코드 가독성이 더 향상될 것 같습니다. 주석에 "일요일 오후 11시 55분에 실행"을 명확히 기재하면 좋겠습니다. 추가로, 해당 주기의 필요성이 코드 주석에 설명되어 있으면 더 이해하기 쉬울 것 같습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:11:41.028081', 228, '2024-11-18 11:11:41.028081', 58, '`e.printStackTrace();`를 사용하여 스택 트레이스를 출력하는 것은 디버깅에 도움이 될 수 있지만, 실제 운영 환경에서는 로그 파일에 기록하는 것이 더 바람직합니다. 대신 로그 레벨을 조정하여 `log.error()` 또는 `log.debug()`로 스택 트레이스를 기록하도록 변경하면 좋습니다. 이렇게 하면 로그 관리가 수월해지고, 생산 환경에서의 정보 노출을 줄일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:11:47.781527', 229, '2024-11-18 11:11:47.781527', 58, '안녕하세요! 코드 리뷰를 요청해주셔서 감사합니다. 변경된 코드를 살펴보고 피드백을 드리겠습니다.

### 잘된 부분
1. **예외 처리**: 예외 처리에서 `e.printStackTrace()`를 추가하신 것은 좋은 접근입니다. 디버깅하는 데 도움이 될 수 있지만, 프로덕션에서는 표준 에러 출력보다는 로깅을 활용하는 게 더 바람직합니다. 그런데 `log.error()`를 이미 사용하고 있으니 `e.printStackTrace()`는 필요하지 않을 것 같습니다.

2. **크론 표현식 업데이트**: 주기적인 작업의 크론 표현식을 변경하여 필요에 맞게 조정한 점도 좋습니다. систем에서 주기적으로 실행되는 작업은 명확하게 정의되는 것이 중요하니까요.

### 개선이 필요한 부분
1. **예외 처리 개선**: 예외 발생 시에 스택 트레이스를 출력하는 것보다는 적절한 로깅을 사용하는 것이 좋습니다. 예를 들어, `log.error("An error occurred", e);`를 사용하면 예외 메시지와 스택 트레이스를 함께 기록할 수 있습니다.

   ```java
   } catch (Exception e) {
       log.error("An error occurred: {}", e.getMessage(), e);
   }
   ```

2. **주석의 명확성**: 크론 주석에 대한 설명은 잘 작성되어 있습니다. 다만, 주기성이 중요한 기능이라면 별도의 설명서를 추가하거나 이 설명을 유지 관리하는 방법도 고려해보세요. 다른 개발자들이 주기를 변경하고 싶을 때 이해하기 쉽도록 해당 설정에 대한 추가적인 정보가 도움이 될 수 있습니다.

3. **코드 스타일 및 컨벤션**: 코드 전반에서 일관된 스타일을 유지하는 것이 중요합니다. 만약 회사의 코딩 가이드라인이 있다면 it 의 규칙에 맞추어 적절하게 작성되었는지 다시 점검해 보는 것이 좋겠습니다. 특히 공백, 들여쓰기, 줄 길이 등을 신경 써주세요.

4. **테스트 케이스 추가**: 예외 처리를 추가한 만큼, 해당 예외가 발생하는 상황에 대한 테스트 케이스를 작성해보시는 것이 좋습니다. 모든 함수와 메서드는 예상치 못한 상황에서도 안정적으로 동작할 수 있어야 합니다.

5. **문서화**: 코드 변경 후, 문서와 관련된 내용도 업데이트해야 합니다. 기능 및 사용법에 대한 설명이 최신 상태인지 확인하는 것이 중요합니다. 변경된 크론 표현식이나 새로 추가된 예외 처리 등에 대한 문서도 포함해주세요.

### 결론
전반적으로 변경된 코드는 좋은 방향으로 가고 있지만, 몇 가지 세부 사항에서 개선의 여지가 있습니다. 제안된 부분들을 반영해보시면 더 안정적이고 유지 보수하기 쉬운 코드를 만들 수 있을 것입니다. 리뷰가 도움이 되셨길 바라며, 추가로 궁금한 부분이 있다면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 11:13:01.117411', 230, '2024-11-18 11:13:01.117411', 59, '코드 변경사항은 `MrEvalRequestMessage`에 `username` 필드를 추가하여 더 많은 정보를 담을 수 있게 합니다. 하지만, `username`의 의미와 사용 목적에 대한 주석을 추가하면 코드 가독성이 향상될 것입니다. 또한, 필드 순서를 고려하여 일관성을 유지하는 것도 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:01.133136', 231, '2024-11-18 11:13:01.133136', 59, '코드의 중복을 줄이기 위해 `chunks.add(...)` 부분을 별도의 메소드로 추출하는 것이 좋습니다. 이렇게 하면 각 코드 조각을 추가하는 로직이 통합되어 가독성과 유지보수성이 향상됩니다. 또한, 해당 메소드에 인자로 `node`와 `code`를 전달하여 재사용성을 높일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:01.165191', 232, '2024-11-18 11:13:01.165191', 59, '코드 변경 사항은 `MrEvalResponseMessage`에 사용자의 이름을 추가하여 더 많은 정보를 포함하도록 개선된 것 같습니다. 다만, 메서드 호출이 길어지는 걸 방지하기 위해 각 매개변수를 한 줄에 하나씩 배치하거나, 매개변수의 순서를 정리하면 가독성이 향상될 수 있습니다. 추가적으로, `log.info` 메시지에 사용자 이름도 포함시킨다면, 로그의 유용성이 더 높아질 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:01.507931', 233, '2024-11-18 11:13:01.507931', 59, '변경 사항은 파일 확장자를 동적으로 가져와 `ChunkedCode` 객체를 생성하는 것으로, 코드의 유연성과 재사용성을 높입니다. 다만, 파일 확장자를 가져오는 `FileUtil.getFileExtension(file)`의 실행 결과가 null일 경우를 고려해야 할 필요가 있습니다. null 체크를 추가하여 예외 상황을 처리하는 것이 좋겠습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:02.596175', 234, '2024-11-18 11:13:02.596175', 59, '코드에서 파일 확장자를 필터링하는 방식은 효과적이지만, 향후 유지보수를 고려하여 확장자 목록을 상수 또는 배열로 따로 관리하는 것이 좋습니다. 이렇게 하면 새로운 확장자를 추가하거나 변경할 때 코드의 가독성과 관리가 용이해질 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:02.73589', 235, '2024-11-18 11:13:02.73589', 59, '변경된 `MrEvalResponseMessage`에 `username` 필드를 추가한 것은 유용한 개선입니다. 그러나 코드의 가독성을 높이기 위해, 필드들이 그룹화되어 있는 경우 동의어로 분리하여 명확하게 작성하는 것이 좋습니다. 또한, 문서화 주석을 추가하면 코드의 이해도를 높이는 데 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:03.805788', 236, '2024-11-18 11:13:03.805788', 59, '`tsx`에 대한 처리를 추가한 것은 좋은 개선점입니다. 다만, 코드의 일관성을 위해 각 언어의 전략을 더 깔끔하게 관리할 수 있는 방법을 고려해보는 것이 좋습니다. 예를 들어, 모든 언어 전략을 리스트에 저장하고 루프를 통해 추가하는 방식으로 유지보수성을 높일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:21:48.420398', 240, '2024-11-18 11:21:48.420398', 60, '코드에서 날짜 정보를 표시하기 위해 추가된 부분은 유용하지만, 날짜의 범위를 정적으로 표시하는 대신, 동적으로 상태를 관리할 수 있는 로직이 필요할 수 있습니다. 또한, `startDate`와 `endDate`의 초기 상태를 `null`이 아닌 적절한 기본값으로 설정하면 사용자 경험이 향상될 수 있습니다. 마지막으로, 코드의 가독성을 높이기 위해 CSS 클래스와 관련된 구조를 정리하면 좋을 듯합니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:13:11.9908', 237, '2024-11-18 11:13:11.9908', 59, '안녕하세요! 코드 리뷰를 요청해 주셔서 감사합니다. 변경사항들을 살펴보았고, 여러 가지 잘된 점과 개선이 필요한 점을 함께 이야기해보려고 합니다.

### 잘된 점
1. **기능 추가**: `MrEvalRequestMessage`와 `MrEvalResponseMessage`에 `username` 필드를 추가한 것은 좋은 접근입니다. 이로 인해 어떤 사용자가 평가했는지 추적할 수 있어 사용자 맞춤형 응답이나 로그 기록에 유용할 것입니다.

2. **확장성**: 특정 확장자에 대한 필터링을 추가한 부분도 좋습니다. 여러 파일 형식이 추가됨에 따라 코드가 명확하게 확장되고 있다는 점에서 긍정적입니다. 이용할 수 있는 확장자를 늘린 것은 다양한 언어의 코드도 올바르게 처리할 수 있도록 합니다.

### 개선할 점
1. **설계**:
   - `MrEvalRequestMessage`와 `MrEvalResponseMessage` 두 DTO에 모두 `username`을 각각 추가했는데, 혹시 공통된 로직이 있다면 사실상 별도의 클래스를 만들어 일반화할 수 있는지 고민해보는 것도 좋을 것 같아요. 예를 들어, `UserMessage` 같은 공통 클래스를 만들어 재사용할 수 있지 않을까요?

2. **복잡도**:
   - `isCodeFile` 메서드에서 여러 파일 확장자를 한 줄로 나열하는 방식은 가독성에 좋지 않은 선택일 수 있습니다. 배열을 사용하여 다음과 같이 정리하면 더욱 깔끔할 수 있습니다.
     ```java
     private boolean isCodeFile(Path filePath) {
         String fileName = filePath.getFileName().toString();
         String[] validExtensions = {".java", ".js", ".tsx", ".ts", ".css", ".html", ".md"};
         
         return Arrays.stream(validExtensions).anyMatch(fileName::endsWith);
     }
     ```
   - 이러면 새로운 확장자를 추가하기도 수월해질 것입니다.

3. **주석 및 문서화**:
   - `isCodeFile` 메서드는 무엇을 하고 있는지 설명하는 주석이 필요할 것 같습니다. 다른 개발자나 미래의 자신이 이해하기 쉽도록 주석을 보강해주세요.
   - 각 DTO에 대한 사용 방법과 필요한 필드에 대한 문서화가 제공되면 더 좋을 것 같습니다.

4. **테스트**:
   - 변경된 사항에 맞게 테스트 케이스도 추가되었는지 확인이 필요합니다. 특히 사용자 관련 필드가 들어온 만큼, 유효한 `username`과 유효하지 않은 `username`에 대한 테스트를 작성해보는 것을 추천합니다. 

5. **이름 짓기**:
   - DTO 클래스명의 경우, `MrEvalRequestMessage`와 같은 이름이 적절하지만, 만약 프로젝트 전반에 걸쳐 비슷한 기능을 하는 DTO가 많다면, 이름에 일관성을 유지하기 위한 패턴을 개발하거나, 더 직관적인 이름을 고려하는 것도 좋습니다.

이와 같은 점들을 고려하여 도전해보시면 더욱 나은 결과를 얻으실 수 있을 거라 생각합니다. 질문이나 추가적인 논의가 필요하면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 11:21:47.971284', 238, '2024-11-18 11:21:47.971284', 60, '코드가 잘 작성되었지만, 중복 코드가 있으니 `formatDate` 함수를 외부로 빼내어 재사용할 수 있도록 하면 가독성과 유지 보수성이 향상될 것입니다. 또한, 주말 계산에 대한 상수를 하드코딩하는 대신, ''일요일''과 ''월요일''을 상수로 정의해 사용하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:21:48.223349', 239, '2024-11-18 11:21:48.223349', 60, '코드에서 `startDate`와 `endDate` 변수를 처리하는 부분이 명확하고 잘 구조화되었습니다. 다만, `responseData`의 필드가 존재하지 않을 경우 조기에 오류를 던진다면 코드 이해도가 더 향상될 수 있습니다. 또한, `throw new Error(''Invalid response structure'');`와 같은 에러 메시지를 좀 더 구체적으로 작성하면 디버깅에 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:21:48.581575', 241, '2024-11-18 11:21:48.581575', 60, '코드 개선을 위해 몇 가지 제안을 드리겠습니다:

1. **날짜 포맷팅**: `startOfWeek`와 `today`를 직접 출력하기보다는, 사용자 친화적인 형식으로 변환하여 표시하는 것이 좋습니다.
2. **상수화**: 텍스트 문자열("아직 BEST MR이 없습니다.") 같은 부분을 상수로 빼내어 관리하면 유지보수가 용이합니다.
3. **에러 처리**: 데이터가 없을 때만 메시지를 출력하는 것 외에, API 호출 실패 시의 에러 메시지도 추가하면 사용자 경험이 향상될 수 있습니다.

이러한 개선점을 반영하면 더 나은 코드 품질을 유지할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:21:55.916959', 242, '2024-11-18 11:21:55.916959', 60, '안녕하세요! 코드 리뷰 요청 주셔서 감사합니다. 주어진 변경 사항을 살펴보았고, 몇 가지 잘된 점과 개선이 필요한 부분에 대해 말씀드릴게요.

### 잘된 부분
1. **설계 개선**: 날짜 관련 정보를 `startDate`와 `endDate` 두 개의 변수를 추가하여 깔끔하게 처리한 점이 좋습니다. 이는 코드의 가독성을 높이고, 필요한 데이터의 흐름을 명확히 만듭니다.
2. **오류 처리**: 응답이 예상한 데이터 구조를 따르지 않았을 경우에 예외를 throw하는 방식이 안전하게 구현되어 있습니다. 이로 인해 사용자는 잘못된 데이터를 다루지 않도록 방지가 될 수 있습니다.
3. **상태 관리**: 상태를 관리하는 부분도 일관되게 작성되어 있어, 각각의 데이터(예: `startDate`, `endDate`)가 실제 컴포넌트에서 어떻게 사용되는지 명확히 보였습니다.

### 개선이 필요한 부분
1. **타입 안정성**: `any` 타입을 사용하는 부분이 보입니다. `response.data`를 `any`로 처리하면, 나중에 이 데이터 구조가 변경될 경우 예기치 못한 오류가 발생할 수 있습니다. 필요하다면, 적절한 타입을 정의해 사용하면 더 안전합니다. 예를 들어:
   ```javascript
   interface ResponseData {
     startDate?: string;
     endDate?: string;
     scoreOfWeek?: any[];
     codeQualityScores?: any[];
   }
   const responseData = response.data as ResponseData;
   ```

2. **주석의 명확성**: 함수 위나 중요한 로직 부분에 대해 주석을 남겨두면 다른 개발자가 코드를 이해하는 데 도움이 됩니다. 코드 흐름을 명확히 하는 주석이 있다면, 특히 데이터와 날짜 처리 부분에서 유용할 것입니다.

3. **중복 제거**: `startDate`와 `endDate`를 처리하는 부분에서 코드가 약간 중복되는 것처럼 보입니다. 다음과 같이 리팩토링하면 더 간결해질 수 있습니다.
   ```javascript
   const dates = {
     startDate: responseData.startDate || null,
     endDate: responseData.endDate || null,
   };

   if (''scoreOfWeek'' in responseData) {
     cumulativeScoreData = { ...dates, scoreOfWeek: responseData.scoreOfWeek || [] };
   } else if (''codeQualityScores'' in responseData) {
     individualScoreData = { ...dates, codeQualityScores: responseData.codeQualityScores || [] };
   } else {
     throw new Error(''Invalid response structure'');
   }
   ```

4. **스타일 일관성**: 스타일을 적용하는 부분에서 간격(padding, margin 등)이 조금씩 다르게 설정된 것 같은데, 일관성을 유지하면 코드 가독성이 높아집니다. 예를 들어, 차트 컨테이너의 `... p-4` 같은 부분에서 비슷한 UI 요소에 대해 통일감을 주면 좋을 것 같습니다.

5. **테스트 커버리지**: 마지막으로, 코드의 변경 사항이 의도한 대로 잘 작동하는지에 대한 자동화된 테스트가 충분한지 점검하세요. 특히 새로운 상태 관리 및 데이터 처리 로직에 대한 테스트가 필요합니다.

전반적으로 잘된 점이 많았지만, 약간의 세세한 부분에서 개선하면 더 나은 코드가 될 수 있을 것 같습니다. 궁금한 사항이 생기면 언제든지 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.186399', 243, '2024-11-18 11:32:46.186399', 61, '변경 내용을 잘 반영하셨습니다. 추가된 `username` 필드가 어떤 목적으로 사용될 것인지에 대한 주석을 추가하면 가독성이 더욱 높아질 것입니다. 또한, 관련 문서나 API 명세에 이 변경 사항이 반영되었는지 확인하는 것도 중요합니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.524454', 245, '2024-11-18 11:32:46.524454', 61, '코드 변경 사항에서 GitLab 이벤트 핸들러에 `username`을 추가하여 메서드에 전달하는 것은 좋은 개선입니다. 그러나 코드 가독성을 높이기 위해 메서드 인자를 정렬하거나 주석을 추가하여 각 인자의 용도를 명시하면 좋습니다. 또한, `username`을 사용하는 목적을 명확히 하기 위해 관련 로직을 추가해 주석을 보완하는 것이 좋습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.937944', 248, '2024-11-18 11:32:46.937944', 61, '코드 변경 내용에서 Repository 인터페이스에 새로운 메서드가 추가되었습니다. 추가된 메서드는 특정 주와 코드 품질 코드에 기반하여 `UserProjectScore`를 조회하는 기능을 제공하는데, 이는 코드의 가독성과 유지보수성을 높이는 데 도움이 됩니다. 그러나 메서드 이름이 다소 길고 복잡하므로, 더 명확하고 간결한 이름으로 변경하는 것을 고려해볼 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:47.499508', 249, '2024-11-18 11:32:47.499508', 61, '코드의 구조가 명확해졌지만, `totalScore` 초기화가 생성자에서 이루어지고 있어 디폴트 값 0을 명시적으로 주는 대신 메서드 호출에 의한 변경을 고려해볼 수 있습니다. `addToTotalScore` 메서드를 통해 점수를 추가할 수 있지만, 기본점수 설정과 관련된 코드가 직관적이지 않을 수 있습니다. `totalScore` 초기값 설정 및 추가 논리를 명확히 하여 코드 가독성을 높이는 것을 추천합니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.619505', 246, '2024-11-18 11:32:46.619505', 61, '기존 `GitlabEventRequest` 레코드에 `User` 정보를 추가한 것은 이벤트 처리에 유용할 수 있습니다. 그러나, `User` 레코드 내부에 추가적인 필드(예: `id`, `email`, `fullname` 등)가 있을 경우 더 많은 정보를 제공할 수 있습니다. 또한, `User`와 `Project` 간의 관계를 명확히 하기 위해 각 레코드에 더욱 세부적인 설명을 추가하는 것도 좋을 듯합니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:46.755326', 247, '2024-11-18 11:32:46.755326', 61, '변경된 `MrEvalResponseMessage` 클래스에 `username` 필드를 추가한 점은 유용하지만, 이전 버전과의 호환성을 고려하여 필요한 경우 생성자나 메서드에 대한 수정도 검토해야 합니다. 또한, 문서화 주석을 추가하여 새 필드의 용도를 명확히 설명하는 것이 좋습니다. 예를 들어, 사용자의 이름이나 ID와 같은 데이터임을 명시하는 것이 코드 가독성을 높일 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:48.005995', 250, '2024-11-18 11:32:48.005995', 61, '현재 코드 구조와 기능이 잘 정리되어 있지만, 다음과 같은 개선 사항을 고려할 수 있습니다:

1. **예외 처리**: `getUserProject` 메서드에서 `User`나 `GitlabAccount`를 찾지 못할 경우에 대한 예외 처리를 추가하는 것이 좋습니다.
2. **상수 사용**: `scoresMap`에서 사용하는 숫자 키(1L ~ 6L)를 상수로 정의하면 코드 가독성이 좋아질 수 있습니다.
3. **메서드 분리**: `updateOrSaveUserProjectScore` 메서드 내에서 점수를 업데이트하거나 새로 생성하는 로직을 별도의 메서드로 분리하면 더 명확한 책임 분리가 이루어질 수 있습니다.
4. **로깅 추가**: 주요 작업에서 로깅을 추가하면 디버깅 및 유지보수에 도움이 됩니다.
5. **성능 최적화**: `codeQualityCodeMap`의 크기가 크다면, 이를 초기화할 때 캐싱 전략을 고려할 수 있습니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:48.621568', 251, '2024-11-18 11:32:48.621568', 61, '코드 변경 사항에 대해 몇 가지 개선점을 제안합니다:

1. **주석 추가**: 주요 로직이나 변수가 어떤 역할을 하는지 설명하는 주석이 있으면 코드 가독성이 향상됩니다. 특히 `userProjectScoreService.saveUserProjectScores` 부분에 대해 구체적인 설명이 필요합니다.

2. **의미 있는 변수 이름 사용**: `username` 변수가 무엇을 의미하는지 명확하게 알 수 있도록 이름을 바꾸는 것이 좋습니다. 예를 들어, `gitlabUsername`으로 변경하여 GitLab 사용자임을 명시할 수 있습니다.

3. **예외 처리**: 외부 서비스 호출 (예: `userProjectScoreService.saveUserProjectScores`)에 대한 예외 처리를 추가하여 서비스의 안정성을 높일 수 있습니다.

4. **일관성 있는 코드 스타일**: 새로운 import는 정렬된 상태로 유지하여 가독성을 높이는 것이 좋습니다.

5. **로깅 개선**: 함수의 진입과 주요 상태 변화에 대한 로깅을 하면, 서비스의 흐름을 추적하는 데 도움이 됩니다.

이러한 점들을 고려하여 코드를 개선하면 전체적인 품질이 높아질 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:49.392291', 252, '2024-11-18 11:32:49.392291', 61, '변경 내용에서 `assertThrows`를 static import한 것은 명확한 의도를 전달하는 데 도움이 됩니다. 그러나 주석이나 설명 없이 코드가 변경되었으므로, 코드의 의도나 변경 이유를 문서화하는 것이 좋습니다. 또한, `openActionRequest.user().username()`을 추가한 이유에 대한 설명이 필요할 수 있습니다. 추가적인 설명이 있다면 코드 유지보수에 도움이 될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 11:32:53.780451', 253, '2024-11-18 11:32:53.780451', 61, '안녕하세요! 코드를 리뷰해주셔서 감사합니다. 변경사항 확인해봤는데 전반적으로 잘 구현되어 있긴 하지만 몇 가지 개선할 부분과 놓친 예외 케이스들을 지적해보려 합니다. 

### 잘된 점
1. **설계**: 전반적인 구조가 잘 나누어져 있고, `UserProjectScoreService` 클래스가 비즈니스 로직을 잘 캡슐화하고 있네요. 이렇게 서비스 클래스를 분리함으로써 코드의 재사용성과 테스트 가능성이 높아집니다.
2. **기능성**: 각 메서드가 특정 기능에 충실하게 작성되어 있어 직관적입니다. 예를 들어 `saveUserProjectScores` 메서드는 매개변수만 보고 어떤 일을 할지 쉽게 알 수 있습니다.

### 개선이 필요한 부분
1. **예외 처리**: `getByUsername()` 같은 메서드는 사용자가 존재하지 않을 경우 `BusinessException`을 발생시키고 있습니다. 추가적으로 NotFound 예외나 다른 예외 타입을 다루는 것이 좋습니다. 예를 들어 사용자 정보를 요구하는 메서드에서 `Optional.empty()`를 다루는 것이 좋죠.

   ```java
   User user = userRepository.getByUsername(username)
       .orElseThrow(() -> new BusinessException("User not found with username: " + username));
   ```

2. **테스트 케이스**: `GitlabEventHandlerTest` 클래스에서 모든 예외 케이스를 고려했는지 확인해볼 필요가 있습니다. 특히 `user`가 `null`이거나, `username`이 비어있을 경우에 대한 테스트가 필요해 보입니다. 이러한 케이스도 추가하면 좋습니다.

3. **주석**: 전체적으로 코드의 가독성이 좋지만, 몇몇 복잡한 로직에 대해 더 구체적인 주석이 있었으면 좋겠습니다. 예를 들어 `updateOrSaveUserProjectScore` 메서드의 의도를 잘 설명하는 주석 추가가 필요해 보입니다.

4. **네이밍**: `getByUsername` 메서드와 `getByUserIdAndProjectId`는 어떤 의미인지 명확하지만, 좀 더 직관적인 이름으로 변화시킬 수 있을 것 같습니다. 예를 들어 `findUserByUsername`나 `findGitlabAccountByUserAndProject` 등으로 바꾸면 명확해집니다.

5. **문서화**: 변경사항에 대해 관련 문서가 업데이트되었는지 확인했으면 좋겠습니다. 특히 API 변화나 데이터 모델 변화는 문서화되어야 합니다. 

이러한 제안들이 도움이 되었길 바라며, 추가적인 질문이나 논의가 필요하면 언제든지 말씀해 주세요. 코드 진행에 행운을 빕니다!');
INSERT INTO public.review VALUES ('2024-11-18 12:47:06.949123', 254, '2024-11-18 12:47:06.949123', 62, '코드의 변경 사항이 잘 정리되어 있으며, 불필요한 부분이 제거된 점이 긍정적입니다. 특히, 상세 리뷰 생성 요청 관련 코드가 주석 처리되어 간결해졌습니다. 그러나, 관련된 주석이 남아 있으면 이해에 도움이 되므로, 주석들을 명확하게 작성하는 것이 좋습니다. ''전체 리뷰 생성 요청''에 대한 설명을 추가해 주면 코드의 가독성이 더욱 향상될 것입니다.');
INSERT INTO public.review VALUES ('2024-11-18 12:47:13.926548', 255, '2024-11-18 12:47:13.926548', 62, '안녕하세요! 코드 리뷰를 하게 되어 기쁩니다. 변경된 `ReviewService` 클래스를 중심으로 전반적으로 잘된 점과 개선할 점에 대해 말씀드릴게요.

### 잘된 부분
1. **코드 간결성**: 불필요한 코드(예: `MergeRequestDiffVersionContent` 관련 코드)를 제거함으로써 가독성을 높인 점이 인상적입니다. 이렇게 코드를 깔끔하게 유지하는 것은 유지 보수성에 큰 도움이 됩니다.
   
2. **로그 사용**: `log.debug`를 통해 디버깅 정보를 기록하고 있는 점이 좋습니다. 이로 인해 코드 실행 중 발생하는 문제를 찾는 데 도움이 될 것입니다.

3. **주석**: 각 단계에 대한 주석을 달아놓은 것은 좋습니다. 이로 인해 다른 개발자들이 코드를 이해하는 데 큰 도움이 될 수 있습니다.

### 개선이 필요한 부분
1. **예외 처리**: 변경된 코드에서 예외 처리가 누락된 것 같아요. 특히, 외부 API 호출(`gitLabClient.getMergeRequestDiffVersions`)에서 예외가 발생할 가능성이 있으므로, 이를 적절히 처리할 필요가 있습니다. 예를 들어:
   ```java
   try {
       MergeRequestDiffVersionContent mergeRequestDiffVersionContent = gitLabClient
               .getMergeRequestDiffVersions(gitlabUrl, token, gitlabProjectId, iid)
               .getFirst();
   } catch (Exception e) {
       log.error("Failed to fetch merge request diff versions", e);
       throw new CustomException("Failed to fetch merge request diff versions");
   }
   ```
   
2. **주석 개선**: 주석이 코드의 흐름을 잘 설명하고 있지만, 주요 변수나 리턴 값이 무엇을 의미하는지 좀 더 구체적으로 설명해주시면 좋겠습니다. 예를 들어, `mrDiffs.toString()`이 반환하는 내용이나 `new ReviewRequestMessage(...)`에서 사용하는 파라미터에 대한 설명이 필요할 수 있습니다.

3. **이름 짓기**: `MrContent`, `ReviewRequestMessage` 같은 이름은 기능을 잘 전달하고 있지만, 조금 더 구체적인 이름을 사용할 수 있으면 좋겠습니다. 예를 들어, `MrContent` 대신 `MergeRequestContent`와 같이 하면 의도가 더 명확해질 수 있습니다.

4. **스타일**: 코드에서 공백이나 인덴트가 consistent하게 유지되고 있는지 확인해볼 필요가 있습니다. 특히, 리스트나 객체를 생성할 때 인덴트가 있어 가독성을 높이는 것이 좋겠습니다. 

5. **테스트 케이스**: 예외 처리가 추가된다면 해당 케이스를 포함한 테스트 케이스도 필요합니다. API 호출이 에러나는 경우를 테스트 할 수 있는 기능을 추가해보세요.

### 문서화
문서화는 코드와 함께 발전해야 합니다. 변경된 내용이 코드 주석이나 관련 문서에 반영되었는지 확인해주세요. 이 부분이 잘 관리되면 다른 팀원들이 이해하는 데 큰 도움이 됩니다.

이런 피드백이 코드 개선에 도움이 되기를 바랍니다! 추가적인 질문이나 도움이 필요하시다면 언제든지 말씀해 주세요.');
INSERT INTO public.review VALUES ('2024-11-18 14:29:05.263599', 275, '2024-11-18 14:29:05.263599', 67, '안녕하세요! 코드를 리뷰할 수 있어서 반갑습니다. 변경하신 사항을 잘 살펴봤고, 몇 가지 피드백을 드리겠습니다.

### 잘된 부분
1. **간결성**: 파일 확장자가 하드코딩으로 변경된 부분에서 코드가 더 명확해졌습니다. `FileUtil.getFileExtension(file)`을 제거하여 불필요한 복잡성을 줄인 점이 긍정적입니다.
2. **일관성**: `JavaScriptChunkStrategy`와 `TypeScriptChunkStrategy`에서 유사한 방식으로 코드를 처리하고 있는 점이 좋습니다. 이렇게 일관성 있는 접근은 유지 관리와 이해를 도와줍니다.

### 개선이 필요한 부분
1. **예외 처리**: 현재 코드에서 파일의 확장자를 하드코딩하는 방식이 모든 경우를 커버하기에 충분한지 확인할 필요가 있습니다. 예를 들어, 지원하는 파일 형식에 대해 실수로 누락되거나 잘못된 형식을 처리해야 할 상황이 생길 수 있습니다. 예외가 발생하는 경우를 대비해 에러 핸들링 로직을 추가하는 것이 좋겠어요. 아래와 같은 형태로 구현할 수 있습니다:

   ```java
   if (!supportedFileTypes.contains(extension)) {
       throw new UnsupportedFileTypeException("Unsupported file type: " + extension);
   }
   ```

2. **주석의 필요성**: 로그 관련 코드가 주석처리되어 있는데, 현재로서는 불필요한 주석일 수 있으나 로그를 통해 디버깅이나 추적이 필요한 경우에 대비하여 필요 시 재사용할 수 있는지 고민해보세요. 주석을 추가해 의도를 명확히 하면 장기적으로 도움이 될 것입니다. 

3. **이름 짓기**: `traverseAndCollectNodes` 메서드는 상당히 명확하지만, 메서드 내에서 Node 유형에 따라 다른 처리를 하는 부분에서 각 Node의 타입에 대한 설명이나 목적을 주석으로 추가하는 것이 좋습니다. 그렇게 하면 다른 개발자들이 그 메서드의 목적과 처리 로직을 더 쉽게 이해할 수 있습니다.

4. **스타일**: 코드 전체에서 설정한 코드 스타일 가이드에 맞춰 공백이나 들여쓰기가 일관되게 관리되고 있는지 확인하세요. 자주 사용하는 팀의 스타일 가이드를 기준으로 전체적인 일관성을 유지하는 것이 좋습니다.

이러한 피드백을 바탕으로 개선해 보시면 좋을 것 같은데요. 결과적으로 코드의 가독성과 유지 관리가 한층 더 향상될 것입니다. 필요하시다면 추가적인 코드 예제나 설명도 도와드릴 수 있으니 말씀해 주세요! 발전하는 모습 기대하겠습니다. 😊');
INSERT INTO public.review VALUES ('2024-11-18 14:47:03.049152', 278, '2024-11-18 14:47:03.049152', 70, '변경사항을 검토하면서 전반적으로 잘 처리된 부분과 개선이 필요한 부분을 아래와 같이 정리해 보았습니다.

### 잘된 부분

1. **상태 관리와 상태 업데이트**: `MrStatusFilter`에서 상태를 잘 관리하고 있으며, 초기 상태를 props로 전달받아 업데이트하는 방식이 좋습니다. 이로 인해 컴포넌트의 재사용성이 높아졌습니다.

2. **사용자 인증 토큰 설명**: 회원가입 폼에서 사용자 인증 토큰에 대한 안내가 명확하게 작성되어 있습니다. 이와 관련된 모달 띄우기 기능도 잘 구현되어 있어 사용자 경험을 높였습니다.

3. **조건부 렌더링 개선**: `ReviewList` 컴포넌트의 코드가 깔끔하게 수정됐으며, 리뷰가 없을 때 사용자에게 피드백을 제공하는 부분이 추가되어 사용성이 개선되었습니다.

4. **스타일 통일성**: 폼과 버튼의 스타일이 일관되게 적용되어 있어 사용자에게 편안한 시각적 경험을 제공합니다. 특히 `SignupForm`에서 로고와 제목이 포함된 점은 좋은 UI 요소입니다.

### 개선이 필요한 부분

1. **예외 처리 강화**: API 호출 시 에러 발생에 대한 처리 로직이 부족한 부분이 있습니다. 예를 들어, `handleValidateToken`와 `handleSignup` 함수에서의 에러 처리가 애매합니다. 에러 발생 시 사용자에게 어떤 문제가 발생했는지 명확하게 알려주는 메시지를 추가해 주세요. 아래는 예시입니다.

   ```javascript
   const handleValidateToken = async () => {
     try {
       // ... API 호출
     } catch (error) {
       // 에러 메시지 구체화
       setAlertModalContent([''토큰 검증 중 오류가 발생했습니다. 다시 시도해 주세요.'']);
       setIsAlertModalOpen(true);
     }
   };
   ```

2. **하드코딩된 상태 처리**: `MrStatusFilter`에서 `activeStatus`의 초기값을 하드코딩하고 있는데, 이 초기값도 props로 받아 처리하는 것이 좋습니다. 이를 통해 상태를 외부에서 제어할 수 있는 flexibility를 줄 수 있습니다.

3. **감사 메시지 중복**: `setAlertModalContent([...])`를 호출하는 부분에서 중복된 메시지가 존재할 수 있습니다. 같은 메시지를 여러 번 표시하지 않도록 조건문을 추가하거나, 메시지를 배열로 정리한 뒤 중복 체크를 통해 일관성을 유지하는 게 좋습니다.

4. **API 호출 최적화**: `fetchMergeRequests`와 같은 API 호출 함수가 여러 곳에서 중복 사용되는데, 이 함수들을 utility 함수로 분리하여 코드의 모듈성을 높이는 것이 좋습니다. 

5. **주석 및 문서화**: 함수와 컴포넌트에 대한 설명이 부족한 부분이 있습니다. 문서화를 위한 주석을 추가하여 다른 개발자들이 코드를 더 쉽게 이해할 수 있도록 도와주세요.

이러한 점들을 고려하여 최종 확인을 진행하면 변경사항에 대한 품질을 더욱 높일 수 있을 것 같습니다.위 피드백을 반영하여 개선 사항 및 에러 케이스를 점검해보세요. 도움이 필요하면 말씀해 주세요!');
INSERT INTO public.review VALUES ('2024-11-18 15:54:15.835798', 280, '2024-11-18 15:54:15.835798', 72, '성공적으로 잘 작성된 코드에 대해 리뷰를 하게 되어 기쁩니다! 여러분이 진행한 변경 사항을 검토하면서 몇 가지 긍정적인 부분과 개선이 필요한 사항을 언급해 보겠습니다.

### 잘된 부분
1. **일관된 스타일**: 코드 변경 시 스타일 일관성을 유지하며, CSS 클래스 이름을 조정하여 작성해주신 점이 좋습니다. 이런 수정은 전체적인 UI의 일관성을 높이고 가독성을 향상시킵니다.
   
2. **명확한 코드 구조**: 전체적인 컴포넌트 구조가 명확하게 구성되어 있어, 유지보수 및 확장이 용이하게 되어 있습니다. 단일 책임 원칙(SRP)을 잘 따르고 있습니다.

3. **비즈니스 로직의 분리**: UI와 비즈니스 로직 사이의 경계를 명확히 지켜, 각 컴포넌트가 수행하는 역할이 분명합니다. 예를 들어, `GuideModal`에서 토큰 검증 로직이 잘 분리되어 있습니다.

### 개선이 필요한 부분
1. **예외 처리 강화**: 
   - 특히, 항상 비동기 작업을 수행할 때 `try-catch` 일부에서 오류 처리가 잘 이루어지지 않는 경우가 있습니다. 예를 들어, `validateToken` 또는 사용자 인증 로직에서 가능한 오류를 세분화하여 각각에 적절히 대응해주는 것이 필요합니다.
   - 사용자에게 오류 메시지가 표시되도록 `setAlertMessage`와 같은 함수 호출을 통해 명확한 피드백을 제공하는 것이 좋습니다.

    ```javascript
    try {
        // API 호출
    } catch (error) {
        setAlertMessage([''오류 발생'', ''다시 시도해주세요.'']);
    }
    ```

2. **네비게이션 로직 통일성**:
   - 네비게이션 로직(`navigate` 호출)을 적용할 때, 가능한 한 경로를 상수로 관리하여 의도치 않은 경로 변경을 방지하는 것이 좋습니다. 
   - 예를 들어, `/login`과 같은 경로를 상수로 정의하고 사용할 수 있습니다. 

   ```javascript
   const LOGIN_PATH = ''/login'';
   ...
   onClick={() => navigate(LOGIN_PATH)}
   ```

3. **주석 추가**: 
   - 코드 블록이 복잡한 경우 각각의 기능이나 수행 목적을 설명하는 주석을 추가하면 좋습니다. 예를 들어, `loading` 상태 관리 부분에서 어떤 상황에서 해당 상태가 업데이트 되는 흠에 대한 주석이 추가된다면 다른 개발자들이 코드를 이해하는 데 큰 도움이 될 것입니다.

4. **구성 요소의 재사용성**: 
   - `TokenInput` 및 `GuideModal`과 같은 구성 요소의 재사용성과 재사용을 고려해봄직합니다. 이러한 컴포넌트는 애플리케이션의 전반적인 일관성과 유지 관리를 위해 다양한 위치에서 재사용될 수 있습니다.
   - 가능한 한 구성을 독립적으로 만들어 다양한 사용 사례를 수용할 수 있도록 노력해 주세요.

전체적으로 코드가 깔끔하게 잘 작성이 되어 있으며, 사용자를 고려한 UI 디자인이 뚜렷하게 드러납니다. 위의 제안 사항을 통해 가독성과 에러 처리 면에서 더욱 향상될 수 있을 것입니다. 지속적인 개선을 위해 항상 다양한 의견을 수렴해보세요!');
INSERT INTO public.review VALUES ('2024-11-18 16:00:40.380121', 281, '2024-11-18 16:00:40.380121', 73, '안녕하세요! 코드를 리뷰해볼게요. 변경 사항에 대해 살펴보면서 잘한 점과 개선할 수 있는 점을 말씀드리겠습니다.

### 잘된 부분
1. **기능 추가**: `MrEvalRequestMessage`에 `username`을 추가하여 리뷰 평가 요청을 보낼 때 더 많은 정보를 함께 전달할 수 있게 된 점은 정말 좋습니다. 이로 인해 리뷰 프로세스가 명확해질 것입니다.
2. **코드 구조**: `record`를 활용하여 불변 객체를 설계한 점이 인상적입니다. Java의 최신 기능을 잘 활용하고 계신 것 같아요.

### 개선이 필요한 부분
1. **예외 처리**: 현재 코드에서는 `username`이 null이거나 비어있는 경우에 대한 처리가 보이지 않는데, 이럴 경우 의도하지 않은 동작이 발생할 수 있습니다. 예를 들어:
   ```java
   if (username == null || username.isEmpty()) {
       throw new IllegalArgumentException("Username must not be null or empty");
   }
   ```
   위와 같은 예외 처리를 추가하여 안정성을 높일 수 있습니다.

2. **설계의 일관성**: `ReviewRequestMessage`에서 `username`을 제거하고 `MrEvalRequestMessage`에서만 추가한 것 같은데, `username`이 항상 필요한 정보라면 `ReviewRequestMessage`에도 포함시키는 것이 좋습니다. 이렇게 되면 다른 클래스 간의 일관성을 유지할 수 있을 것 같습니다.

3. **주석 및 문서화**: 주석이 부재한 것도 아쉽습니다. 각 클래스 및 필드의 목적을 설명하는 주석을 추가하면 코드의 가독성이 높아질 것입니다. 예를 들어:
   ```java
   // User''s GitHub username for identification during review evaluation
   String username;
   ```

4. **테스트 커버리지**: 추가된 `username`을 테스트할 수 있는 단위 테스트가 필요합니다. 다양한 입력 케이스를 고려해 테스트를 작성하면 변경 내역이 의도한 대로 작동하는지 확인할 수 있습니다. 예를 들어:
   ```java
   @Test
   void testMrEvalRequestMessageWithValidUsername() {
       MrEvalRequestMessage request = new MrEvalRequestMessage(1L, 2L, new MrContent("description", "diffs"), "validUsername");
       assertEquals("validUsername", request.username());
   }
   
   @Test
   void testMrEvalRequestMessageWithEmptyUsername() {
       assertThrows(IllegalArgumentException.class, () -> {
           new MrEvalRequestMessage(1L, 2L, new MrContent("description", "diffs"), "");
       });
   }
   ```

5. **스타일 가이드**: 변경된 코드는 Java 스타일 가이드에 잘 맞춰져 있습니다. 그러나 일관된 포맷을 유지하기 위해, 코드 포맷터를 사용하는 것이 좋습니다. 예를 들어, 긴 줄이 있으면 적절히 나누는 등의 방식으로 가독성을 높일 수 있습니다.

결론적으로, 기능적으로는 잘 되어 있지만 예외 처리나 테스트 등의 면에서 개선할 여지가 있습니다. 전반적으로 방향이 좋으며, 위에서 언급한 부분들에 조금씩 신경을 쓰신다면 훨씬 나은 코드가 될 것 같습니다. 추가로 궁금한 점이 있으면 언제든지 물어보세요!');
INSERT INTO public.review VALUES ('2024-11-18 16:04:50.473777', 282, '2024-11-18 16:04:50.473777', 74, '코드 리뷰를 진행해볼게요! 먼저, 변경된 부분에 대한 설명과 결과를 살펴보고 피드백을 제공하겠습니다. 

### 긍정적인 부분
1. **명확한 메서드명**: `addToTotalScore`에서 `updateTotalScore`로의 변경은 메서드가 수행하는 기능을 더 잘 설명해줍니다. 메서드 이름이 더 직관적이어서, 다른 개발자들이 이해하는 데 도움이 될 것 같아요.

2. **null 체크 추가**: `score`가 `null`일 경우 0으로 초기화하는 로직은 좋습니다. 이로 인해 NullPointerException을 방지할 수 있어 전반적인 안정성이 향상되었습니다.

### 개선이 필요한 부분
1. **상대 평균 계산의 명확성**: 현재 `totalScore`를 업데이트하는 로직이 평균값을 계산하는 것인데, 이 의도가 명확하지 않을 수 있습니다. 평균을 구하는 것인지, 단순히 스코어를 반영하고 싶은 것인지 주석을 추가하거나 메서드 이름을 좀 더 구체적으로 변경할 수 있습니다. 예를 들어, `calculateNewAverageScore` 같은 이름을 통해 계산 방식의 의도를 명확히 할 수 있을 것 같습니다.

```java
public void updateAverageScore(Integer score) {
    // 기존 totalScore 업데이트 시 평균 계산 로직
    if (score == null) score = 0;
    this.totalScore = (totalScore + score) / 2; // 평균 계산
}
```

2. **예외 처리**: `updateTotalScore` 메서드에서 예상치 못한 상황이 발생했을 때 어떻게 대응해야 할지에 대한 예외 처리가 필요할 수 있습니다. 예를 들어, `totalScore`가 음수로 내려가지 않도록 체크를 추가하는 것도 방법입니다. 

```java
public void updateTotalScore(Integer score) {
    if (score == null) score = 0;
    this.totalScore = Math.max(0, (totalScore + score) / 2); // 음수 방지
}
```

3. **주석 부족**: 코드에서 어떤 로직이 수행되는지에 대한 주석이 부족해 보입니다. 현재 변경된 `updateTotalScore` 메서드에 어떤 의도로 평균을 계산하는지 설명하는 주석을 추가하는 것이 좋겠습니다. 팀원들이 이해하는 데 도움이 될 것입니다.

4. **테스트 케이스**: `updateTotalScore` 메서드에 대한 단위 테스트가 있을 것 같은데, 다양한 스코어 값에 대한 테스트(양수, 음수, Zero)를 확인해보세요. 평균 계산이 예상대로 작동하는지 보장하는 것이 중요합니다.

### 스타일 및 문서화
- 코드 전반에 걸쳐 일관된 네이밍 컨벤션을 준수하고 있지만, 메서드 네이밍에 대해 일관성을 유지하세요. 각각의 메서드가 무엇을 하는지 쉽게 알 수 있어야 합니다.
- 문서화 부분도 확인해 보세요. 변경된 로직에 대한 설명이 주석이나 필요 시 README에 추가되는 것이 좋겠어요. 특히 팀원들이 코드를 이해하는 데 있어 큰 도움이 될 것입니다.

전반적으로 좋은 개선이 있었지만, 약간의 추가적인 조정과 문서화로 코드의 가독성과 유지보수성을 높일 수 있을 것 같습니다. 이런 부분을 반영해 주시면 더 많은 코드 품질 향상 효과를 누릴 수 있을 거예요!');


--
-- TOC entry 3860 (class 0 OID 35566)
-- Dependencies: 255
-- Data for Name: software_quality; Type: TABLE DATA; Schema: public; Owner: reviewping
--



--
-- TOC entry 3862 (class 0 OID 35570)
-- Dependencies: 257
-- Data for Name: user; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public."user" VALUES ('2024-11-17 13:08:50.742556', 14, 2, '2024-11-17 13:09:37.960354', '100056289886945737473', 'https://secure.gravatar.com/avatar/de5618f1a5aedaa97da4da8aea212a4f10088fef603b68a9ef38c7cc3f569930?s=80&d=identicon', 'GOOGLE', 'USER', '홍선기');
INSERT INTO public."user" VALUES ('2024-11-11 15:24:44.93336', 4, 6, '2024-11-11 15:24:44.93336', '3762042892', 'https://secure.gravatar.com/avatar/3dad23da35ae776322ccd39ae7ae88e6552c60d49a3e0a6bafedd847f94a3196?s=80&d=identicon', 'KAKAO', 'USER', 'fkgnssla');
INSERT INTO public."user" VALUES ('2024-11-11 15:23:22.16942', 2, 2, '2024-11-14 15:04:16.191597', '3763330566', 'https://secure.gravatar.com/avatar/3dad23da35ae776322ccd39ae7ae88e6552c60d49a3e0a6bafedd847f94a3196?s=80&d=identicon', 'KAKAO', 'USER', 'jimmi219');
INSERT INTO public."user" VALUES ('2024-11-11 15:24:41.126278', 3, 3, '2024-11-11 15:28:00.973447', '3779430596', 'https://secure.gravatar.com/avatar/5df4d4186f3aa8c84bf409a74f39adb23d0695b905365155357fda4ed004a8b8?s=80&d=identicon', 'KAKAO', 'USER', 'btothey99');
INSERT INTO public."user" VALUES ('2024-11-11 15:23:09.555647', 1, 6, '2024-11-11 15:23:31.226218', '3764848161', 'https://secure.gravatar.com/avatar/18d31feb03d8981c6c569b9924031f8be04855d7bf40d32a2d66e9093d49cc09?s=384&d=identicon', 'KAKAO', 'USER', 'anjs134');
INSERT INTO public."user" VALUES ('2024-11-11 16:58:22.160867', 6, 5, '2024-11-11 17:02:56.147656', '3787758179', 'https://secure.gravatar.com/avatar/47167cd2ae5c88c5b69f4a690ab5cdb4554a141768b8d6f17c9d62b6380ee1d2?s=80&d=identicon', 'KAKAO', 'USER', 'fview');
INSERT INTO public."user" VALUES ('2024-11-14 15:54:22.410519', 9, NULL, '2024-11-15 12:39:15.422631', '3792030088', 'https://secure.gravatar.com/avatar/de5618f1a5aedaa97da4da8aea212a4f10088fef603b68a9ef38c7cc3f569930?s=80&d=identicon', 'KAKAO', 'USER', 'ajsthfldu1');
INSERT INTO public."user" VALUES ('2024-11-14 11:11:10.258456', 8, NULL, '2024-11-14 11:11:10.258456', '3791657696', NULL, 'KAKAO', 'USER', NULL);
INSERT INTO public."user" VALUES ('2024-11-14 19:29:41.886955', 10, NULL, '2024-11-14 19:29:41.886955', '110595077389205588048', NULL, 'GOOGLE', 'USER', NULL);
INSERT INTO public."user" VALUES ('2024-11-15 09:07:42.261967', 11, NULL, '2024-11-15 09:07:42.261967', '3792879462', NULL, 'KAKAO', 'USER', NULL);
INSERT INTO public."user" VALUES ('2024-11-18 15:38:45.026574', 15, NULL, '2024-11-18 15:40:35.628123', '112749271364547010319', 'https://secure.gravatar.com/avatar/de5618f1a5aedaa97da4da8aea212a4f10088fef603b68a9ef38c7cc3f569930?s=80&d=identicon', 'GOOGLE', 'USER', 'ajsthfldu');
INSERT INTO public."user" VALUES ('2024-11-17 12:33:18.997058', 12, NULL, '2024-11-17 12:33:18.997058', '3779342373', NULL, 'KAKAO', 'USER', NULL);


--
-- TOC entry 3863 (class 0 OID 35577)
-- Dependencies: 258
-- Data for Name: user_badge; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.user_badge VALUES (6, '2024-11-11 15:23:09.780328', 1, '2024-11-11 15:23:09.780328', 1);
INSERT INTO public.user_badge VALUES (6, '2024-11-11 15:23:22.197177', 2, '2024-11-11 15:23:22.197177', 2);
INSERT INTO public.user_badge VALUES (1, '2024-11-11 15:23:31.07385', 3, '2024-11-11 15:23:31.07385', 1);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 15:24:18.244314', 4, '2024-11-11 15:24:18.244314', 1);
INSERT INTO public.user_badge VALUES (6, '2024-11-11 15:24:41.147215', 5, '2024-11-11 15:24:41.147215', 3);
INSERT INTO public.user_badge VALUES (6, '2024-11-11 15:24:44.95375', 6, '2024-11-11 15:24:44.95375', 4);
INSERT INTO public.user_badge VALUES (1, '2024-11-11 15:28:00.860124', 7, '2024-11-11 15:28:00.860124', 3);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 15:28:02.998448', 8, '2024-11-11 15:28:02.998448', 3);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 15:40:31.699908', 9, '2024-11-11 15:40:31.699908', 1);
INSERT INTO public.user_badge VALUES (6, '2024-11-11 16:58:22.178608', 13, '2024-11-11 16:58:22.178608', 6);
INSERT INTO public.user_badge VALUES (1, '2024-11-11 17:02:56.01325', 16, '2024-11-11 17:02:56.01325', 6);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 17:03:16.268521', 20, '2024-11-11 17:03:16.268521', 6);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 17:08:30.420767', 21, '2024-11-11 17:08:30.420767', 2);
INSERT INTO public.user_badge VALUES (3, '2024-11-11 17:08:36.998959', 22, '2024-11-11 17:08:36.998959', 3);
INSERT INTO public.user_badge VALUES (5, '2024-11-11 17:20:45.402107', 25, '2024-11-11 17:20:45.402107', 6);
INSERT INTO public.user_badge VALUES (NULL, '2024-11-11 17:28:47.575455', 26, '2024-11-11 17:28:47.575455', 6);
INSERT INTO public.user_badge VALUES (2, '2024-11-12 09:28:40.767385', 27, '2024-11-12 09:28:40.767385', 3);
INSERT INTO public.user_badge VALUES (2, '2024-11-12 11:18:53.90937', 28, '2024-11-12 11:18:53.90937', 1);
INSERT INTO public.user_badge VALUES (2, '2024-11-13 09:12:43.340059', 29, '2024-11-13 09:12:43.340059', 6);
INSERT INTO public.user_badge VALUES (6, '2024-11-14 11:11:10.28668', 30, '2024-11-14 11:11:10.28668', 8);
INSERT INTO public.user_badge VALUES (6, '2024-11-14 15:54:22.448271', 31, '2024-11-14 15:54:22.448271', 9);
INSERT INTO public.user_badge VALUES (6, '2024-11-14 19:29:41.917753', 34, '2024-11-14 19:29:41.917753', 10);
INSERT INTO public.user_badge VALUES (6, '2024-11-15 09:07:42.301046', 35, '2024-11-15 09:07:42.301046', 11);
INSERT INTO public.user_badge VALUES (1, '2024-11-15 12:39:15.274419', 36, '2024-11-15 12:39:15.274419', 9);
INSERT INTO public.user_badge VALUES (3, '2024-11-15 12:39:28.693228', 37, '2024-11-15 12:39:28.693228', 9);
INSERT INTO public.user_badge VALUES (2, '2024-11-15 19:44:45.105653', 38, '2024-11-15 19:44:45.105653', 4);
INSERT INTO public.user_badge VALUES (6, '2024-11-17 12:33:19.089971', 39, '2024-11-17 12:33:19.089971', 12);
INSERT INTO public.user_badge VALUES (6, '2024-11-17 13:08:50.760579', 45, '2024-11-17 13:08:50.760579', 14);
INSERT INTO public.user_badge VALUES (1, '2024-11-17 13:09:37.838297', 47, '2024-11-17 13:09:37.838297', 14);
INSERT INTO public.user_badge VALUES (3, '2024-11-17 13:09:39.845881', 48, '2024-11-17 13:09:39.845881', 14);
INSERT INTO public.user_badge VALUES (2, '2024-11-17 15:39:40.606453', 49, '2024-11-17 15:39:40.606453', 2);
INSERT INTO public.user_badge VALUES (2, '2024-11-17 15:50:26.938059', 50, '2024-11-17 15:50:26.938059', 14);
INSERT INTO public.user_badge VALUES (5, '2024-11-18 15:38:45.083278', 51, '2024-11-18 15:38:45.083278', 15);
INSERT INTO public.user_badge VALUES (1, '2024-11-18 15:40:35.514601', 53, '2024-11-18 15:40:35.514601', 15);


--
-- TOC entry 3866 (class 0 OID 35582)
-- Dependencies: 261
-- Data for Name: user_project; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.user_project VALUES ('2023-10-29 00:00:00', 1, 1, '2024-11-11 15:24:18.205293', 1);
INSERT INTO public.user_project VALUES ('2023-10-29 00:00:00', 3, 6, '2024-11-11 15:28:02.987563', 1);
INSERT INTO public.user_project VALUES ('2023-10-29 00:00:00', 4, 7, '2024-11-11 15:32:19.746539', 1);
INSERT INTO public.user_project VALUES ('2023-10-29 00:00:00', 2, 8, '2024-10-16 09:00:00', 1);
INSERT INTO public.user_project VALUES ('2023-10-29 00:00:00', 9, 12, '2024-11-11 17:03:16.259696', 1);
INSERT INTO public.user_project VALUES ('2024-11-15 12:39:28.675019', 11, 13, '2024-11-15 12:39:28.675019', 1);
INSERT INTO public.user_project VALUES ('2024-11-17 13:09:39.834996', 16, 17, '2024-11-17 13:09:39.834996', 1);
INSERT INTO public.user_project VALUES ('2024-11-18 15:41:59.392451', 18, 18, '2024-11-18 15:41:59.392451', 1);


--
-- TOC entry 3868 (class 0 OID 35586)
-- Dependencies: 263
-- Data for Name: user_project_score; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.user_project_score VALUES (1, 1, '2024-10-18 09:00:00', 49, '2024-10-18 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (1, 2, '2024-10-18 09:00:00', 50, '2024-10-18 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (1, 3, '2024-10-18 09:00:00', 51, '2024-10-18 09:00:00', 9, 1);
INSERT INTO public.user_project_score VALUES (1, 4, '2024-10-18 09:00:00', 52, '2024-10-18 09:00:00', 6, 1);
INSERT INTO public.user_project_score VALUES (1, 5, '2024-10-18 09:00:00', 53, '2024-10-18 09:00:00', 10, 1);
INSERT INTO public.user_project_score VALUES (1, 6, '2024-10-18 09:00:00', 54, '2024-10-18 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (2, 1, '2024-10-23 09:00:00', 55, '2024-10-23 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (2, 2, '2024-10-23 09:00:00', 56, '2024-10-23 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (2, 3, '2024-10-23 09:00:00', 57, '2024-10-23 09:00:00', 6, 1);
INSERT INTO public.user_project_score VALUES (2, 4, '2024-10-23 09:00:00', 58, '2024-10-23 09:00:00', 9, 1);
INSERT INTO public.user_project_score VALUES (2, 5, '2024-10-23 09:00:00', 59, '2024-10-23 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (2, 6, '2024-10-23 09:00:00', 60, '2024-10-23 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (3, 1, '2024-10-30 09:00:00', 61, '2024-10-30 09:00:00', 9, 1);
INSERT INTO public.user_project_score VALUES (3, 2, '2024-10-30 09:00:00', 62, '2024-10-30 09:00:00', 10, 1);
INSERT INTO public.user_project_score VALUES (3, 3, '2024-10-30 09:00:00', 63, '2024-10-30 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (3, 4, '2024-10-30 09:00:00', 64, '2024-10-30 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (3, 5, '2024-10-30 09:00:00', 65, '2024-10-30 09:00:00', 9, 1);
INSERT INTO public.user_project_score VALUES (3, 6, '2024-10-30 09:00:00', 66, '2024-10-30 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (4, 1, '2024-11-05 09:00:00', 67, '2024-11-05 09:00:00', 5, 1);
INSERT INTO public.user_project_score VALUES (4, 2, '2024-11-05 09:00:00', 68, '2024-11-05 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (4, 3, '2024-11-05 09:00:00', 69, '2024-11-05 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (4, 4, '2024-11-05 09:00:00', 70, '2024-11-05 09:00:00', 8, 1);
INSERT INTO public.user_project_score VALUES (4, 5, '2024-11-05 09:00:00', 71, '2024-11-05 09:00:00', 7, 1);
INSERT INTO public.user_project_score VALUES (4, 6, '2024-11-05 09:00:00', 72, '2024-11-05 09:00:00', 4, 1);
INSERT INTO public.user_project_score VALUES (1, 1, '2024-10-18 09:00:00', 73, '2024-10-18 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (1, 2, '2024-10-18 09:00:00', 74, '2024-10-18 09:00:00', 7, 8);
INSERT INTO public.user_project_score VALUES (1, 3, '2024-10-18 09:00:00', 75, '2024-10-18 09:00:00', 9, 8);
INSERT INTO public.user_project_score VALUES (1, 4, '2024-10-18 09:00:00', 76, '2024-10-18 09:00:00', 6, 8);
INSERT INTO public.user_project_score VALUES (1, 5, '2024-10-18 09:00:00', 77, '2024-10-18 09:00:00', 10, 8);
INSERT INTO public.user_project_score VALUES (1, 6, '2024-10-18 09:00:00', 78, '2024-10-18 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (2, 1, '2024-10-23 09:00:00', 79, '2024-10-23 09:00:00', 7, 8);
INSERT INTO public.user_project_score VALUES (2, 2, '2024-10-23 09:00:00', 80, '2024-10-23 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (2, 3, '2024-10-23 09:00:00', 81, '2024-10-23 09:00:00', 6, 8);
INSERT INTO public.user_project_score VALUES (2, 4, '2024-10-23 09:00:00', 82, '2024-10-23 09:00:00', 9, 8);
INSERT INTO public.user_project_score VALUES (2, 5, '2024-10-23 09:00:00', 83, '2024-10-23 09:00:00', 7, 8);
INSERT INTO public.user_project_score VALUES (2, 6, '2024-10-23 09:00:00', 84, '2024-10-23 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (3, 1, '2024-10-30 09:00:00', 85, '2024-10-30 09:00:00', 9, 8);
INSERT INTO public.user_project_score VALUES (3, 2, '2024-10-30 09:00:00', 86, '2024-10-30 09:00:00', 10, 8);
INSERT INTO public.user_project_score VALUES (3, 3, '2024-10-30 09:00:00', 87, '2024-10-30 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (3, 4, '2024-10-30 09:00:00', 88, '2024-10-30 09:00:00', 7, 8);
INSERT INTO public.user_project_score VALUES (3, 5, '2024-10-30 09:00:00', 89, '2024-10-30 09:00:00', 9, 8);
INSERT INTO public.user_project_score VALUES (3, 6, '2024-10-30 09:00:00', 90, '2024-10-30 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (4, 1, '2024-11-05 09:00:00', 91, '2024-11-05 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (4, 2, '2024-11-05 09:00:00', 92, '2024-11-05 09:00:00', 4, 8);
INSERT INTO public.user_project_score VALUES (4, 3, '2024-11-05 09:00:00', 93, '2024-11-05 09:00:00', 9, 8);
INSERT INTO public.user_project_score VALUES (4, 4, '2024-11-05 09:00:00', 94, '2024-11-05 09:00:00', 8, 8);
INSERT INTO public.user_project_score VALUES (4, 5, '2024-11-05 09:00:00', 95, '2024-11-05 09:00:00', 5, 8);
INSERT INTO public.user_project_score VALUES (4, 6, '2024-11-05 09:00:00', 96, '2024-11-05 09:00:00', 6, 8);
INSERT INTO public.user_project_score VALUES (1, 1, '2024-10-18 09:00:00', 97, '2024-10-18 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (1, 2, '2024-10-18 09:00:00', 98, '2024-10-18 09:00:00', 6, 7);
INSERT INTO public.user_project_score VALUES (1, 3, '2024-10-18 09:00:00', 99, '2024-10-18 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (1, 4, '2024-10-18 09:00:00', 100, '2024-10-18 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (1, 5, '2024-10-18 09:00:00', 101, '2024-10-18 09:00:00', 9, 7);
INSERT INTO public.user_project_score VALUES (1, 6, '2024-10-18 09:00:00', 102, '2024-10-18 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (2, 1, '2024-10-23 09:00:00', 103, '2024-10-23 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (2, 2, '2024-10-23 09:00:00', 104, '2024-10-23 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (2, 3, '2024-10-23 09:00:00', 105, '2024-10-23 09:00:00', 6, 7);
INSERT INTO public.user_project_score VALUES (2, 4, '2024-10-23 09:00:00', 106, '2024-10-23 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (2, 5, '2024-10-23 09:00:00', 107, '2024-10-23 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (2, 6, '2024-10-23 09:00:00', 108, '2024-10-23 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (3, 1, '2024-10-30 09:00:00', 109, '2024-10-30 09:00:00', 9, 7);
INSERT INTO public.user_project_score VALUES (3, 2, '2024-10-30 09:00:00', 110, '2024-10-30 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (3, 3, '2024-10-30 09:00:00', 111, '2024-10-30 09:00:00', 10, 7);
INSERT INTO public.user_project_score VALUES (3, 4, '2024-10-30 09:00:00', 112, '2024-10-30 09:00:00', 9, 7);
INSERT INTO public.user_project_score VALUES (3, 5, '2024-10-30 09:00:00', 113, '2024-10-30 09:00:00', 8, 7);
INSERT INTO public.user_project_score VALUES (3, 6, '2024-10-30 09:00:00', 114, '2024-10-30 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (1, 1, '2024-10-18 09:00:00', 121, '2024-10-18 09:00:00', 6, 6);
INSERT INTO public.user_project_score VALUES (1, 2, '2024-10-18 09:00:00', 122, '2024-10-18 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (1, 3, '2024-10-18 09:00:00', 123, '2024-10-18 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (1, 4, '2024-10-18 09:00:00', 124, '2024-10-18 09:00:00', 6, 6);
INSERT INTO public.user_project_score VALUES (1, 5, '2024-10-18 09:00:00', 125, '2024-10-18 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (1, 6, '2024-10-18 09:00:00', 126, '2024-10-18 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (2, 1, '2024-10-23 09:00:00', 127, '2024-10-23 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (2, 2, '2024-10-23 09:00:00', 128, '2024-10-23 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (2, 3, '2024-10-23 09:00:00', 129, '2024-10-23 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (2, 4, '2024-10-23 09:00:00', 130, '2024-10-23 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (2, 5, '2024-10-23 09:00:00', 131, '2024-10-23 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (2, 6, '2024-10-23 09:00:00', 132, '2024-10-23 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (3, 1, '2024-10-30 09:00:00', 133, '2024-10-30 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (3, 2, '2024-10-30 09:00:00', 134, '2024-10-30 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (3, 3, '2024-10-30 09:00:00', 135, '2024-10-30 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (3, 4, '2024-10-30 09:00:00', 136, '2024-10-30 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (3, 5, '2024-10-30 09:00:00', 137, '2024-10-30 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (3, 6, '2024-10-30 09:00:00', 138, '2024-10-30 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (4, 1, '2024-11-05 09:00:00', 115, '2024-11-05 09:00:00', 4, 7);
INSERT INTO public.user_project_score VALUES (4, 2, '2024-11-05 09:00:00', 116, '2024-11-05 09:00:00', 2, 7);
INSERT INTO public.user_project_score VALUES (4, 3, '2024-11-05 09:00:00', 117, '2024-11-05 09:00:00', 4, 7);
INSERT INTO public.user_project_score VALUES (4, 4, '2024-11-05 09:00:00', 118, '2024-11-05 09:00:00', 2, 7);
INSERT INTO public.user_project_score VALUES (4, 5, '2024-11-05 09:00:00', 119, '2024-11-05 09:00:00', 1, 7);
INSERT INTO public.user_project_score VALUES (4, 6, '2024-11-05 09:00:00', 120, '2024-11-05 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (4, 1, '2024-11-05 09:00:00', 139, '2024-11-05 09:00:00', 5, 6);
INSERT INTO public.user_project_score VALUES (4, 2, '2024-11-05 09:00:00', 140, '2024-11-05 09:00:00', 9, 6);
INSERT INTO public.user_project_score VALUES (4, 3, '2024-11-05 09:00:00', 141, '2024-11-05 09:00:00', 1, 6);
INSERT INTO public.user_project_score VALUES (4, 4, '2024-11-05 09:00:00', 142, '2024-11-05 09:00:00', 2, 6);
INSERT INTO public.user_project_score VALUES (4, 5, '2024-11-05 09:00:00', 143, '2024-11-05 09:00:00', 4, 6);
INSERT INTO public.user_project_score VALUES (4, 6, '2024-11-05 09:00:00', 144, '2024-11-05 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (1, 1, '2024-10-18 09:00:00', 145, '2024-10-18 09:00:00', 3, 17);
INSERT INTO public.user_project_score VALUES (1, 2, '2024-10-18 09:00:00', 146, '2024-10-18 09:00:00', 4, 17);
INSERT INTO public.user_project_score VALUES (1, 3, '2024-10-18 09:00:00', 147, '2024-10-18 09:00:00', 8, 17);
INSERT INTO public.user_project_score VALUES (1, 4, '2024-10-18 09:00:00', 148, '2024-10-18 09:00:00', 3, 17);
INSERT INTO public.user_project_score VALUES (1, 5, '2024-10-18 09:00:00', 149, '2024-10-18 09:00:00', 2, 17);
INSERT INTO public.user_project_score VALUES (1, 6, '2024-10-18 09:00:00', 150, '2024-10-18 09:00:00', 9, 17);
INSERT INTO public.user_project_score VALUES (2, 1, '2024-10-23 09:00:00', 151, '2024-10-23 09:00:00', 4, 17);
INSERT INTO public.user_project_score VALUES (2, 2, '2024-10-23 09:00:00', 152, '2024-10-23 09:00:00', 5, 17);
INSERT INTO public.user_project_score VALUES (2, 3, '2024-10-23 09:00:00', 153, '2024-10-23 09:00:00', 8, 17);
INSERT INTO public.user_project_score VALUES (2, 4, '2024-10-23 09:00:00', 154, '2024-10-23 09:00:00', 4, 17);
INSERT INTO public.user_project_score VALUES (2, 5, '2024-10-23 09:00:00', 155, '2024-10-23 09:00:00', 4, 17);
INSERT INTO public.user_project_score VALUES (2, 6, '2024-10-23 09:00:00', 156, '2024-10-23 09:00:00', 9, 17);
INSERT INTO public.user_project_score VALUES (3, 1, '2024-10-30 09:00:00', 157, '2024-10-30 09:00:00', 5, 17);
INSERT INTO public.user_project_score VALUES (3, 2, '2024-10-30 09:00:00', 158, '2024-10-30 09:00:00', 5, 17);
INSERT INTO public.user_project_score VALUES (3, 3, '2024-10-30 09:00:00', 159, '2024-10-30 09:00:00', 7, 17);
INSERT INTO public.user_project_score VALUES (3, 4, '2024-10-30 09:00:00', 160, '2024-10-30 09:00:00', 6, 17);
INSERT INTO public.user_project_score VALUES (3, 5, '2024-10-30 09:00:00', 161, '2024-10-30 09:00:00', 7, 17);
INSERT INTO public.user_project_score VALUES (3, 6, '2024-10-30 09:00:00', 162, '2024-10-30 09:00:00', 9, 17);
INSERT INTO public.user_project_score VALUES (4, 1, '2024-11-05 09:00:00', 163, '2024-11-05 09:00:00', 7, 17);
INSERT INTO public.user_project_score VALUES (4, 2, '2024-11-05 09:00:00', 164, '2024-11-05 09:00:00', 6, 17);
INSERT INTO public.user_project_score VALUES (4, 3, '2024-11-05 09:00:00', 165, '2024-11-05 09:00:00', 9, 17);
INSERT INTO public.user_project_score VALUES (4, 4, '2024-11-05 09:00:00', 166, '2024-11-05 09:00:00', 6, 17);
INSERT INTO public.user_project_score VALUES (4, 5, '2024-11-05 09:00:00', 167, '2024-11-05 09:00:00', 7, 17);
INSERT INTO public.user_project_score VALUES (4, 6, '2024-11-05 09:00:00', 168, '2024-11-05 09:00:00', 8, 17);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 169, '2024-11-13 09:00:00', 1, 1);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 170, '2024-11-13 09:00:00', 3, 1);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 171, '2024-11-13 09:00:00', 2, 1);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 172, '2024-11-13 09:00:00', 4, 1);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 173, '2024-11-13 09:00:00', 5, 1);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 174, '2024-11-13 09:00:00', 6, 1);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 175, '2024-11-13 09:00:00', 4, 8);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 176, '2024-11-13 09:00:00', 3, 8);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 177, '2024-11-13 09:00:00', 4, 8);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 178, '2024-11-13 09:00:00', 2, 8);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 179, '2024-11-13 09:00:00', 1, 8);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 180, '2024-11-13 09:00:00', 6, 8);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 181, '2024-11-13 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 182, '2024-11-13 09:00:00', 4, 7);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 183, '2024-11-13 09:00:00', 2, 7);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 184, '2024-11-13 09:00:00', 3, 7);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 185, '2024-11-13 09:00:00', 5, 7);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 186, '2024-11-13 09:00:00', 7, 7);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 187, '2024-11-13 09:00:00', 3, 6);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 188, '2024-11-13 09:00:00', 2, 6);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 189, '2024-11-13 09:00:00', 4, 6);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 190, '2024-11-13 09:00:00', 7, 6);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 191, '2024-11-13 09:00:00', 8, 6);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 192, '2024-11-13 09:00:00', 5, 6);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 193, '2024-11-13 09:00:00', 8, 12);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 194, '2024-11-13 09:00:00', 4, 12);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 195, '2024-11-13 09:00:00', 5, 12);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 196, '2024-11-13 09:00:00', 6, 12);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 197, '2024-11-13 09:00:00', 3, 12);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 198, '2024-11-13 09:00:00', 5, 12);
INSERT INTO public.user_project_score VALUES (5, 1, '2024-11-12 09:00:00', 199, '2024-11-13 09:00:00', 8, 13);
INSERT INTO public.user_project_score VALUES (5, 2, '2024-11-12 09:00:00', 200, '2024-11-13 09:00:00', 4, 13);
INSERT INTO public.user_project_score VALUES (5, 3, '2024-11-12 09:00:00', 201, '2024-11-13 09:00:00', 3, 13);
INSERT INTO public.user_project_score VALUES (5, 4, '2024-11-12 09:00:00', 202, '2024-11-13 09:00:00', 2, 13);
INSERT INTO public.user_project_score VALUES (5, 5, '2024-11-12 09:00:00', 203, '2024-11-13 09:00:00', 6, 13);
INSERT INTO public.user_project_score VALUES (5, 6, '2024-11-12 09:00:00', 204, '2024-11-13 09:00:00', 7, 13);
INSERT INTO public.user_project_score VALUES (6, 1, '2024-11-18 16:04:41.421636', 205, '2024-11-18 16:04:41.421636', 8, 18);
INSERT INTO public.user_project_score VALUES (6, 2, '2024-11-18 16:04:41.447729', 206, '2024-11-18 16:04:41.447729', 8, 18);
INSERT INTO public.user_project_score VALUES (6, 3, '2024-11-18 16:04:41.454252', 207, '2024-11-18 16:04:41.454252', 7, 18);
INSERT INTO public.user_project_score VALUES (6, 4, '2024-11-18 16:04:41.460416', 208, '2024-11-18 16:04:41.460416', 7, 18);
INSERT INTO public.user_project_score VALUES (6, 5, '2024-11-18 16:04:41.467359', 209, '2024-11-18 16:04:41.467359', 6, 18);
INSERT INTO public.user_project_score VALUES (6, 6, '2024-11-18 16:04:41.474697', 210, '2024-11-18 16:04:41.474697', 7, 18);


--
-- TOC entry 3870 (class 0 OID 35590)
-- Dependencies: 265
-- Data for Name: webhook_channel; Type: TABLE DATA; Schema: public; Owner: reviewping
--

INSERT INTO public.webhook_channel VALUES (1, '2024-11-14 15:32:07.049022', 1, '2024-11-14 15:32:07.049022', 1, 'https://meeting.ssafy.com/hooks/zhepiqizm3gtte9cxofzop58sw');


--
-- TOC entry 3880 (class 0 OID 0)
-- Dependencies: 218
-- Name: badge_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.badge_id_seq', 1, false);


--
-- TOC entry 3881 (class 0 OID 0)
-- Dependencies: 222
-- Name: batch_job_execution_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.batch_job_execution_seq', 2, true);


--
-- TOC entry 3882 (class 0 OID 0)
-- Dependencies: 224
-- Name: batch_job_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.batch_job_seq', 2, true);


--
-- TOC entry 3883 (class 0 OID 0)
-- Dependencies: 227
-- Name: batch_step_execution_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.batch_step_execution_seq', 2, true);


--
-- TOC entry 3884 (class 0 OID 0)
-- Dependencies: 229
-- Name: best_mr_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.best_mr_history_id_seq', 1, false);


--
-- TOC entry 3885 (class 0 OID 0)
-- Dependencies: 231
-- Name: branch_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.branch_id_seq', 5, true);


--
-- TOC entry 3886 (class 0 OID 0)
-- Dependencies: 235
-- Name: code_quality_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.code_quality_id_seq', 1, false);


--
-- TOC entry 3887 (class 0 OID 0)
-- Dependencies: 237
-- Name: custom_prompt_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.custom_prompt_id_seq', 2, true);


--
-- TOC entry 3888 (class 0 OID 0)
-- Dependencies: 239
-- Name: gitlab_account_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.gitlab_account_id_seq', 18, true);


--
-- TOC entry 3889 (class 0 OID 0)
-- Dependencies: 242
-- Name: language_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.language_id_seq', 17, true);


--
-- TOC entry 3890 (class 0 OID 0)
-- Dependencies: 244
-- Name: login_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.login_history_id_seq', 51, true);


--
-- TOC entry 3891 (class 0 OID 0)
-- Dependencies: 246
-- Name: mr_info_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.mr_info_id_seq', 74, true);


--
-- TOC entry 3892 (class 0 OID 0)
-- Dependencies: 267
-- Name: notification_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.notification_id_seq', 26, true);


--
-- TOC entry 3893 (class 0 OID 0)
-- Dependencies: 248
-- Name: project_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.project_id_seq', 2, true);


--
-- TOC entry 3894 (class 0 OID 0)
-- Dependencies: 250
-- Name: prompt_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.prompt_history_id_seq', 44, true);


--
-- TOC entry 3895 (class 0 OID 0)
-- Dependencies: 252
-- Name: retrieval_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.retrieval_id_seq', 1568, true);


--
-- TOC entry 3896 (class 0 OID 0)
-- Dependencies: 254
-- Name: review_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.review_id_seq', 282, true);


--
-- TOC entry 3897 (class 0 OID 0)
-- Dependencies: 256
-- Name: software_quality_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.software_quality_id_seq', 1, false);


--
-- TOC entry 3898 (class 0 OID 0)
-- Dependencies: 259
-- Name: user_badge_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.user_badge_id_seq', 53, true);


--
-- TOC entry 3899 (class 0 OID 0)
-- Dependencies: 260
-- Name: user_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.user_id_seq', 15, true);


--
-- TOC entry 3900 (class 0 OID 0)
-- Dependencies: 262
-- Name: user_project_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.user_project_id_seq', 18, true);


--
-- TOC entry 3901 (class 0 OID 0)
-- Dependencies: 264
-- Name: user_project_score_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.user_project_score_id_seq', 210, true);


--
-- TOC entry 3902 (class 0 OID 0)
-- Dependencies: 266
-- Name: webhook_channel_id_seq; Type: SEQUENCE SET; Schema: public; Owner: reviewping
--

SELECT pg_catalog.setval('public.webhook_channel_id_seq', 1, true);


--
-- TOC entry 3583 (class 2606 OID 35595)
-- Name: badge_code badge_code_name_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.badge_code
    ADD CONSTRAINT badge_code_name_key UNIQUE (name);


--
-- TOC entry 3585 (class 2606 OID 35597)
-- Name: badge_code badge_code_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.badge_code
    ADD CONSTRAINT badge_code_pkey PRIMARY KEY (id);


--
-- TOC entry 3579 (class 2606 OID 35599)
-- Name: badge badge_name_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.badge
    ADD CONSTRAINT badge_name_key UNIQUE (name);


--
-- TOC entry 3581 (class 2606 OID 35601)
-- Name: badge badge_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.badge
    ADD CONSTRAINT badge_pkey PRIMARY KEY (id);


--
-- TOC entry 3589 (class 2606 OID 35603)
-- Name: batch_job_execution_context batch_job_execution_context_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_execution_context
    ADD CONSTRAINT batch_job_execution_context_pkey PRIMARY KEY (job_execution_id);


--
-- TOC entry 3587 (class 2606 OID 35605)
-- Name: batch_job_execution batch_job_execution_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_execution
    ADD CONSTRAINT batch_job_execution_pkey PRIMARY KEY (job_execution_id);


--
-- TOC entry 3591 (class 2606 OID 35607)
-- Name: batch_job_instance batch_job_instance_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_instance
    ADD CONSTRAINT batch_job_instance_pkey PRIMARY KEY (job_instance_id);


--
-- TOC entry 3597 (class 2606 OID 35609)
-- Name: batch_step_execution_context batch_step_execution_context_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_step_execution_context
    ADD CONSTRAINT batch_step_execution_context_pkey PRIMARY KEY (step_execution_id);


--
-- TOC entry 3595 (class 2606 OID 35611)
-- Name: batch_step_execution batch_step_execution_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_step_execution
    ADD CONSTRAINT batch_step_execution_pkey PRIMARY KEY (step_execution_id);


--
-- TOC entry 3599 (class 2606 OID 35613)
-- Name: best_mr_history best_mr_history_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.best_mr_history
    ADD CONSTRAINT best_mr_history_pkey PRIMARY KEY (id);


--
-- TOC entry 3601 (class 2606 OID 35615)
-- Name: branch branch_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.branch
    ADD CONSTRAINT branch_pkey PRIMARY KEY (id);


--
-- TOC entry 3603 (class 2606 OID 35617)
-- Name: channel_code channel_code_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.channel_code
    ADD CONSTRAINT channel_code_pkey PRIMARY KEY (id);


--
-- TOC entry 3607 (class 2606 OID 35619)
-- Name: code_quality_code code_quality_code_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.code_quality_code
    ADD CONSTRAINT code_quality_code_pkey PRIMARY KEY (id);


--
-- TOC entry 3605 (class 2606 OID 35621)
-- Name: code_quality code_quality_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.code_quality
    ADD CONSTRAINT code_quality_pkey PRIMARY KEY (id);


--
-- TOC entry 3609 (class 2606 OID 35623)
-- Name: custom_prompt custom_prompt_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.custom_prompt
    ADD CONSTRAINT custom_prompt_pkey PRIMARY KEY (id);


--
-- TOC entry 3611 (class 2606 OID 35625)
-- Name: custom_prompt custom_prompt_project_id_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.custom_prompt
    ADD CONSTRAINT custom_prompt_project_id_key UNIQUE (project_id);


--
-- TOC entry 3613 (class 2606 OID 35627)
-- Name: gitlab_account gitlab_account_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.gitlab_account
    ADD CONSTRAINT gitlab_account_pkey PRIMARY KEY (id);


--
-- TOC entry 3615 (class 2606 OID 35629)
-- Name: gitlab_account gitlab_account_user_token_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.gitlab_account
    ADD CONSTRAINT gitlab_account_user_token_key UNIQUE (user_token);


--
-- TOC entry 3593 (class 2606 OID 35631)
-- Name: batch_job_instance job_inst_un; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_instance
    ADD CONSTRAINT job_inst_un UNIQUE (job_name, job_key);


--
-- TOC entry 3619 (class 2606 OID 35633)
-- Name: language_code language_code_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.language_code
    ADD CONSTRAINT language_code_pkey PRIMARY KEY (id);


--
-- TOC entry 3617 (class 2606 OID 35635)
-- Name: language language_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.language
    ADD CONSTRAINT language_pkey PRIMARY KEY (id);


--
-- TOC entry 3621 (class 2606 OID 35637)
-- Name: login_history login_history_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.login_history
    ADD CONSTRAINT login_history_pkey PRIMARY KEY (id);


--
-- TOC entry 3623 (class 2606 OID 35639)
-- Name: mr_info mr_info_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.mr_info
    ADD CONSTRAINT mr_info_pkey PRIMARY KEY (id);


--
-- TOC entry 3655 (class 2606 OID 36290)
-- Name: notification notification_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.notification
    ADD CONSTRAINT notification_pkey PRIMARY KEY (id);


--
-- TOC entry 3625 (class 2606 OID 35641)
-- Name: project project_bot_token_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.project
    ADD CONSTRAINT project_bot_token_key UNIQUE (bot_token);


--
-- TOC entry 3627 (class 2606 OID 35643)
-- Name: project project_gitlab_project_id_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.project
    ADD CONSTRAINT project_gitlab_project_id_key UNIQUE (gitlab_project_id);


--
-- TOC entry 3629 (class 2606 OID 35645)
-- Name: project project_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.project
    ADD CONSTRAINT project_pkey PRIMARY KEY (id);


--
-- TOC entry 3631 (class 2606 OID 35647)
-- Name: prompt_history prompt_history_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.prompt_history
    ADD CONSTRAINT prompt_history_pkey PRIMARY KEY (id);


--
-- TOC entry 3633 (class 2606 OID 35649)
-- Name: retrieval retrieval_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.retrieval
    ADD CONSTRAINT retrieval_pkey PRIMARY KEY (id);


--
-- TOC entry 3635 (class 2606 OID 35651)
-- Name: review review_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.review
    ADD CONSTRAINT review_pkey PRIMARY KEY (id);


--
-- TOC entry 3637 (class 2606 OID 35653)
-- Name: software_quality software_quality_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.software_quality
    ADD CONSTRAINT software_quality_pkey PRIMARY KEY (id);


--
-- TOC entry 3645 (class 2606 OID 35655)
-- Name: user_badge user_badge_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_badge
    ADD CONSTRAINT user_badge_pkey PRIMARY KEY (id);


--
-- TOC entry 3639 (class 2606 OID 35657)
-- Name: user user_oauth2id_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_oauth2id_key UNIQUE (oauth2id);


--
-- TOC entry 3641 (class 2606 OID 35659)
-- Name: user user_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- TOC entry 3647 (class 2606 OID 35661)
-- Name: user_project user_project_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project
    ADD CONSTRAINT user_project_pkey PRIMARY KEY (id);


--
-- TOC entry 3649 (class 2606 OID 35663)
-- Name: user_project_score user_project_score_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project_score
    ADD CONSTRAINT user_project_score_pkey PRIMARY KEY (id);


--
-- TOC entry 3643 (class 2606 OID 35665)
-- Name: user user_username_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_username_key UNIQUE (username);


--
-- TOC entry 3651 (class 2606 OID 35667)
-- Name: webhook_channel webhook_channel_pkey; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.webhook_channel
    ADD CONSTRAINT webhook_channel_pkey PRIMARY KEY (id);


--
-- TOC entry 3653 (class 2606 OID 35669)
-- Name: webhook_channel webhook_channel_webhook_url_key; Type: CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.webhook_channel
    ADD CONSTRAINT webhook_channel_webhook_url_key UNIQUE (webhook_url);


--
-- TOC entry 3661 (class 2606 OID 35670)
-- Name: branch fk1sg3b030lhwn3huugkpnja4sh; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.branch
    ADD CONSTRAINT fk1sg3b030lhwn3huugkpnja4sh FOREIGN KEY (project_id) REFERENCES public.project(id);


--
-- TOC entry 3669 (class 2606 OID 35675)
-- Name: user_badge fk3kqh48j7xuqeaodv4nc7kg5en; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_badge
    ADD CONSTRAINT fk3kqh48j7xuqeaodv4nc7kg5en FOREIGN KEY (user_id) REFERENCES public."user"(id);


--
-- TOC entry 3671 (class 2606 OID 35680)
-- Name: user_project fk465j69qxsk6c5wjuleymo9nej; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project
    ADD CONSTRAINT fk465j69qxsk6c5wjuleymo9nej FOREIGN KEY (gitlab_account_id) REFERENCES public.gitlab_account(id);


--
-- TOC entry 3668 (class 2606 OID 35685)
-- Name: user fk4sivv5693w6gt5680cucppo9u; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT fk4sivv5693w6gt5680cucppo9u FOREIGN KEY (main_badge_code_id) REFERENCES public.badge_code(id);


--
-- TOC entry 3677 (class 2606 OID 36291)
-- Name: notification fk6mvn0cus30t77bvav87nvsmvr; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.notification
    ADD CONSTRAINT fk6mvn0cus30t77bvav87nvsmvr FOREIGN KEY (user_project_id) REFERENCES public.user_project(id);


--
-- TOC entry 3665 (class 2606 OID 35690)
-- Name: retrieval fk6ou78lssjxudgaowcplf5ubil; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.retrieval
    ADD CONSTRAINT fk6ou78lssjxudgaowcplf5ubil FOREIGN KEY (review_id) REFERENCES public.review(id);


--
-- TOC entry 3666 (class 2606 OID 35695)
-- Name: retrieval fk90aylqt3mkreqno0doq5j4uvq; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.retrieval
    ADD CONSTRAINT fk90aylqt3mkreqno0doq5j4uvq FOREIGN KEY (language_id) REFERENCES public.language(id);


--
-- TOC entry 3662 (class 2606 OID 35700)
-- Name: custom_prompt fk9e2791cwnxch58aayu29xwxvq; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.custom_prompt
    ADD CONSTRAINT fk9e2791cwnxch58aayu29xwxvq FOREIGN KEY (project_id) REFERENCES public.project(id);


--
-- TOC entry 3667 (class 2606 OID 35705)
-- Name: review fka2rtfco3g9vyaj5fehk8uj8t; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.review
    ADD CONSTRAINT fka2rtfco3g9vyaj5fehk8uj8t FOREIGN KEY (mr_info_id) REFERENCES public.mr_info(id);


--
-- TOC entry 3670 (class 2606 OID 35710)
-- Name: user_badge fkbacqtjrcysllkw9b97fe3gick; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_badge
    ADD CONSTRAINT fkbacqtjrcysllkw9b97fe3gick FOREIGN KEY (badge_code_id) REFERENCES public.badge_code(id);


--
-- TOC entry 3675 (class 2606 OID 35715)
-- Name: webhook_channel fkdj3tpg13q3pqrsj3x35xrm0yb; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.webhook_channel
    ADD CONSTRAINT fkdj3tpg13q3pqrsj3x35xrm0yb FOREIGN KEY (project_id) REFERENCES public.project(id);


--
-- TOC entry 3663 (class 2606 OID 35720)
-- Name: gitlab_account fke6n3nhxauxldn3b4ni22dto1e; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.gitlab_account
    ADD CONSTRAINT fke6n3nhxauxldn3b4ni22dto1e FOREIGN KEY (user_id) REFERENCES public."user"(id);


--
-- TOC entry 3673 (class 2606 OID 35725)
-- Name: user_project_score fkikmobnuqwo3r24qr5ug4kqink; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project_score
    ADD CONSTRAINT fkikmobnuqwo3r24qr5ug4kqink FOREIGN KEY (code_quality_code_id) REFERENCES public.code_quality_code(id);


--
-- TOC entry 3674 (class 2606 OID 35730)
-- Name: user_project_score fkinbpgfontrgkh0jhs96wweaei; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project_score
    ADD CONSTRAINT fkinbpgfontrgkh0jhs96wweaei FOREIGN KEY (user_project_id) REFERENCES public.user_project(id);


--
-- TOC entry 3676 (class 2606 OID 35735)
-- Name: webhook_channel fko6i8fo8nxil2w3ui015rtmr3q; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.webhook_channel
    ADD CONSTRAINT fko6i8fo8nxil2w3ui015rtmr3q FOREIGN KEY (channel_code_id) REFERENCES public.channel_code(id);


--
-- TOC entry 3672 (class 2606 OID 35740)
-- Name: user_project fkocfkr6u2yh3w1qmybs8vxuv1c; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.user_project
    ADD CONSTRAINT fkocfkr6u2yh3w1qmybs8vxuv1c FOREIGN KEY (project_id) REFERENCES public.project(id);


--
-- TOC entry 3664 (class 2606 OID 35745)
-- Name: mr_info fkqb2a8qef7in7ruv0mjrxtiwii; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.mr_info
    ADD CONSTRAINT fkqb2a8qef7in7ruv0mjrxtiwii FOREIGN KEY (project_id) REFERENCES public.project(id);


--
-- TOC entry 3657 (class 2606 OID 35750)
-- Name: batch_job_execution_context job_exec_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_execution_context
    ADD CONSTRAINT job_exec_ctx_fk FOREIGN KEY (job_execution_id) REFERENCES public.batch_job_execution(job_execution_id);


--
-- TOC entry 3658 (class 2606 OID 35755)
-- Name: batch_job_execution_params job_exec_params_fk; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_execution_params
    ADD CONSTRAINT job_exec_params_fk FOREIGN KEY (job_execution_id) REFERENCES public.batch_job_execution(job_execution_id);


--
-- TOC entry 3659 (class 2606 OID 35760)
-- Name: batch_step_execution job_exec_step_fk; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_step_execution
    ADD CONSTRAINT job_exec_step_fk FOREIGN KEY (job_execution_id) REFERENCES public.batch_job_execution(job_execution_id);


--
-- TOC entry 3656 (class 2606 OID 35765)
-- Name: batch_job_execution job_inst_exec_fk; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_job_execution
    ADD CONSTRAINT job_inst_exec_fk FOREIGN KEY (job_instance_id) REFERENCES public.batch_job_instance(job_instance_id);


--
-- TOC entry 3660 (class 2606 OID 35770)
-- Name: batch_step_execution_context step_exec_ctx_fk; Type: FK CONSTRAINT; Schema: public; Owner: reviewping
--

ALTER TABLE ONLY public.batch_step_execution_context
    ADD CONSTRAINT step_exec_ctx_fk FOREIGN KEY (step_execution_id) REFERENCES public.batch_step_execution(step_execution_id);


-- Completed on 2024-11-18 16:11:09

--
-- PostgreSQL database dump complete
--

